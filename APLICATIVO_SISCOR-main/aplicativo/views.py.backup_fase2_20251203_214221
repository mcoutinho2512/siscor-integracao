# -*- coding: utf-8 -*-
"""
SISCOR - Views
Sistema Integrado do Centro de Opera√ß√µes Rio
"""

import re
import random
import base64
import logging
import urllib3
import requests
from functools import lru_cache
from datetime import datetime, timedelta

from django.shortcuts import render
from django.http import JsonResponse, HttpResponse
from django.views.decorators.cache import cache_page, never_cache
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.decorators import login_required
from django.utils import timezone

from rest_framework.decorators import api_view
from rest_framework.response import Response

from .models import (
    Sirene,
    DadosSirene,
    Estagio,
    ChuvaConsolidado,
    Evento,
    Ocorrencias,
    EstacaoPlv,
    DadosPlv,
    EstacaoMet,
    DadosMet,
    EscolasMunicipais,
    BensProtegidos,
    Calor
)

# Configura√ß√£o do Logger
logger = logging.getLogger(__name__)

def teste_sem_login(request):
    """Teste sem login"""
    from django.http import HttpResponse
    return HttpResponse('<h1>FUNCIONOU! SEM LOGIN!</h1>')

# ============================================
# VIEWS DE P√ÅGINAS
# ============================================

@login_required(login_url='login')
@never_cache
def waze_dashboard_view(request):
    """Dashboard principal do mapa"""
    return render(request, 'mapa_novo/waze_dashboard.html')

# ============================================
# APIs - SIRENES
# ============================================

@never_cache
def sirene_api(request):
    """
    API de Sirenes - Retorna APENAS sirenes ATIVAS/ACIONADAS
    Filtro:
    - Fonte COR: status == "ativa"
    - Fonte Defesa Civil: tipo != "Desligada"
    """
    try:
        lista_estacoes = []
        sirenes = Sirene.objects.all()

        for sirene in sirenes:
            try:
                # Pegar √∫ltimo dado da sirene
                dados = DadosSirene.objects.filter(estacao_id=sirene.id).latest('id')

                status = dados.status if hasattr(dados, 'status') else "inativa"
                tipo = dados.tipo if hasattr(dados, 'tipo') else "Desligada"
                fonte = sirene.fonte if hasattr(sirene, 'fonte') else "COR"
                
                # ‚úÖ FILTRO: Apenas sirenes ativas
                if fonte == "COR":
                    # Fonte COR: status deve ser "ativa"
                    if status.lower() != "ativa":
                        continue  # Pular esta sirene
                else:
                    # Fonte Defesa Civil: tipo deve ser diferente de "Desligada"
                    if tipo == "Desligada":
                        continue  # Pular esta sirene

                # Se passou pelo filtro, adicionar
                lista_estacoes.append({
                    "id": sirene.id,
                    "fonte": fonte,
                    "lat": float(sirene.lat) if sirene.lat else -22.9068,
                    "lng": float(sirene.lon) if sirene.lon else -43.1729,
                    "nome": sirene.nome,
                    "cidade": sirene.municipio if hasattr(sirene, 'municipio') else "Rio de Janeiro",
                    "status": status,
                    "tipo": tipo,
                    "prioridade": tipo
                })
                
            except DadosSirene.DoesNotExist:
                # Se n√£o tem dados, considerar como inativa e pular
                continue

        # Ordenar por tipo (prioridade)
        lista_ordenada = sorted(lista_estacoes, key=lambda k: k.get('tipo', 'baixa'), reverse=True)
        
        ativas = len(lista_ordenada)
        logger.info(f"üö® {ativas} sirenes ATIVAS no momento")

        return JsonResponse({
            'success': True,
            'count': ativas,
            'ativas': ativas,
            'data': lista_ordenada
        })

    except Exception as e:
        logger.error(f"‚ùå Erro na API de sirenes: {str(e)}")
        return JsonResponse({
            'success': False,
            'error': str(e),
            'data': []
        }, status=500)


# ============================================
# APIs - EST√ÅGIOS DE MOBILIDADE
# ============================================

@never_cache
def estagio_api(request):
    """
    API de Est√°gios de Mobilidade
    Retorna o est√°gio atual da cidade
    """
    try:
        av = Estagio.objects.latest('id')

        # Extrair n√∫mero do texto "N√≠vel X"
        estagio_texto = av.esta or 'N√≠vel 1'
        match = re.search(r'(\d+)', estagio_texto)
        nivel = int(match.group(1)) if match else 1

        # Mapeamento de cores por n√≠vel
        cores_map = {
            1: '#228d46',  # Verde - Normalidade
            2: '#f5c520',  # Amarelo - Aten√ß√£o
            3: '#ef8c3f',  # Laranja - Alerta
            4: '#d0262d',  # Vermelho - Alerta M√°ximo
            5: '#5f2f7e'   # Roxo - Crise
        }

        nomes_map = {
            1: 'Normalidade',
            2: 'Aten√ß√£o',
            3: 'Alerta',
            4: 'Alerta M√°ximo',
            5: 'Crise'
        }

        return JsonResponse({
            'success': True,
            'estagio': estagio_texto,
            'estagio_id': nivel,
            'nivel': nivel,
            'cor': cores_map.get(nivel, '#228d46'),
            'nome': nomes_map.get(nivel, 'Normalidade'),
            'mensagem': av.men if hasattr(av, 'men') else '',
            'inicio': av.data_i.isoformat() if hasattr(av, 'data_i') and av.data_i else None,
            'data_atualizacao': datetime.now().isoformat()
        })

    except Estagio.DoesNotExist:
        return JsonResponse({
            'success': True,
            'estagio': 'N√≠vel 1',
            'estagio_id': 1,
            'nivel': 1,
            'cor': '#228d46',
            'nome': 'Normalidade',
            'mensagem': 'Sistema operando normalmente',
            'inicio': None,
            'data_atualizacao': datetime.now().isoformat()
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@csrf_exempt
def estagio_api_app(request):
    """API de est√°gio para app mobile (formato simplificado)"""
    try:
        av = Estagio.objects.latest('id')
        estagio = av.esta.upper()
        return HttpResponse(estagio)
    except:
        return HttpResponse("NORMALIDADE")


# ============================================
# APIs - CHUVA/METEOROLOGIA
# ============================================

@cache_page(60 * 5)  # Cache de 5 minutos
def chuva_api(request):
    """
    API de Dados de Chuva
    Retorna √∫ltimo consolidado de chuva
    """
    try:
        consolidado = ChuvaConsolidado.objects.latest('id')

        return JsonResponse({
            'success': True,
            'data': {
                'id': consolidado.id,
                'valor': str(consolidado) if consolidado else 'N/A',
                'data_atualizacao': datetime.now().isoformat()
            }
        })
    except ChuvaConsolidado.DoesNotExist:
        return JsonResponse({
            'success': True,
            'data': {
                'valor': 'Sem dados',
                'data_atualizacao': datetime.now().isoformat()
            }
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


# ============================================
# APIs - EVENTOS
# ============================================

@never_cache
def api_eventos(request):
    """API de eventos da cidade"""
    try:
        eventos = Evento.objects.all()[:50]  # √öltimos 50 eventos

        data = []
        for evento in eventos:
            data.append({
                'id': evento.id,
                'nome': evento.nome if hasattr(evento, 'nome') else 'Evento',
                'tipo': evento.tipo if hasattr(evento, 'tipo') else 'geral',
                'lat': float(evento.lat) if hasattr(evento, 'lat') and evento.lat else -22.9068,
                'lng': float(evento.lon) if hasattr(evento, 'lon') and evento.lon else -43.1729,
                'data': evento.data.isoformat() if hasattr(evento, 'data') and evento.data else None,
                'prioridade': evento.prioridade if hasattr(evento, 'prioridade') else 'media',
                'local': evento.local if hasattr(evento, 'local') else ''
            })

        return JsonResponse({
            'success': True,
            'count': len(data),
            'data': data
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e),
            'data': []
        }, status=500)


# ============================================
# APIs - OCORR√äNCIAS
# ============================================

@api_view(['GET'])
def api_ocorrencias_hoje(request):
    """
    API REST - Ocorr√™ncias de HOJE
    Usando o modelo Ocorrencias existente
    """
    try:
        # Data de hoje
        hoje = timezone.now().date()
        inicio_dia = timezone.make_aware(datetime.combine(hoje, datetime.min.time()))
        fim_dia = timezone.make_aware(datetime.combine(hoje, datetime.max.time()))
        
        # Buscar ocorr√™ncias ABERTAS (n√£o conclu√≠das)
        ocorrencias = Ocorrencias.objects.exclude(
        status='Conclu√≠do'
        ).order_by('-data') 
        
        total = ocorrencias.count()
        
        # Mapear prioridades para cores
        cores_prioridade = {
            'SECUND√ÅRIO': '#10b981',  # Verde
            'BAIXO': '#10b981',        # Verde
            'MEDIO': '#f59e0b',        # Amarelo
            'ALTO': '#ef4444',         # Vermelho
            'CRITICO': '#991b1b',      # Vermelho escuro
        }
        
        # Mapear tipos para √≠cones
        icones_tipo = {
            'ACIDENTE': 'bi-car-front-fill',
            'ALAGAMENTO': 'bi-water',
            'DESLIZAMENTO': 'bi-exclamation-triangle-fill',
            'QUEDA DE √ÅRVORE': 'bi-tree-fill',
            'INC√äNDIO': 'bi-fire',
            'VAZAMENTO': 'bi-droplet-fill',
            'BURACO': 'bi-sign-stop-fill',
        }
        
        # Formatar dados
        dados = []
        for occ in ocorrencias:
            # Determinar √≠cone baseado no tipo de incidente
            icone = 'bi-exclamation-circle-fill'  # padr√£o
            if occ.incidente:
                incidente_upper = occ.incidente.upper()
                for key, icon in icones_tipo.items():
                    if key in incidente_upper:
                        icone = icon
                        break
            
            dados.append({
                'id': occ.id,
                'id_c': occ.id_c or '',
                'tipo': occ.incidente or 'Outros',
                'descricao': occ.obs or 'Sem descri√ß√£o',
                'endereco': occ.log or 'Endere√ßo n√£o informado',
                'bairro': occ.bairro or '',
                'lat': float(occ.lat) if occ.lat else None,
                'lng': float(occ.lon) if occ.lon else None,
                'prioridade': occ.prio or 'MEDIO',
                'cor_prioridade': cores_prioridade.get(occ.prio, '#6b7280'),
                'status': occ.status or 'Acionado',
                'icone': icone,
                'data_criacao': occ.data.isoformat() if occ.data else None,
                'esta_aberta': occ.status != 'Conclu√≠do' if occ.status else True,
            })
        
        # Estat√≠sticas
        abertas = ocorrencias.exclude(status='Conclu√≠do').count()
        concluidas = ocorrencias.filter(status='Conclu√≠do').count()
        
        return Response({
            'success': True,
            'data': dados,
            'estatisticas': {
                'total': total,
                'abertas': abertas,
                'concluidas': concluidas,
            },
            'filtro': {
                'tipo': 'hoje',
                'data': hoje.isoformat(),
            },
            'timestamp': timezone.now().isoformat(),
        })
        
    except Exception as e:
        logger.error(f'‚ùå Erro ao buscar ocorr√™ncias: {str(e)}', exc_info=True)
        return Response({
            'success': False,
            'error': str(e),
            'data': [],
        }, status=500)

@csrf_exempt
def api_ocorrencias(request):
    """
    API de ocorr√™ncias - APENAS DO DIA ATUAL
    """
    try:
        from django.utils import timezone  # ‚Üê Importar do Django
        
        # MOSTRAR TODAS AS ABERTAS
        ocorrencias = Ocorrencias.objects.exclude(
        status='Conclu√≠do'
        ).order_by('-data')  # Mais recentes primeiro   
        
        total = ocorrencias.count()
        
        data = []
        for ocorrencia in ocorrencias:
            data.append({
                'id': ocorrencia.id,
                'id_c': ocorrencia.id_c,
                'incidente': ocorrencia.incidente,
                'location': ocorrencia.location,
                'lat': float(ocorrencia.lat) if ocorrencia.lat else None,
                'lon': float(ocorrencia.lon) if ocorrencia.lon else None,
                'prio': ocorrencia.prio,
                'status': ocorrencia.status,
                'data': ocorrencia.data.isoformat() if ocorrencia.data else None,
            })
        
        return JsonResponse({
            'success': True,
            'data': data,
            'count': total,
            'filtro': 'hoje',
            'data_filtro': hoje.isoformat()
        })
        
    except Exception as e:
        logger.error(f'Erro ao buscar ocorr√™ncias: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': str(e),
            'data': []
        }, status=500)

# ============================================
# APIs - OUTRAS (Placeholder para expans√£o futura)
# ============================================

def api_escolas(request):
    """API de escolas (placeholder)"""
    return JsonResponse({'success': True, 'count': 0, 'data': []})

def api_hospitais(request):
    """API de hospitais (placeholder)"""
    return JsonResponse({'success': True, 'count': 0, 'data': []})


def waze_dashboard_completo(request):
    """Dashboard completo com todas as estat√≠sticas"""
    context = {
        'tamanho_4': 0,
        'pc': 0,
        'color_pc': '228d46',
        'hist': 0,
        'unz': [],
        'qt_unz': 0,
        'baixo_v': 0,
        'medio_v': 0,
        'alto_v': 0,
        'lista_estacoes_plv': [],
        'jams_linha': [],
        'escolas': [],
        'hospitais': [],
        'eventos': [],
        'ocorrencias': [],
        'sirenes': [],
        'abrigos': [],
        'alagamentos': [],
        'bens': [],
        'chuva': [],
        'lista_pontos': [],
        'sensores': []
    }

    return render(request, 'mapa_novo/waze_dashboard.html', context)

@login_required(login_url='login')
@never_cache
def cor_dashboard_view(request):
    """Dashboard com design COR profissional"""
    return render(request, 'mapa_novo/cor_dashboard.html')



@api_view(['GET'])
def pluviometros_view(request):
    """API de pluvi√¥metros - VERS√ÉO CORRIGIDA"""
    try:
        from aplicativo.models import DadosPlv
        from django.utils import timezone
        from datetime import datetime
        
        hoje = timezone.now().date()
        inicio = timezone.make_aware(datetime.combine(hoje, datetime.min.time()))
        fim = timezone.make_aware(datetime.combine(hoje, datetime.max.time()))
        
        leituras = DadosPlv.objects.filter(
            data_t__gte=inicio,
            data_t__lte=fim
        ).select_related('estacao')
        
        dados = {}
        for l in leituras:
            if l.estacao.id_e not in dados:
                dados[l.estacao.id_e] = {
                    'id': l.estacao.id,
                    'nome': l.estacao.nome,
                    'lat': float(l.estacao.lat or 0),
                    'lng': float(l.estacao.lon or 0),
                    'chuva_1h': float(l.chuva_1 or 0),
                    'chuva_4h': float(l.chuva_4 or 0),
                    'chuva_24h': float(l.chuva_24 or 0),
                    'chuva_96h': float(l.chuva_96 or 0),
                    'data': l.data_t.isoformat(),
                    'status': 'ativa'
                }
        
        return Response({
            'success': True,
            'data': list(dados.values()),
            'count': len(dados),
            'filtro': f'HOJE - {hoje}'
        })
    except Exception as e:
        return Response({'success': False, 'error': str(e)}, status=500)
    

@api_view(['GET'])
def estacoes_vento_view(request):
    """API de Esta√ß√µes de Vento - Velocidade convertida para km/h"""
    try:
        data = []
        estacoes = EstacaoMet.objects.all()

        for estacao in estacoes:
            if estacao.lat and estacao.lon:
                ultimo = DadosMet.objects.filter(estacao=estacao).order_by('-data').first()

                if ultimo:
                    # ‚úÖ Converter m/s ‚Üí km/h (multiplicar por 3.6)
                    velocidade_ms = float(ultimo.vel or 0)
                    velocidade_kmh = round(velocidade_ms * 3.6, 1)  # Arredondar para 1 casa decimal
                    
                    data.append({
                        'id': estacao.id,
                        'nome': estacao.nome,
                        'lat': float(estacao.lat),
                        'lng': float(estacao.lon),
                        'temperatura': float(ultimo.temp or 0),
                        'umidade': float(ultimo.umd or 0),
                        'direcao': str(ultimo.dire) if ultimo.dire else 'N/A',
                        'velocidade': velocidade_kmh,  # ‚Üê Agora em km/h
                        'velocidade_ms': velocidade_ms,  # ‚Üê Original em m/s (opcional)
                        'data': str(ultimo.data) if ultimo.data else 'N/A',
                        'status': 'ativa'
                    })

        return Response({
            'success': True,
            'data': data,
            'count': len(data)
        })

    except Exception as e:
        import traceback
        logger.error(f'‚ùå Erro API ventos: {e}')
        print(traceback.format_exc())
        return Response({
            'success': False,
            'error': str(e),
            'data': []
        }, status=500)


@api_view(['GET'])
def escolas_view(request):
    """API de Escolas Municipais"""
    print('DEBUG: escolas_view foi chamada!')
    escolas_list = list(EscolasMunicipais.objects.all())
    print(f'DEBUG: Encontradas {len(escolas_list)} escolas')

    data = []
    for escola in escolas_list:
        print(f'DEBUG: Processando {escola.nome} - x={escola.x}, y={escola.y}')
        data.append({
            'id': escola.id,
            'nome': escola.nome,
            'lat': float(escola.y),
            'lng': float(escola.x),
            'endereco': str(escola.endereco or 'N/A'),
            'bairro': str(escola.bairro or 'N/A'),
            'telefone': str(escola.telefone or 'N/A'),
            'tipo': 'escola_municipal'
        })

    print(f'DEBUG: Retornando {len(data)} escolas')
    return Response({'success': True, 'data': data, 'count': len(data)})


@api_view(['GET'])
def bens_tombados_view(request):
    """API de Bens Tombados"""
    try:
        data = []
        bens = BensProtegidos.objects.all()

        for bem in bens:
            if bem.y and bem.x:
                data.append({
                    'id': bem.id,
                    'nome': bem.np or 'Bem Tombado',
                    'lat': float(bem.y),
                    'lng': float(bem.x),
                    'rua': bem.rua or 'N/A',
                    'grau': bem.grau_de_pr or 'N/A',
                    'tipo': 'bem_tombado'
                })

        return Response({'success': True, 'data': data, 'count': len(data)})
    except Exception as e:
        return Response({'success': False, 'error': str(e), 'data': []}, status=500)


@api_view(['GET'])
def api_estagio(request):
    """API de est√°gio - formato novo"""
    try:
        # Buscar √∫ltimo est√°gio
        ultimo = Estagio.objects.filter(
            data_f__isnull=True
        ).order_by('-data_i').first()

        if not ultimo:
            ultimo = Estagio.objects.order_by('-data_i').first()

        if ultimo:
            # Extrair n√∫mero do est√°gio
            estagio_texto = ultimo.esta or 'N√≠vel 1'
            match = re.search(r'(\d+)', estagio_texto)
            nivel = int(match.group(1)) if match else 1

            # Mapear cores
            cores_map = {
                1: '#228d46',
                2: '#f5c520',
                3: '#ef8c3f',
                4: '#d0262d',
                5: '#5f2f7e'
            }

            descricoes_map = {
                1: 'Normalidade',
                2: 'Aten√ß√£o',
                3: 'Alerta',
                4: 'Alerta M√°ximo',
                5: 'Crise'
            }

            return Response({
                'success': True,
                'data': {
                    'nivel': nivel,
                    'nome': estagio_texto,
                    'cor': cores_map.get(nivel, '#228d46'),
                    'descricao': descricoes_map.get(nivel, 'Normalidade')
                },
                'estagio': estagio_texto,
                'cor': cores_map.get(nivel, '#228d46'),
                'estagio_id': ultimo.id,
                'inicio': ultimo.data_i,
                'data_atualizacao': timezone.now()
            })

        # Se n√£o tem est√°gio, retornar padr√£o
        return Response({
            'success': True,
            'data': {
                'nivel': 1,
                'nome': 'N√≠vel 1',
                'cor': '#228d46',
                'descricao': 'Normalidade'
            },
            'estagio': 'N√≠vel 1',
            'cor': '#228d46',
            'data_atualizacao': timezone.now()
        })

    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=500)


@api_view(['GET'])
def inserir_ocorrencia_mobile(request):
    """
    Endpoint compat√≠vel com o sistema antigo
    Recebe via GET: ?lat=X&lon=Y&descricao=Z&tipo=W
    """
    try:
        ocorrencia = Ocorrencias.objects.create(
            incidente=request.GET.get('descricao', 'Ocorr√™ncia via mobile'),
            lat=request.GET.get('lat'),
            lon=request.GET.get('lon'),
            tipo_forma=request.GET.get('tipo', 'Outros'),
            prio=request.GET.get('prioridade', 'media'),
            bairro=request.GET.get('bairro', ''),
            status='Em andamento',
            data=timezone.now()
        )

        return Response({
            'success': True,
            'message': 'Ocorr√™ncia registrada',
            'id': ocorrencia.id
        })

    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=400)

@never_cache
def calor_api(request):
    """
    API de Alerta de Calor
    Retorna o alerta de calor atual
    """
    try:
        # Buscar √∫ltimo alerta ativo (sem data_f)
        alerta = Calor.objects.filter(data_f__isnull=True).latest('id')
        
        # Se n√£o encontrar, buscar o √∫ltimo registro
        if not alerta:
            alerta = Calor.objects.latest('id')
        
        # Extrair n√∫mero do texto "N√≠vel X"
        nivel_texto = alerta.alive or 'N√≠vel 0'
        match = re.search(r'(\d+)', nivel_texto)
        nivel = int(match.group(1)) if match else 0
        
        # Mapeamento de cores por n√≠vel
        cores_map = {
            0: '#228d46',  # Verde - Normal
            1: '#f5c520',  # Amarelo - Observa√ß√£o
            2: '#ef8c3f',  # Laranja - Aten√ß√£o
            3: '#d0262d',  # Vermelho - Alerta
        }
        
        nomes_map = {
            0: 'Normal',
            1: 'Observa√ß√£o',
            2: 'Aten√ß√£o',
            3: 'Alerta',
        }
        
        return JsonResponse({
            'success': True,
            'nivel': nivel,
            'nome': nomes_map.get(nivel, 'Normal'),
            'cor': cores_map.get(nivel, '#228d46'),
            'texto': nivel_texto,
            'data_inicio': alerta.data_i.isoformat() if alerta.data_i else None,
            'data_atualizacao': datetime.now().isoformat()
        })
        
    except Calor.DoesNotExist:
        return JsonResponse({
            'success': True,
            'nivel': 0,
            'nome': 'Normal',
            'cor': '#228d46',
            'texto': 'N√≠vel 0',
            'data_inicio': None,
            'data_atualizacao': datetime.now().isoformat()
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@api_view(['GET'])
def api_estagio_atual(request):
    """Retorna o est√°gio operacional calculado dinamicamente"""
    try:
        # Calcular inline
        CORES = {
            1: {'cor': '#228d46', 'nome': 'N√≠vel 1', 'descricao': 'Normalidade'},
            2: {'cor': '#f5c520', 'nome': 'N√≠vel 2', 'descricao': 'Aten√ß√£o'},
            3: {'cor': '#ef8c3f', 'nome': 'N√≠vel 3', 'descricao': 'Alerta'},
            4: {'cor': '#d0262d', 'nome': 'N√≠vel 4', 'descricao': 'Alerta M√°ximo'},
            5: {'cor': '#5f2f7e', 'nome': 'N√≠vel 5', 'descricao': 'Crise'}
        }

        # N√≠vel Ocorr√™ncias
        abertas = Ocorrencias.objects.count()
        if abertas >= 50:
            nivel_ocorrencias = 5
        elif abertas >= 30:
            nivel_ocorrencias = 4
        elif abertas >= 15:
            nivel_ocorrencias = 3
        elif abertas >= 5:
            nivel_ocorrencias = 2
        else:
            nivel_ocorrencias = 1

        # N√≠vel Tempo (simplificado)
        nivel_tempo = 1

        # N√≠vel Eventos
        nivel_eventos = 1

        # N√≠vel geral
        nivel_geral = int((nivel_ocorrencias + nivel_tempo + nivel_eventos) / 3)

        resultado = {
            'nivel': nivel_geral,
            'cor': CORES[nivel_geral]['cor'],
            'nome': CORES[nivel_geral]['nome'],
            'descricao': CORES[nivel_geral]['descricao'],
            'detalhes': {
                'tempo': {'nivel': nivel_tempo, **CORES[nivel_tempo]},
                'ocorrencias': {'nivel': nivel_ocorrencias, **CORES[nivel_ocorrencias], 'total': abertas},
                'eventos': {'nivel': nivel_eventos, **CORES[nivel_eventos]}
            }
        }

        return Response({
            'success': True,
            'data': resultado
        })
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=500)

@api_view(['GET'])
def waze_data_view(request):
    """Busca dados do Waze (alertas e congestionamentos)"""
    try:
        import requests
        
        url = "https://www.waze.com/row-partnerhub-api/partners/14420996249/waze-feeds/c5c19146-e0f9-44a7-9815-3862c8a6ed67?format=1"
        
        response = requests.get(url, timeout=10)
        
        if response.status_code != 200:
            return Response({
                'success': False,
                'error': 'Erro ao buscar dados do Waze'
            }, status=500)
        
        data = response.json()
        
        # Processar alertas
        alertas_processados = []
        for alert in data.get('alerts', [])[:100]:  # Limitar a 100 para performance
            tipo_map = {
                'HAZARD': 'Perigo',
                'ACCIDENT': 'Acidente',
                'JAM': 'Congestionamento',
                'WEATHERHAZARD': 'Condi√ß√£o Clim√°tica',
                'ROAD_CLOSED': 'Via Fechada'
            }
            
            subtipo_map = {
                'HAZARD_ON_ROAD_POT_HOLE': 'Buraco',
                'HAZARD_ON_ROAD_OBJECT': 'Objeto na Pista',
                'HAZARD_ON_ROAD': 'Perigo na Pista',
                'HAZARD_ON_SHOULDER': 'Perigo no Acostamento',
                'HAZARD_WEATHER': 'Clima',
                'HAZARD_ON_ROAD_ICE': 'Pista Escorregadia',
                'HAZARD_ON_ROAD_CONSTRUCTION': 'Obra',
                'HAZARD_ON_ROAD_CAR_STOPPED': 'Ve√≠culo Parado',
                'HAZARD_ON_ROAD_TRAFFIC_LIGHT_FAULT': 'Sem√°foro com Defeito'
            }
            
            alertas_processados.append({
                'id': alert.get('uuid'),
                'tipo': tipo_map.get(alert.get('type'), alert.get('type')),
                'subtipo': subtipo_map.get(alert.get('subtype'), alert.get('subtype', '')),
                'lat': alert.get('location', {}).get('y'),
                'lng': alert.get('location', {}).get('x'),
                'rua': alert.get('street', 'Via n√£o identificada'),
                'cidade': alert.get('city', 'Rio de Janeiro'),
                'confianca': alert.get('confidence', 0),
                'confiabilidade': alert.get('reliability', 0),
                'data': alert.get('pubMillis')
            })
        
        # Processar congestionamentos
        jams_processados = []
        for jam in data.get('jams', [])[:50]:  # Limitar a 50
            # Pegar primeiro e √∫ltimo ponto da linha
            line = jam.get('line', [])
            if len(line) > 0:
                inicio = line[0]
                fim = line[-1]
                
                # Calcular ponto central
                centro_lat = (inicio['y'] + fim['y']) / 2
                centro_lng = (inicio['x'] + fim['x']) / 2
                
                nivel_map = {
                    0: 'Livre',
                    1: 'Leve',
                    2: 'Moderado', 
                    3: 'Pesado',
                    4: 'Parado',
                    5: 'Muito Lento'
                }
                
                jams_processados.append({
                    'id': jam.get('uuid'),
                    'rua': jam.get('street', 'Via n√£o identificada'),
                    'cidade': jam.get('city', 'Rio de Janeiro'),
                    'nivel': jam.get('level', 0),
                    'nivel_texto': nivel_map.get(jam.get('level', 0), 'Desconhecido'),
                    'velocidade': round(jam.get('speedKMH', 0), 1),
                    'comprimento': jam.get('length', 0),
                    'atraso': jam.get('delay', 0),
                    'lat': centro_lat,
                    'lng': centro_lng,
                    'linha': line,  # Pontos para desenhar linha no mapa
                    'data': jam.get('pubMillis')
                })
        
        return Response({
            'success': True,
            'alertas': alertas_processados,
            'congestionamentos': jams_processados,
            'total_alertas': len(data.get('alerts', [])),
            'total_jams': len(data.get('jams', [])),
            'atualizacao': data.get('endTime')
        })
        
    except Exception as e:
        import traceback
        return Response({
            'success': False,
            'error': str(e),
            'traceback': traceback.format_exc()
        }, status=500)
        
@csrf_exempt
def api_ocorrencias(request):
    """
    API de ocorr√™ncias - APENAS DE HOJE
    """
    try:
        from django.utils import timezone
        from datetime import datetime
        
        # FILTRAR APENAS HOJE
        hoje = timezone.now().date()
        inicio_dia = timezone.make_aware(datetime.combine(hoje, datetime.min.time()))
        fim_dia = timezone.make_aware(datetime.combine(hoje, datetime.max.time()))
        
        # MOSTRAR TODAS AS ABERTAS
        ocorrencias = Ocorrencias.objects.exclude(
        status='Conclu√≠do'
        ).order_by('-data')
        
        total = ocorrencias.count()
        
        # Cores
        cores_prioridade = {
            'SECUND√ÅRIO': '#10b981',
            'BAIXO': '#10b981',
            'MEDIO': '#f59e0b',
            'ALTO': '#ef4444',
            'CRITICO': '#991b1b',
        }
        
        # √çcones
        icones = {
            'ACIDENTE': 'bi-car-front-fill',
            'ALAGAMENTO': 'bi-water',
            'DESLIZAMENTO': 'bi-exclamation-triangle-fill',
            'QUEDA': 'bi-tree-fill',
            'INC√äNDIO': 'bi-fire',
            'VAZAMENTO': 'bi-droplet-fill',
            'BURACO': 'bi-sign-stop-fill',
        }
        
        data = []
        for occ in ocorrencias:
            # Determinar √≠cone
            icone = 'bi-exclamation-circle-fill'
            if occ.incidente:
                for key, icon in icones.items():
                    if key in occ.incidente.upper():
                        icone = icon
                        break
            
            data.append({
                'id': occ.id,
                'id_c': occ.id_c or '',
                'tipo': occ.incidente or 'Outros',
                'descricao': occ.obs or 'Sem descri√ß√£o',
                'endereco': occ.log or 'Endere√ßo n√£o informado',
                'bairro': occ.bairro or '',
                'lat': float(occ.lat) if occ.lat else None,
                'lng': float(occ.lon) if occ.lon else None,
                'prioridade': occ.prio or 'MEDIO',
                'cor_prioridade': cores_prioridade.get(occ.prio, '#6b7280'),
                'status': occ.status or 'Acionado',
                'icone': icone,
                'data_criacao': occ.data.isoformat() if occ.data else None,
            })
        
        abertas = ocorrencias.exclude(status='Conclu√≠do').count()
        
        return JsonResponse({
            'success': True,
            'data': data,
            'count': total,
            'abertas': abertas,
            'filtro': 'HOJE - ' + hoje.isoformat(),
        })
        
    except Exception as e:
        logger.error(f'Erro: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': str(e),
            'data': []
        }, status=500)
    


# ============================================
# API OCORR√äNCIAS - TEMPO REAL (HEXAGON)
# ============================================

@csrf_exempt
def api_ocorrencias_tempo_real(request):
    """
    API de ocorr√™ncias - BUSCA DIRETO DA API HEXAGON EM TEMPO REAL
    Retorna apenas ocorr√™ncias ABERTAS de HOJE
    """
    import requests
    from datetime import datetime, date
    from django.utils import timezone
    
    HEXAGON_API_BASE_URL = "https://api.corio-oncall.com.br/hxgnEvents/api"
    HEXAGON_API_USERNAME = "APIOpenedEvent"
    HEXAGON_API_PASSWORD = "12345"
    
    # Mapeamento de tipos de eventos
    EVENT_DICT = {
        "POP01": "ACIDENTE SEM VITIMA",
        "POP02": "ACIDENTE COM VITIMA",
        "POP03": "ACIDENTE COM OBITO",
        "POP04": "INCENDIO EM VEICULO",
        "POP05": "BOLSAO DE AGUA EM VIA",
        "POP06": "MANIFESTACAO EM LOCAL PUBLICO",
        "POP07": "INCENDIO EM IMOVEL",
        "POP08": "SINAIS DE TRANSITO COM MAU FUNCIONAMENTO",
        "POP09": "REINTEGRACAO DE POSSE",
        "POP10": "QUEDA DE ARVORE",
        "POP11": "QUEDA DE POSTE",
        "POP12": "ACIDENTE COM QUEDA DE CARGA",
        "POP13": "INCENDIO NO ENTORNO DE VIAS PUBLICAS",
        "POP14": "INCENDIO DENTRO DE TUNEIS",
        "POP15": "VAZAMENTO DE AGUA E ESGOTO",
        "POP16": "FALTA CRITICA DE ENERGIA OU APAGAO",
        "POP17": "IMPLOSAO",
        "POP18": "ESCAPAMENTO DE GAS",
        "POP19": "EVENTO NAO PROGRAMADO",
        "POP20": "ATROPELAMENTO",
        "POP21": "AFUNDAMENTO DE PISTA OU BURACO NA VIA",
        "POP22": "ABALROAMENTO",
        "POP23": "OBRA/MANUTEN√á√ÉO EM LOCAL PUBLICO",
        "POP24": "OPERACAO POLICIAL",
        "POP25": "ACIONAMENTO DE SIRENES",
        "POP26": "ALAGAMENTO",
        "POP27": "ENCHENTE OU INUNDACAO",
        "POP28": "LAMINA DE AGUA",
        "POP29": "ACIDENTE AMBIENTAL",
        "POP30": "INCIDENTE COM BUEIRO",
        "POP31": "QUEDA DE ARVORE SOBRE FIACAO",
        "POP32": "RESIDUOS NA VIA",
        "POP33": "INCENDIO EM VEGETACAO",
        "POP34": "DESLIZAMENTO",
        "POP35": "QUEDA DE ESTRUTURA DE ALVENARIA",
        "POP36": "RESGATE OU REMOCAO DE ANIMAIS TERRESTRES E AEREOS",
        "POP37": "REMOCAO DE ANIMAIS MORTOS NA AREIA",
        "POP38": "RESGATE DE ANIMAL MARINHO PRESO EM REDE OU ENCALHADO",
        "POP39": "ANIMAL EM LOCAL PUBLICO",
        "POP40": "QUEDA DE CARGA VIVA DE GRANDE PORTE",
        "POP41": "QUEDA DE CARGA VIVA DE PEQUENO PORTE",
        "POP42": "PROTOCOLO DE VIA",
        "POP43": "PROTOCOLO DE CICLOVIA",
        "POP44": "ENGUICO NA VIA",
        "POP45": "PROTOCOLO DE CALOR - NC2",
        "POP46": "PROTOCOLO DE CALOR - NC3",
        "POP47": "PROTOCOLO DE CALOR - NC4",
        "POP48": "PROTOCOLO DE CALOR - NC5",
        "POP49": "PROTOCOLO DE PARQUES",
        "POP50": "OCORRENCIA EM PARQUE AEROPORTUARIO",
        "POP51": "INTERRUP√á√ÉO PARCIAL OU TOTAL DE MODAL DE TRANSPORTE",
        "POP52": "FIA√á√ÉO PARTIDA/ARREADA",
        "POP53": "RESSACA/MAR√â ALTA"
    }
    
    PRIORIDADE_DICT = {
        1: "BAIXA",
        2: "M√âDIA",
        3: "ALTA",
        4: "MUITO ALTA"
    }
    
    CORES_PRIORIDADE = {
        'BAIXA': '#10b981',
        'M√âDIA': '#f59e0b',
        'ALTA': '#ef4444',
        'MUITO ALTA': '#991b1b',
    }
    
    ICONES = {
        'ACIDENTE': 'bi-car-front-fill',
        'ALAGAMENTO': 'bi-water',
        'DESLIZAMENTO': 'bi-exclamation-triangle-fill',
        'QUEDA': 'bi-tree-fill',
        'INCENDIO': 'bi-fire',
        'INC√äNDIO': 'bi-fire',
        'VAZAMENTO': 'bi-droplet-fill',
        'BURACO': 'bi-sign-stop-fill',
        'AFUNDAMENTO': 'bi-sign-stop-fill',
    }
    
    try:
        # 1. AUTENTICAR NA API HEXAGON
        auth_url = f"{HEXAGON_API_BASE_URL}/Events/Login"
        auth_payload = {"UserName": HEXAGON_API_USERNAME, "Password": HEXAGON_API_PASSWORD}
        
        auth_response = requests.post(auth_url, json=auth_payload, timeout=10)
        auth_response.raise_for_status()
        
        token = auth_response.json().get("AccessToken")
        if not token:
            raise Exception("Falha na autentica√ß√£o - Token n√£o recebido")
        
        # 2. BUSCAR OCORR√äNCIAS ABERTAS
        events_url = f"{HEXAGON_API_BASE_URL}/Events/OpenedEvents"
        events_payload = {"token": token}
        
        events_response = requests.post(events_url, json=events_payload, timeout=15)
        events_response.raise_for_status()
        
        raw_events = events_response.json()
        
        # 3. FILTRAR APENAS AS DE HOJE
        hoje = date.today()
        
        ocorrencias = []
        for item in raw_events:
            # Pegar data do evento
            created_date = item.get("CreatedDate", "")
            if not created_date:
                continue
            
            try:
                # Parse da data (formato: 2025-11-24T10:30:00)
                dt = datetime.fromisoformat(created_date.replace('Z', '+00:00'))
                event_date = dt.date()
                
                # Filtrar apenas de HOJE
                if event_date != hoje:
                    continue
                    
            except Exception:
                continue
            
            # Pegar tipo do evento
            tipo_code = item.get("AgencyEventTypeCode", "")
            tipo = EVENT_DICT.get(tipo_code, tipo_code or "OUTROS")
            
            # Pegar prioridade
            prio_num = item.get("Priority", 1)
            prioridade = PRIORIDADE_DICT.get(prio_num, "M√âDIA")
            
            # Determinar √≠cone
            icone = 'bi-exclamation-circle-fill'
            for key, icon in ICONES.items():
                if key in tipo.upper():
                    icone = icon
                    break
            
            ocorrencias.append({
                'id': item.get("EventId"),
                'id_c': item.get("EventId"),
                'tipo': tipo,
                'descricao': item.get("Description") or tipo,
                'endereco': item.get("Location") or 'Endere√ßo n√£o informado',
                'bairro': item.get("District") or '',
                'lat': item.get("Latitude"),
                'lng': item.get("Longitude"),
                'prioridade': prioridade,
                'cor_prioridade': CORES_PRIORIDADE.get(prioridade, '#6b7280'),
                'status': 'Em andamento',
                'icone': icone,
                'data_criacao': created_date,
            })
        
        # Ordenar por data (mais recentes primeiro)
        ocorrencias.sort(key=lambda x: x['data_criacao'] or '', reverse=True)
        
        total = len(ocorrencias)
        
        return JsonResponse({
            'success': True,
            'data': ocorrencias,
            'count': total,
            'abertas': total,
            'filtro': f'HOJE (TEMPO REAL) - {hoje.isoformat()}',
            'fonte': 'API Hexagon',
            'timestamp': timezone.now().isoformat()
        })
        
    except requests.exceptions.Timeout:
        logger.error('Timeout ao conectar com API Hexagon')
        return JsonResponse({
            'success': False,
            'error': 'Timeout ao conectar com API Hexagon',
            'data': []
        }, status=504)
        
    except Exception as e:
        logger.error(f'Erro ao buscar ocorr√™ncias tempo real: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': str(e),
            'data': []
        }, status=500)
    
# ===== MATRIZ DECIS√ìRIA =====
def matriz_decisoria(request):
    return render(request, 'mapa_novo/matriz_decisoria.html')

def api_matriz_decisoria(request):
    # SUBSTITUA PELA SUA API REAL!
    # response = requests.get('SUA_URL_API')
    # return JsonResponse(response.json())
    
    # Dados de exemplo por enquanto
    dados = {
        "EstagioOperacional": {"EstagioOperacionalSugerido": 1, "ProgressoEstagioOperacionalSugerido": 30, "ValorEstagioOperacionalSugerido": 0.36},
        "NivelIndicado": {"NivelG1": 1, "NivelG2": 0, "NivelG3": 0, "NivelG4": 0, "ProximidadeNivelSeguinte": 27.5},
        "NivelG1": {"TabelaNivelG1": {"ProgressoNivelG1": 100, "NivelCalor": 1, "Chuva": {"Total": "116", "ChuvaFraca": "4", "ChuvaModerada": "0", "ChuvaForte": "0", "ChuvaMuitoForte": "0"}, "Sirene": {"Total": "162", "Alarmada": "0"}, "Vento": {"VentoForte": "0", "VentoMuitoForte": "0", "VentoMediaH01": "8.6"}}},
        "NivelG2": {"ProgressoNivelG2": 73, "Critica": 0, "MuitoAlta": 0, "Alta": 0, "Media": 1, "Baixa": 11},
        "NivelG3": {"ProgressoNivelG3": 0, "StatusModal": {"Metr√¥": "Normal", "BRT": "Normal", "Trem": "Normal", "√înibus": "Normal", "Barcas": "Normal", "VLT": "Normal", "GIG": "Normal", "SDU": "Normal"}, "Transito": {"EAC": 49}, "Modal": {"ModalEmAtencao": 0, "ModalInterrompido": 0}},
        "NivelG4": {"ProgressoNivelG4": 0, "MuitoAlta": 0, "Alta": 0, "Media": 0, "Baixa": 0, "Evento": None}
    }
    return JsonResponse(dados)

# ===== MATRIZ DECIS√ìRIA =====
def matriz_decisoria(request):
    """View principal da Matriz Decis√≥ria"""
    return render(request, 'mapa_novo/matriz_decisoria.html')


def api_matriz_decisoria(request):
    """API para buscar dados da matriz decis√≥ria"""
    dados = {
        "EstagioOperacional": {
            "EstagioOperacionalSugerido": 1,
            "ValorEstagioOperacionalSugerido": 0.36,
            "ProgressoEstagioOperacionalSugerido": 30
        },
        "NivelIndicado": {
            "NivelG1": 1,
            "NivelG2": 0,
            "NivelG3": 0,
            "NivelG4": 0,
            "ProximidadeNivelSeguinte": 27.5
        },
        "NivelG1": {
            "TabelaNivelG1": {
                "ProgressoNivelG1": 100,
                "NivelCalor": 1,
                "Chuva": {"Total": "116", "ChuvaFraca": "4", "ChuvaModerada": "0", "ChuvaForte": "0", "ChuvaMuitoForte": "0"},
                "Sirene": {"Total": "162", "Alarmada": "0"},
                "Vento": {"VentoForte": "0", "VentoMuitoForte": "0", "VentoMediaH01": "8.6"}
            }
        },
        "NivelG2": {"ProgressoNivelG2": 73, "Critica": 0, "MuitoAlta": 0, "Alta": 0, "Media": 1, "Baixa": 11},
        "NivelG3": {
            "ProgressoNivelG3": 0,
            "StatusModal": {"Metr√¥": "Normal", "BRT": "Normal", "Trem": "Normal", "√înibus": "Normal", "Barcas": "Normal", "VLT": "Normal", "GIG": "Normal", "SDU": "Normal"},
            "Transito": {"EAC": 49},
            "Modal": {"ModalEmAtencao": 0, "ModalInterrompido": 0}
        },
        "NivelG4": {"ProgressoNivelG4": 0, "MuitoAlta": 0, "Alta": 0, "Media": 0, "Baixa": 0, "Evento": None}
    }
    return JsonResponse(dados)

@api_view(['GET'])
def api_cameras(request):
    """API de c√¢meras de monitoramento"""
    try:
        from aplicativo.models import Cameras
        
        # Par√¢metros
        bairro = request.GET.get('bairro', None)
        status = request.GET.get('status', None)
        search = request.GET.get('search', None)
        
        # Query
        cameras = Cameras.objects.all()
        
        # Filtros
        if bairro:
            cameras = cameras.filter(bairro__icontains=bairro)
        
        if status:
            cameras = cameras.filter(status__iexact=status)
        
        if search:
            cameras = cameras.filter(nome__icontains=search)
        
        # Serializar
        data = []
        bairros_set = set()
        
        for cam in cameras.order_by('id_c'):
            try:
                lat = float(cam.lat) if cam.lat else None
                lon = float(cam.lon) if cam.lon else None
                
                if lat and lon and lat != 0 and lon != 0:
                    data.append({
                        'id': cam.id,
                        'id_c': cam.id_c,
                        'nome': cam.nome or f'C√¢mera {cam.id_c}',
                        'bairro': cam.bairro or 'Sem bairro',
                        'lat': lat,
                        'lng': lon,
                        'status': cam.status,
                        'url_stream': f'https://dev.tixxi.rio/outvideo2/?CODE={cam.id_c}&KEY=B0914'
                    })
                    bairros_set.add(cam.bairro or 'Sem bairro')
            except:
                continue
        
        return Response({
            'success': True,
            'data': data,
            'count': len(data),
            'bairros': sorted(list(bairros_set))
        })
        
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=500)

@api_view(['GET'])
def api_sirenes(request):
    """API de sirenes"""
    try:
        from aplicativo.models import Sirene
        
        sirenes = Sirene.objects.all()
        data = []
        
        for s in sirenes:
            try:
                data.append({
                    'id': s.id,
                    'nome': s.nome or f'Sirene {s.id}',
                    'endereco': s.endereco if hasattr(s, 'endereco') else '',
                    'bairro': s.bairro if hasattr(s, 'bairro') else '',
                    'lat': float(s.lat) if s.lat else None,
                    'lng': float(s.lon) if s.lon else None,
                    'status': s.status if hasattr(s, 'status') else 'inativa',
                    'prioridade': s.prioridade if hasattr(s, 'prioridade') else 'm√©dia'
                })
            except:
                continue
        
        return Response({'success': True, 'data': data, 'count': len(data)})
    except Exception as e:
        return Response({'success': False, 'error': str(e)}, status=500)


from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view(['GET'])
def api_pluviometros(request):
    """API de pluvi√¥metros - VERS√ÉO TESTE SIMPLES"""
    
    # ‚úÖ RETORNAR DADOS FAKE PRIMEIRO PARA TESTAR
    return Response({
        'success': True,
        'data': [
            {
                'id': 1,
                'nome': 'Teste Tijuca',
                'lat': -22.9249,
                'lng': -43.2311,
                'chuva_1h': 5.5,
                'chuva_4h': 10.0,
                'chuva_24h': 20.0,
                'chuva_96h': 40.0,
                'data': '2025-11-13T12:00:00',
                'status': 'ativa'
            }
        ],
        'count': 1,
        'chovendo': 1,
        'filtro': 'TESTE',
        'mensagem': 'üî• FUN√á√ÉO FUNCIONANDO!'
    })


@api_view(['GET'])
def api_ventos(request):
    """API de esta√ß√µes meteorol√≥gicas"""
    try:
        from aplicativo.models import EstacaoMet
        
        estacoes = EstacaoMet.objects.all()
        data = []
        
        for e in estacoes:
            try:
                data.append({
                    'id': e.id,
                    'nome': e.nome if hasattr(e, 'nome') else f'Esta√ß√£o {e.id}',
                    'lat': float(e.lat) if hasattr(e, 'lat') and e.lat else None,
                    'lng': float(e.lon) if hasattr(e, 'lon') and e.lon else None,
                    'velocidade': float(e.velocidade) if hasattr(e, 'velocidade') and e.velocidade else 0,
                    'direcao': e.direcao if hasattr(e, 'direcao') else 'N/A',
                    'temperatura': float(e.temperatura) if hasattr(e, 'temperatura') and e.temperatura else 0,
                    'umidade': float(e.umidade) if hasattr(e, 'umidade') and e.umidade else 0,
                    'data': e.data.strftime('%d/%m/%Y %H:%M') if hasattr(e, 'data') and e.data else 'N/A'
                })
            except:
                continue
        
        return Response({'success': True, 'data': data, 'count': len(data)})
    except Exception as e:
        return Response({'success': False, 'error': str(e)}, status=500)


# ===== VIEWS DE METEOROLOGIA =====

@login_required(login_url='login')
@never_cache
def meteorologia_dashboard_view(request):
    """Dashboard de Meteorologia"""
    return render(request, 'mapa_novo/meteorologia_dashboard.html')


@api_view(['GET'])
def api_previsao_tempo(request):
    """API de previs√£o do tempo (dados simulados por enquanto)"""
    try:
        # Dados de previs√£o para pr√≥ximos 5 dias
        previsao = [
            {
                'dia': 'Segunda',
                'data': '28/10',
                'temp_min': 22,
                'temp_max': 28,
                'condicao': 'Parcialmente nublado',
                'icone': 'cloud-sun',
                'chuva_prob': 30,
                'umidade': 65
            },
            {
                'dia': 'Ter√ßa',
                'data': '29/10',
                'temp_min': 21,
                'temp_max': 27,
                'condicao': 'Chuva leve',
                'icone': 'cloud-drizzle',
                'chuva_prob': 70,
                'umidade': 75
            },
            {
                'dia': 'Quarta',
                'data': '30/10',
                'temp_min': 20,
                'temp_max': 26,
                'condicao': 'Nublado',
                'icone': 'cloud',
                'chuva_prob': 50,
                'umidade': 70
            },
            {
                'dia': 'Quinta',
                'data': '31/10',
                'temp_min': 23,
                'temp_max': 29,
                'condicao': 'Ensolarado',
                'icone': 'sun',
                'chuva_prob': 10,
                'umidade': 55
            },
            {
                'dia': 'Sexta',
                'data': '01/11',
                'temp_min': 24,
                'temp_max': 30,
                'condicao': 'Ensolarado',
                'icone': 'sun',
                'chuva_prob': 5,
                'umidade': 50
            }
        ]
        
        return Response({
            'success': True,
            'data': previsao
        })
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=500)


@api_view(['GET'])
def api_historico_chuva(request):
    """API de hist√≥rico de chuva - √∫ltimas 24 horas"""
    try:
        from aplicativo.models import DadosPlv
        from datetime import datetime, timedelta
        
        # Pegar dados das √∫ltimas 24 horas
        data_limite = datetime.now() - timedelta(hours=24)
        
        dados = DadosPlv.objects.filter(
            data__gte=data_limite
        ).order_by('data')[:100]
        
        historico = []
        for d in dados:
            historico.append({
                'hora': d.data.strftime('%H:%M') if d.data else 'N/A',
                'chuva_1h': float(d.chuva_1 or 0),
                'estacao': d.estacao.nome if hasattr(d, 'estacao') else 'N/A'
            })
        
        return Response({
            'success': True,
            'data': historico
        })
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e),
            'data': []
        }, status=500)


@api_view(['GET'])
def api_alertas_meteorologicos(request):
    """API de alertas meteorol√≥gicos ativos"""
    try:
        from aplicativo.models import EstacaoPlv, DadosPlv
        
        alertas = []
        
        # Verificar esta√ß√µes com chuva forte
        estacoes = EstacaoPlv.objects.all()
        
        for estacao in estacoes:
            ultimo = DadosPlv.objects.filter(estacao=estacao).order_by('-data').first()
            
            if ultimo:
                chuva_1h = float(ultimo.chuva_1 or 0)
                
                if chuva_1h >= 25:
                    alertas.append({
                        'tipo': 'Chuva Forte',
                        'nivel': 'alto',
                        'estacao': estacao.nome,
                        'valor': chuva_1h,
                        'mensagem': f'Chuva forte de {chuva_1h}mm em {estacao.nome}',
                        'icone': 'cloud-rain-heavy'
                    })
                elif chuva_1h >= 10:
                    alertas.append({
                        'tipo': 'Chuva Moderada',
                        'nivel': 'medio',
                        'estacao': estacao.nome,
                        'valor': chuva_1h,
                        'mensagem': f'Chuva moderada de {chuva_1h}mm em {estacao.nome}',
                        'icone': 'cloud-rain'
                    })
        
        return Response({
            'success': True,
            'data': alertas,
            'count': len(alertas)
        })
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e),
            'data': []
        }, status=500)

# ===== VIEWS DE MOBILIDADE URBANA =====

@login_required(login_url='login')
@never_cache
def mobilidade_dashboard_view(request):
    return render(request, 'mapa_novo/mobilidade_dashboard.html')  # ‚Üê NOME REAL DO ARQUIVO


@api_view(['GET'])
def api_brt_linhas(request):
    """API de linhas de BRT"""
    try:
        # Dados das principais linhas de BRT do Rio
        linhas = [
            {
                'id': 1,
                'nome': 'TransOeste',
                'cor': '#0066cc',
                'status': 'Opera√ß√£o Normal',
                'status_code': 'normal',
                'estacoes': 59,
                'extensao': '56 km',
                'tempo_medio': '85 min',
                'intervalo': '5-10 min'
            },
            {
                'id': 2,
                'nome': 'TransCarioca',
                'cor': '#ff6600',
                'status': 'Opera√ß√£o Normal',
                'status_code': 'normal',
                'estacoes': 45,
                'extensao': '39 km',
                'tempo_medio': '60 min',
                'intervalo': '4-8 min'
            },
            {
                'id': 3,
                'nome': 'TransOl√≠mpica',
                'cor': '#00cc66',
                'status': 'Opera√ß√£o Normal',
                'status_code': 'normal',
                'estacoes': 18,
                'extensao': '26 km',
                'tempo_medio': '35 min',
                'intervalo': '6-12 min'
            },
            {
                'id': 4,
                'nome': 'TransBrasil',
                'cor': '#cc0000',
                'status': 'Em Obras',
                'status_code': 'obras',
                'estacoes': 28,
                'extensao': '32 km',
                'tempo_medio': 'N/A',
                'intervalo': 'N/A'
            }
        ]
        
        return Response({
            'success': True,
            'data': linhas,
            'count': len(linhas)
        })
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=500)


@api_view(['GET'])
def api_metro_linhas(request):
    """API de linhas de Metr√¥"""
    try:
        linhas = [
            {
                'id': 1,
                'numero': '1',
                'nome': 'Linha 1 (Laranja)',
                'cor': '#ff6600',
                'status': 'Opera√ß√£o Normal',
                'status_code': 'normal',
                'estacoes': 19,
                'extensao': '19,8 km',
                'intervalo': '3-5 min',
                'origem': 'Uruguai',
                'destino': 'General Os√≥rio'
            },
            {
                'id': 2,
                'numero': '2',
                'nome': 'Linha 2 (Verde)',
                'cor': '#00aa00',
                'status': 'Opera√ß√£o Normal',
                'status_code': 'normal',
                'estacoes': 18,
                'extensao': '22,8 km',
                'intervalo': '4-6 min',
                'origem': 'Pavuna',
                'destino': 'Botafogo'
            },
            {
                'id': 3,
                'numero': '4',
                'nome': 'Linha 4 (Amarela)',
                'cor': '#ffcc00',
                'status': 'Opera√ß√£o Normal',
                'status_code': 'normal',
                'estacoes': 6,
                'extensao': '16 km',
                'intervalo': '5-8 min',
                'origem': 'Ipanema',
                'destino': 'Jardim Oce√¢nico'
            }
        ]
        
        return Response({
            'success': True,
            'data': linhas,
            'count': len(linhas)
        })
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=500)


@api_view(['GET'])
def api_bike_rio(request):
    """API de esta√ß√µes Bike Rio"""
    try:
        # Dados simulados de esta√ß√µes Bike Rio
        estacoes = [
            {
                'id': 1,
                'nome': 'Copacabana - Posto 5',
                'bairro': 'Copacabana',
                'bikes_disponiveis': 12,
                'vagas_disponiveis': 8,
                'total_vagas': 20,
                'status': 'Operando',
                'lat': -22.9876,
                'lng': -43.1902
            },
            {
                'id': 2,
                'nome': 'Ipanema - Posto 9',
                'bairro': 'Ipanema',
                'bikes_disponiveis': 5,
                'vagas_disponiveis': 15,
                'total_vagas': 20,
                'status': 'Operando',
                'lat': -22.9833,
                'lng': -43.2043
            },
            {
                'id': 3,
                'nome': 'Leblon - Posto 12',
                'bairro': 'Leblon',
                'bikes_disponiveis': 0,
                'vagas_disponiveis': 18,
                'total_vagas': 18,
                'status': 'Sem Bikes',
                'lat': -22.9844,
                'lng': -43.2200
            },
            {
                'id': 4,
                'nome': 'Botafogo - Metr√¥',
                'bairro': 'Botafogo',
                'bikes_disponiveis': 18,
                'vagas_disponiveis': 2,
                'total_vagas': 20,
                'status': 'Operando',
                'lat': -22.9519,
                'lng': -43.1822
            },
            {
                'id': 5,
                'nome': 'Centro - Pra√ßa XV',
                'bairro': 'Centro',
                'bikes_disponiveis': 7,
                'vagas_disponiveis': 13,
                'total_vagas': 20,
                'status': 'Operando',
                'lat': -22.9035,
                'lng': -43.1737
            }
        ]
        
        return Response({
            'success': True,
            'data': estacoes,
            'count': len(estacoes),
            'total_bikes': sum(e['bikes_disponiveis'] for e in estacoes),
            'total_vagas': sum(e['total_vagas'] for e in estacoes)
        })
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=500)


@api_view(['GET'])
def api_transito_status(request):
    """API de status geral do tr√¢nsito"""
    try:
        # Status simulado baseado em hor√°rio
        from datetime import datetime
        
        hora_atual = datetime.now().hour
        
        # Definir status baseado no hor√°rio
        if (7 <= hora_atual <= 9) or (17 <= hora_atual <= 19):
            nivel = 3  # Intenso
            descricao = 'Tr√¢nsito Intenso'
            cor = '#ef4444'
        elif (10 <= hora_atual <= 16) or (20 <= hora_atual <= 22):
            nivel = 2  # Moderado
            descricao = 'Tr√¢nsito Moderado'
            cor = '#f59e0b'
        else:
            nivel = 1  # Leve
            descricao = 'Tr√¢nsito Leve'
            cor = '#10b981'
        
        return Response({
            'success': True,
            'data': {
                'nivel': nivel,
                'descricao': descricao,
                'cor': cor,
                'hora': hora_atual,
                'lentidao_km': nivel * 15,  # km de lentid√£o
                'velocidade_media': 45 - (nivel * 10)  # km/h
            }
        })
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=500)
        
        
def waze_alerts_api(request):
    """
    API compat√≠vel com o frontend - redireciona para waze_data_view
    """
    try:
        import requests
        
        # Usar a URL oficial do parceiro Waze do Rio
        url = "https://www.waze.com/row-partnerhub-api/partners/14420996249/waze-feeds/c5c19146-e0f9-44a7-9815-3862c8a6ed67?format=1"
        
        print('üöó Buscando dados do Waze...')
        print(f'üì° URL: {url}')
        
        response = requests.get(url, timeout=15)
        
        print(f'‚úÖ Status: {response.status_code}')
        
        if response.status_code != 200:
            return JsonResponse({
                'success': False,
                'error': f'Waze API retornou status {response.status_code}',
                'data': []
            })
        
        data = response.json()
        
        print(f'üì¶ Dados recebidos: {len(data.get("alerts", []))} alertas, {len(data.get("jams", []))} congestionamentos')
        
        # Processar alertas
        alerts = []
        
        for alert in data.get('alerts', []):
            alerts.append({
                'id': alert.get('uuid', ''),
                'type': alert.get('type', 'UNKNOWN'),
                'subtype': alert.get('subtype', ''),
                'location': {
                    'x': alert.get('location', {}).get('x'),
                    'y': alert.get('location', {}).get('y')
                },
                'street': alert.get('street', ''),
                'city': alert.get('city', ''),
                'reportDescription': alert.get('reportDescription', ''),
                'reliability': alert.get('reliability', 0),
                'confidence': alert.get('confidence', 0),
                'nThumbsUp': alert.get('nThumbsUp', 0),
                'pubMillis': alert.get('pubMillis', 0)
            })
        
        # Processar congestionamentos
        for jam in data.get('jams', []):
            line = jam.get('line', [])
            if line and len(line) > 0:
                mid_point = line[len(line) // 2]
                alerts.append({
                    'id': jam.get('uuid', ''),
                    'type': 'JAM',
                    'subtype': f"N√≠vel {jam.get('level', 0)}",
                    'location': {
                        'x': mid_point.get('x'),
                        'y': mid_point.get('y')
                    },
                    'street': jam.get('street', ''),
                    'city': jam.get('city', ''),
                    'reportDescription': f"Congestionamento - Velocidade: {jam.get('speedKMH', 0)} km/h",
                    'reliability': jam.get('reliability', 0),
                    'confidence': 10,
                    'nThumbsUp': 0,
                    'pubMillis': jam.get('pubMillis', 0)
                })
        
        print(f'‚úÖ Total de alertas processados: {len(alerts)}')
        
        return JsonResponse({
            'success': True,
            'data': alerts,
            'count': len(alerts),
            'timestamp': datetime.now().isoformat()
        })
        
    except requests.exceptions.Timeout:
        print('‚ùå Timeout!')
        return JsonResponse({
            'success': False,
            'error': 'Timeout ao conectar com Waze',
            'data': []
        })
    except Exception as e:
        print(f'‚ùå Erro: {str(e)}')
        import traceback
        traceback.print_exc()
        return JsonResponse({
            'success': False,
            'error': str(e),
            'data': []
        })


@csrf_exempt
def chuva_api(request):
    """API de dados de chuva/pluvi√¥metros"""
    try:
        # TODO: Substituir por dados reais do banco
        # Por enquanto, dados de exemplo
        
        pluviometros = [
            {
                'id': 1,
                'nome': 'Alto da Boa Vista',
                'lat': -22.9667,
                'lng': -43.2833,
                'chuva_15min': 12.5,
                'chuva_1h': 25.3,
                'chuva_24h': 45.8
            },
            {
                'id': 2,
                'nome': 'Tijuca',
                'lat': -22.9333,
                'lng': -43.2333,
                'chuva_15min': 8.2,
                'chuva_1h': 18.7,
                'chuva_24h': 32.4
            },
            {
                'id': 3,
                'nome': 'Copacabana',
                'lat': -22.9711,
                'lng': -43.1822,
                'chuva_15min': 2.1,
                'chuva_1h': 5.3,
                'chuva_24h': 12.7
            },
            {
                'id': 4,
                'nome': 'Barra da Tijuca',
                'lat': -23.0050,
                'lng': -43.3650,
                'chuva_15min': 0.5,
                'chuva_1h': 1.2,
                'chuva_24h': 3.8
            },
            {
                'id': 5,
                'nome': 'Jacarepagu√°',
                'lat': -22.9211,
                'lng': -43.3628,
                'chuva_15min': 15.8,
                'chuva_1h': 32.4,
                'chuva_24h': 56.9
            },
            {
                'id': 6,
                'nome': 'Centro',
                'lat': -22.9068,
                'lng': -43.1729,
                'chuva_15min': 6.3,
                'chuva_1h': 14.5,
                'chuva_24h': 28.2
            },
        ]
        
        # Estat√≠sticas gerais
        stats = {
            'temperatura_media': 25.3,
            'umidade_media': 68,
            'chuva_24h': sum(p['chuva_24h'] for p in pluviometros) / len(pluviometros),
            'vento_velocidade': 15
        }
        
        return JsonResponse({
            'success': True,
            'data': pluviometros,
            'stats': stats,
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@csrf_exempt
def alertas_api(request):
    """API de alertas meteorol√≥gicos"""
    try:
        # TODO: Substituir por dados reais do banco
        # Por enquanto, dados de exemplo
        
        alertas = [
            {
                'id': 1,
                'tipo': 'chuva_forte',
                'severidade': 'alta',
                'titulo': 'Chuva Forte',
                'mensagem': 'Chuva forte prevista para as pr√≥ximas horas',
                'regiao': 'Zona Norte',
                'lat': -22.9333,
                'lng': -43.2333
            },
            {
                'id': 2,
                'tipo': 'alagamento',
                'severidade': 'media',
                'titulo': 'Risco de Alagamento',
                'mensagem': 'Pontos de alagamento reportados',
                'regiao': 'Zona Sul',
                'lat': -22.9711,
                'lng': -43.1822
            }
        ]
        
        return JsonResponse({
            'success': True,
            'alertas': alertas,
            'total': len(alertas),
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e),
            'alertas': []
        }, status=500)


@csrf_exempt
def estagio_api(request):
    """API de est√°gio operacional"""
    try:
        estagios = ['Normalidade', 'Aten√ß√£o', 'Alerta', 'Crise', 'Mobiliza√ß√£o']
        
        return JsonResponse({
            'success': True,
            'estagio': 'Aten√ß√£o',
            'nivel': 2,
            'descricao': 'Chuva moderada em algumas regi√µes',
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)
        

        
        
@csrf_exempt
def chuva_api(request):
    """API de dados de chuva/pluvi√¥metros"""
    import random
    
    # 30 pluvi√¥metros cobrindo toda a cidade do Rio
    pluviometros = [
        # ZONA NORTE
        {'id': 1, 'nome': 'Tijuca', 'lat': -22.9333, 'lng': -43.2333, 
         'chuva_15min': random.uniform(0, 15), 'chuva_1h': random.uniform(5, 30), 'chuva_24h': random.uniform(10, 50)},
        {'id': 2, 'nome': 'Maracan√£', 'lat': -22.9122, 'lng': -43.2302, 
         'chuva_15min': random.uniform(0, 15), 'chuva_1h': random.uniform(5, 30), 'chuva_24h': random.uniform(10, 50)},
        {'id': 3, 'nome': 'S√£o Crist√≥v√£o', 'lat': -22.8994, 'lng': -43.2228, 
         'chuva_15min': random.uniform(0, 15), 'chuva_1h': random.uniform(5, 30), 'chuva_24h': random.uniform(10, 50)},
        {'id': 4, 'nome': 'M√©ier', 'lat': -22.9025, 'lng': -43.2789, 
         'chuva_15min': random.uniform(0, 15), 'chuva_1h': random.uniform(5, 30), 'chuva_24h': random.uniform(10, 50)},
        {'id': 5, 'nome': 'Vila Isabel', 'lat': -22.9164, 'lng': -43.2456, 
         'chuva_15min': random.uniform(0, 15), 'chuva_1h': random.uniform(5, 30), 'chuva_24h': random.uniform(10, 50)},
        
        # ZONA SUL
        {'id': 6, 'nome': 'Copacabana', 'lat': -22.9711, 'lng': -43.1822, 
         'chuva_15min': random.uniform(0, 10), 'chuva_1h': random.uniform(2, 20), 'chuva_24h': random.uniform(5, 35)},
        {'id': 7, 'nome': 'Ipanema', 'lat': -22.9838, 'lng': -43.2096, 
         'chuva_15min': random.uniform(0, 10), 'chuva_1h': random.uniform(2, 20), 'chuva_24h': random.uniform(5, 35)},
        {'id': 8, 'nome': 'Leblon', 'lat': -22.9844, 'lng': -43.2175, 
         'chuva_15min': random.uniform(0, 10), 'chuva_1h': random.uniform(2, 20), 'chuva_24h': random.uniform(5, 35)},
        {'id': 9, 'nome': 'Botafogo', 'lat': -22.9519, 'lng': -43.1828, 
         'chuva_15min': random.uniform(0, 10), 'chuva_1h': random.uniform(2, 20), 'chuva_24h': random.uniform(5, 35)},
        {'id': 10, 'nome': 'Lagoa', 'lat': -22.9711, 'lng': -43.2053, 
         'chuva_15min': random.uniform(0, 10), 'chuva_1h': random.uniform(2, 20), 'chuva_24h': random.uniform(5, 35)},
        {'id': 11, 'nome': 'G√°vea', 'lat': -22.9797, 'lng': -43.2344, 
         'chuva_15min': random.uniform(0, 10), 'chuva_1h': random.uniform(2, 20), 'chuva_24h': random.uniform(5, 35)},
        
        # CENTRO
        {'id': 12, 'nome': 'Centro', 'lat': -22.9068, 'lng': -43.1729, 
         'chuva_15min': random.uniform(0, 12), 'chuva_1h': random.uniform(3, 25), 'chuva_24h': random.uniform(8, 40)},
        {'id': 13, 'nome': 'Pra√ßa XV', 'lat': -22.9033, 'lng': -43.1752, 
         'chuva_15min': random.uniform(0, 12), 'chuva_1h': random.uniform(3, 25), 'chuva_24h': random.uniform(8, 40)},
        {'id': 14, 'nome': 'Lapa', 'lat': -22.9133, 'lng': -43.1786, 
         'chuva_15min': random.uniform(0, 12), 'chuva_1h': random.uniform(3, 25), 'chuva_24h': random.uniform(8, 40)},
        
        # ZONA OESTE
        {'id': 15, 'nome': 'Barra da Tijuca', 'lat': -23.0050, 'lng': -43.3650, 
         'chuva_15min': random.uniform(0, 8), 'chuva_1h': random.uniform(1, 15), 'chuva_24h': random.uniform(3, 30)},
        {'id': 16, 'nome': 'Recreio', 'lat': -23.0197, 'lng': -43.4597, 
         'chuva_15min': random.uniform(0, 8), 'chuva_1h': random.uniform(1, 15), 'chuva_24h': random.uniform(3, 30)},
        {'id': 17, 'nome': 'Jacarepagu√°', 'lat': -22.9211, 'lng': -43.3628, 
         'chuva_15min': random.uniform(0, 12), 'chuva_1h': random.uniform(5, 28), 'chuva_24h': random.uniform(10, 55)},
        {'id': 18, 'nome': 'Cidade de Deus', 'lat': -22.9456, 'lng': -43.3592, 
         'chuva_15min': random.uniform(0, 12), 'chuva_1h': random.uniform(5, 28), 'chuva_24h': random.uniform(10, 55)},
        {'id': 19, 'nome': 'Campo Grande', 'lat': -22.9009, 'lng': -43.5615, 
         'chuva_15min': random.uniform(0, 10), 'chuva_1h': random.uniform(3, 22), 'chuva_24h': random.uniform(8, 45)},
        {'id': 20, 'nome': 'Bangu', 'lat': -22.8719, 'lng': -43.4664, 
         'chuva_15min': random.uniform(0, 10), 'chuva_1h': random.uniform(3, 22), 'chuva_24h': random.uniform(8, 45)},
        
        # REGI√ïES MONTANHOSAS (mais chuva)
        {'id': 21, 'nome': 'Alto da Boa Vista', 'lat': -22.9667, 'lng': -43.2833, 
         'chuva_15min': random.uniform(5, 25), 'chuva_1h': random.uniform(15, 45), 'chuva_24h': random.uniform(30, 80)},
        {'id': 22, 'nome': 'Floresta da Tijuca', 'lat': -22.9442, 'lng': -43.2633, 
         'chuva_15min': random.uniform(5, 25), 'chuva_1h': random.uniform(15, 45), 'chuva_24h': random.uniform(30, 80)},
        {'id': 23, 'nome': 'Vista Chinesa', 'lat': -22.9583, 'lng': -43.2361, 
         'chuva_15min': random.uniform(5, 25), 'chuva_1h': random.uniform(15, 45), 'chuva_24h': random.uniform(30, 80)},
        {'id': 24, 'nome': 'Corcovado', 'lat': -22.9519, 'lng': -43.2106, 
         'chuva_15min': random.uniform(5, 25), 'chuva_1h': random.uniform(15, 45), 'chuva_24h': random.uniform(30, 80)},
        
        # ILHA DO GOVERNADOR
        {'id': 25, 'nome': 'Ilha do Governador', 'lat': -22.8147, 'lng': -43.2108, 
         'chuva_15min': random.uniform(0, 10), 'chuva_1h': random.uniform(2, 18), 'chuva_24h': random.uniform(5, 35)},
        {'id': 26, 'nome': 'Gale√£o', 'lat': -22.8094, 'lng': -43.2436, 
         'chuva_15min': random.uniform(0, 10), 'chuva_1h': random.uniform(2, 18), 'chuva_24h': random.uniform(5, 35)},
        
        # SUB√öRBIOS
        {'id': 27, 'nome': 'Penha', 'lat': -22.8436, 'lng': -43.2775, 
         'chuva_15min': random.uniform(0, 12), 'chuva_1h': random.uniform(4, 24), 'chuva_24h': random.uniform(10, 48)},
        {'id': 28, 'nome': 'Pavuna', 'lat': -22.8117, 'lng': -43.3539, 
         'chuva_15min': random.uniform(0, 12), 'chuva_1h': random.uniform(4, 24), 'chuva_24h': random.uniform(10, 48)},
        {'id': 29, 'nome': 'Iraj√°', 'lat': -22.8328, 'lng': -43.3264, 
         'chuva_15min': random.uniform(0, 12), 'chuva_1h': random.uniform(4, 24), 'chuva_24h': random.uniform(10, 48)},
        {'id': 30, 'nome': 'Santa Cruz', 'lat': -22.9197, 'lng': -43.6836, 
         'chuva_15min': random.uniform(0, 10), 'chuva_1h': random.uniform(3, 20), 'chuva_24h': random.uniform(7, 42)},
    ]
    
    stats = {
        'temperatura_media': round(random.uniform(22, 28), 1),
        'umidade_media': random.randint(60, 85),
        'chuva_24h': round(sum(p['chuva_24h'] for p in pluviometros) / len(pluviometros), 1),
        'vento_velocidade': random.randint(10, 25)
    }
    
    return JsonResponse({
        'success': True,
        'data': pluviometros,
        'stats': stats,
        'timestamp': datetime.now().isoformat()
    })

@csrf_exempt
def alertas_api(request):
    """API de alertas"""
    alertas = [
        {'id': 1, 'tipo': 'chuva_forte', 'severidade': 'alta', 
         'titulo': 'Chuva Forte', 'mensagem': 'Chuva forte prevista',
         'regiao': 'Zona Norte', 'lat': -22.9333, 'lng': -43.2333},
        {'id': 2, 'tipo': 'alagamento', 'severidade': 'media',
         'titulo': 'Risco de Alagamento', 'mensagem': 'Pontos de alagamento',
         'regiao': 'Zona Sul', 'lat': -22.9711, 'lng': -43.1822}
    ]
    
    return JsonResponse({
        'success': True,
        'alertas': alertas,
        'total': len(alertas),
        'timestamp': datetime.now().isoformat()
    })


 #VIDEO MONITORAMENTO - SEM LOGIN
@login_required(login_url='login')
@never_cache
def videomonitoramento(request):
    return render(request, 'mapa_novo/videomonitoramento.html')

# API DE CAMERAS - SEM LOGIN
@csrf_exempt
def cameras_api_local(request):
    import requests
    try:
        response = requests.get('https://aplicativo.cocr.com.br/cameras_api', timeout=10)
        return JsonResponse(response.json(), safe=False)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
def chuva_api(request):
    pluviometros = [
        {'id': 1, 'nome': 'Alto da Boa Vista', 'lat': -22.9667, 'lng': -43.2833, 
         'chuva_15min': 12.5, 'chuva_1h': 25.3, 'chuva_24h': 45.8},
        {'id': 2, 'nome': 'Tijuca', 'lat': -22.9333, 'lng': -43.2333, 
         'chuva_15min': 8.2, 'chuva_1h': 18.7, 'chuva_24h': 32.4},
    ]
    return JsonResponse({'success': True, 'data': pluviometros, 
        'stats': {'temperatura_media': 25.3, 'umidade_media': 68, 'chuva_24h': 29.1, 'vento_velocidade': 15}})

@csrf_exempt
def alertas_api(request):
    alertas = [{'id': 1, 'tipo': 'chuva_forte', 'titulo': 'Chuva Forte', 
                'mensagem': 'Chuva forte prevista', 'lat': -22.9333, 'lng': -43.2333}]
    return JsonResponse({'success': True, 'alertas': alertas, 'total': 1})


# VIDEO - SEM LOGIN - DEFINITIVO
def video_dashboard(request):
    return render(request, 'mapa_novo/videomonitoramento.html')

def api_cameras_proxy(request):
    import requests
    try:
        r = requests.get('https://aplicativo.cocr.com.br/cameras_api', timeout=10)
        return JsonResponse(r.json(), safe=False)
    except:
        return JsonResponse({'error': 'API offline'}, status=500)
    


logger = logging.getLogger(__name__)

@csrf_exempt
def estagio_proxy(request):
    """
    Proxy para API externa de est√°gio (API retorna s√≥ n√∫mero)
    """
    try:
        logger.info('Buscando est√°gio da API externa...')
        
        response = requests.get(
            'http://aplicativo.cocr.com.br/estagio_api_app',
            timeout=10
        )
        
        # Verificar se deu erro
        if response.status_code != 200:
            logger.error(f'API retornou status {response.status_code}')
            return JsonResponse({
                'cor': '#10b981',
                'estagio': 'Est√°gio 1',
                'mensagem': '',
                'mensagem2': '',
                'id': 1,
                'inicio': timezone.now().isoformat(),
                'fallback': True
            })
        
        # API retorna s√≥ o n√∫mero (ex: "1")
        numero_estagio = int(response.text.strip())
        
        # Mapeamento de cores por n√≠vel
        cores = {
            1: '#10b981',  # Verde
            2: '#fbbf24',  # Amarelo
            3: '#f97316',  # Laranja
            4: '#ef4444',  # Vermelho
            5: '#dc2626'   # Vermelho escuro
        }
        
        # Construir resposta completa
        data = {
            'cor': cores.get(numero_estagio, '#10b981'),
            'estagio': f'Est√°gio {numero_estagio}',
            'mensagem': '',
            'mensagem2': '',
            'id': numero_estagio,
            'inicio': timezone.now().isoformat()
        }
        
        logger.info(f'Est√°gio recebido: {numero_estagio}')
        return JsonResponse(data)
        
    except requests.exceptions.Timeout:
        logger.error('Timeout ao buscar API externa')
        return JsonResponse({
            'cor': '#10b981',
            'estagio': 'Est√°gio 1',
            'mensagem': 'API temporariamente indispon√≠vel',
            'mensagem2': '',
            'id': 1,
            'inicio': timezone.now().isoformat(),
            'fallback': True
        })
        
    except ValueError as e:
        logger.error(f'Erro ao converter n√∫mero do est√°gio: {str(e)}')
        return JsonResponse({
            'cor': '#10b981',
            'estagio': 'Est√°gio 1',
            'mensagem': 'Formato inv√°lido da API',
            'mensagem2': '',
            'id': 1,
            'inicio': timezone.now().isoformat(),
            'fallback': True
        }, status=500)
        
    except Exception as e:
        logger.error(f'Erro ao buscar est√°gio: {str(e)}')
        return JsonResponse({
            'cor': '#10b981',
            'estagio': 'Est√°gio 1',
            'mensagem': 'Erro ao buscar est√°gio',
            'mensagem2': '',
            'id': 1,
            'inicio': timezone.now().isoformat(),
            'fallback': True
        }, status=500)
        
        # Se API retornar erro 500
        if response.status_code != 200:
            logger.error(f'API externa retornou status {response.status_code}')
            # Retornar valores padr√£o
            return JsonResponse({
                'cor': '#10b981',
                'estagio': 'Est√°gio 1',
                'mensagem': '',
                'mensagem2': '',
                'id': 1,
                'inicio': '2025-11-09T18:00:00Z',
                'fallback': True  # Indica que √© valor padr√£o
            })
        
        data = response.json()
        logger.info(f'Est√°gio recebido: {data.get("estagio")}')
        
        return JsonResponse(data)
        
    except requests.exceptions.Timeout:
        logger.error('Timeout ao buscar API externa')
        return JsonResponse({
            'error': 'Timeout',
            'cor': '#10b981',
            'estagio': 'Est√°gio 1',
            'mensagem': 'API temporariamente indispon√≠vel',
            'mensagem2': '',
            'id': 1,
            'inicio': '2025-11-09T18:00:00Z',
            'fallback': True
        })
        
    except Exception as e:
        logger.error(f'Erro ao buscar est√°gio: {str(e)}')
        return JsonResponse({
            'error': str(e),
            'cor': '#10b981',
            'estagio': 'Est√°gio 1',
            'mensagem': 'Erro ao buscar est√°gio',
            'mensagem2': '',
            'id': 1,
            'inicio': '2025-11-09T18:00:00Z',
            'fallback': True
        }, status=500)

@login_required(login_url='login')
@never_cache
def mobilidade_dashboard_view(request):
    """Dashboard de Mobilidade Urbana"""
    return render(request, 'mapa_novo/mobilidade_dashboard.html')

@login_required(login_url='login')
@never_cache
def meteorologia_dashboard_view(request):
    """Dashboard de Meteorologia"""
    return render(request, 'mapa_novo/meteorologia_dashboard.html')

def defesa_civil_view(request):
    """Sistema de Defesa Civil"""
    
    # Buscar dados
    sirenes = Sirene.objects.filter(status='ativa').count()
    ocorrencias = Ocorrencia.objects.filter(status='aberta').count()
    alertas = Alerta.objects.filter(
        data_criacao__date=timezone.now().date()
    ).count()
    
    ocorrencias_recentes = Ocorrencia.objects.order_by('-data_criacao')[:10]
    
    context = {
        'system_name': 'Defesa Civil',
        'system_icon': 'shield-fill-exclamation',
        'sirenes_ativas': sirenes,
        'ocorrencias_abertas': ocorrencias,
        'alertas_dia': alertas,
        'ocorrencias': ocorrencias_recentes,
    }
    
    return render(request, 'sistemas/defesa_civil.html', context)




@csrf_exempt
def verificar_status_cameras(request):
    """
    Endpoint para verificar status das c√¢meras
    GET: Retorna status de todas as c√¢meras
    POST: Verifica c√¢mera espec√≠fica
    """
    try:
        # Buscar c√¢meras da API principal
        response = requests.get('https://aplicativo.cocr.com.br/camera_api_json', timeout=10)
        data = response.json()
        
        cameras_status = []
        
        for cam in data.get('cameras', []):
            camera_id = cam.get('id')
            nome = cam.get('nome', '')
            
            # Verificar se tem URL de stream
            stream_url = cam.get('stream_url') or cam.get('url')
            
            # L√≥gica de detec√ß√£o de status
            status = 'online'  # Padr√£o
            motivo = None
            
            # M√âTODO 1: Verificar timestamp (se existir)
            ultima_atualizacao = cam.get('ultima_atualizacao') or cam.get('last_update')
            if ultima_atualizacao:
                try:
                    # Converter timestamp para datetime
                    last_update = datetime.fromisoformat(ultima_atualizacao.replace('Z', '+00:00'))
                    agora = datetime.now(last_update.tzinfo)
                    
                    # Se n√£o atualizou h√° mais de 10 minutos, considerar offline
                    if (agora - last_update) > timedelta(minutes=10):
                        status = 'offline'
                        motivo = 'Sem atualiza√ß√£o h√° mais de 10 minutos'
                except:
                    pass
            
            # M√âTODO 2: Verificar se tem stream_url v√°lida
            if not stream_url or stream_url == '':
                status = 'offline'
                motivo = 'URL de stream n√£o configurada'
            
            # M√âTODO 3: Ping na URL (opcional - pode ser lento)
            # Descomentar se quiser ativar:
            # elif stream_url:
            #     try:
            #         head_response = requests.head(stream_url, timeout=3)
            #         if head_response.status_code >= 400:
            #             status = 'offline'
            #             motivo = f'HTTP {head_response.status_code}'
            #     except requests.exceptions.RequestException as e:
            #         status = 'offline'
            #         motivo = 'Stream inacess√≠vel'
            
            cameras_status.append({
                'camera_id': camera_id,
                'nome': nome,
                'status': status,
                'motivo': motivo,
                'lat': cam.get('lat'),
                'lon': cam.get('lon'),
                'ultima_verificacao': datetime.now().isoformat()
            })
        
        return JsonResponse({
            'success': True,
            'total': len(cameras_status),
            'online': len([c for c in cameras_status if c['status'] == 'online']),
            'offline': len([c for c in cameras_status if c['status'] == 'offline']),
            'cameras': cameras_status,
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f"Erro ao verificar status das c√¢meras: {str(e)}")
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@csrf_exempt
def ping_camera(request):
    """
    Verificar se uma c√¢mera espec√≠fica est√° respondendo
    POST: { "camera_id": "004227", "stream_url": "https://..." }
    """
    if request.method != 'POST':
        return JsonResponse({'error': 'M√©todo n√£o permitido'}, status=405)
    
    try:
        import json
        body = json.loads(request.body)
        
        camera_id = body.get('camera_id')
        stream_url = body.get('stream_url')
        
        if not stream_url:
            return JsonResponse({
                'camera_id': camera_id,
                'status': 'offline',
                'motivo': 'URL n√£o fornecida'
            })
        
        # Tentar HEAD request na URL do stream
        try:
            response = requests.head(stream_url, timeout=5)
            
            if response.status_code == 200:
                return JsonResponse({
                    'camera_id': camera_id,
                    'status': 'online',
                    'http_code': response.status_code,
                    'response_time': response.elapsed.total_seconds()
                })
            else:
                return JsonResponse({
                    'camera_id': camera_id,
                    'status': 'offline',
                    'motivo': f'HTTP {response.status_code}',
                    'http_code': response.status_code
                })
                
        except requests.exceptions.Timeout:
            return JsonResponse({
                'camera_id': camera_id,
                'status': 'offline',
                'motivo': 'Timeout'
            })
        except requests.exceptions.ConnectionError:
            return JsonResponse({
                'camera_id': camera_id,
                'status': 'offline',
                'motivo': 'Conex√£o recusada'
            })
        except Exception as e:
            return JsonResponse({
                'camera_id': camera_id,
                'status': 'offline',
                'motivo': str(e)
            })
            
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
    

@csrf_exempt
def camera_stream_info(request, camera_id):
    """Info de stream"""
    return JsonResponse({'camera_id': str(int(camera_id)), 'stream_available': False, 'snapshot_available': True})

@csrf_exempt
def cameras_status(request):
    """Status geral"""
    return JsonResponse({'streaming_enabled': False, 'snapshot_enabled': True})

@csrf_exempt
def camera_hls_placeholder(request, camera_id):
    """Placeholder HLS"""
    return JsonResponse({'error': 'HLS n√£o dispon√≠vel', 'camera_id': str(int(camera_id))}, status=503)

# ============================================
# CONFIGURA√á√ïES DE SNAPSHOT
# ============================================
SNAPSHOT_TIMEOUT = 5
SNAPSHOT_RETRY_ATTEMPTS = 2
CACHE_TTL = 60

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
logger = logging.getLogger(__name__)


@lru_cache(maxsize=100)
def get_snapshot_urls(camera_id: str) -> list:
    """
    Retorna lista de URLs candidatas para snapshot da c√¢mera.
    URLs s√£o testadas na ordem de prioridade.
    """
    # Normalizar IDs (tentar m√∫ltiplos formatos)
    ids_to_try = [camera_id]
    
    if camera_id.isdigit():
        # Tentar formatos: 6, 06, 006, 0006, 00006, 000006
        for width in [2, 3, 4, 5, 6]:
            padded = camera_id.zfill(width)
            if padded not in ids_to_try:
                ids_to_try.append(padded)
        
        # Tentar formato 10XX
        if len(camera_id) <= 4:
            ids_to_try.append(f"10{camera_id.zfill(2)}")
    
    urls = []
    for cam_id in ids_to_try:
        urls.extend([
            # Prioridade 1: API de snapshot dedicada
            f'https://dev.tixxi.rio/outvideo2/snapshot.php?CODE={cam_id}&KEY=B0914',
            f'https://dev.tixxi.rio/outvideo2/snapshot?CODE={cam_id}&KEY=B0914',
            
            # Prioridade 2: Aplicativo principal
            f'https://aplicativo.cocr.com.br/camera/{cam_id}/snapshot.jpg',
            f'https://aplicativo.cocr.com.br/snapshot/{cam_id}.jpg',
            f'https://aplicativo.cocr.com.br/cameras/snapshot/{cam_id}.jpg',
            
            # Prioridade 3: Endpoints alternativos
            f'http://aplicativo.cocr.com.br/camera/{cam_id}/snapshot.jpg',
        ])
    
    return urls


def try_fetch_snapshot(url: str, timeout: int = SNAPSHOT_TIMEOUT) -> tuple:
    """
    Tenta buscar snapshot de uma URL.
    
    Returns:
        tuple: (success: bool, content: bytes, status_code: int, error: str)
    """
    try:
        response = requests.get(url, timeout=timeout, verify=False)
        
        # Validar resposta
        if response.status_code == 200 and len(response.content) > 100:
            # Verificar se √© realmente uma imagem
            content_type = response.headers.get('content-type', '').lower()
            if any(t in content_type for t in ['image', 'jpeg', 'jpg', 'png']):
                return (True, response.content, 200, None)
        
        return (False, None, response.status_code, f"Invalid response: {response.status_code}")
        
    except requests.exceptions.Timeout:
        return (False, None, 0, "Timeout")
    except requests.exceptions.ConnectionError:
        return (False, None, 0, "Connection failed")
    except Exception as e:
        return (False, None, 0, str(e)[:100])


def generate_professional_placeholder(camera_id: str, attempts: int = 0) -> str:
    """
    Gera placeholder SVG profissional para c√¢mera offline.
    """
    timestamp = datetime.now().strftime('%H:%M:%S')
    
    return f'''<svg width="640" height="480" xmlns="http://www.w3.org/2000/svg">
        <!-- Background -->
        <rect width="640" height="480" fill="#0f172a"/>
        <rect width="640" height="480" fill="url(#gradient)" opacity="0.1"/>
        
        <!-- Gradient -->
        <defs>
            <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#1e40af;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#7c3aed;stop-opacity:1" />
            </linearGradient>
        </defs>
        
        <!-- Camera Icon -->
        <g transform="translate(320, 180)">
            <circle r="70" fill="#1e293b" opacity="0.5"/>
            <path d="M -40 -20 L -40 20 L 40 20 L 40 -20 L 20 -20 L 20 -30 L -20 -30 L -20 -20 Z" 
                  fill="#334155" stroke="#475569" stroke-width="2"/>
            <circle r="18" fill="#64748b"/>
            <circle r="12" fill="#334155"/>
            <circle cx="20" cy="-10" r="4" fill="#ef4444"/>
        </g>
        
        <!-- Status Badge -->
        <rect x="240" y="270" width="160" height="36" rx="18" fill="#1e293b" opacity="0.8"/>
        <circle cx="265" cy="288" r="6" fill="#ef4444">
            <animate attributeName="opacity" values="1;0.3;1" dur="2s" repeatCount="indefinite"/>
        </circle>
        <text x="280" y="293" font-family="system-ui, -apple-system, sans-serif" 
              font-size="14" fill="#e2e8f0" font-weight="500">OFFLINE</text>
        
        <!-- Camera ID -->
        <text x="320" y="330" font-family="system-ui, -apple-system, sans-serif" 
              font-size="16" fill="#94a3b8" text-anchor="middle" font-weight="300">
            C√¢mera #{camera_id}
        </text>
        
        <!-- Status Message -->
        <text x="320" y="360" font-family="system-ui, -apple-system, sans-serif" 
              font-size="13" fill="#64748b" text-anchor="middle">
            Aguardando conex√£o com o servidor
        </text>
        
        <!-- Timestamp -->
        <text x="320" y="385" font-family="'Courier New', monospace" 
              font-size="11" fill="#475569" text-anchor="middle">
            {timestamp} ‚Ä¢ {attempts} tentativa(s)
        </text>
        
        <!-- Footer -->
        <text x="320" y="450" font-family="system-ui, -apple-system, sans-serif" 
              font-size="10" fill="#334155" text-anchor="middle">
            Sistema de Videomonitoramento ‚Ä¢ COR
        </text>
    </svg>'''


@csrf_exempt
def camera_snapshot(request, camera_id):
    """Retorna player de stream ao inv√©s de snapshot"""
    
    # Formatar ID
    camera_id_padded = camera_id.zfill(6)
    
    # URL do player
    stream_url = f'https://dev.tixxi.rio/outvideo2/?CODE={camera_id_padded}&KEY=B0914'
    
    # Retornar HTML com iframe
    html = f'''
    <html>
    <head>
        <style>
            body {{ margin: 0; overflow: hidden; background: #000; }}
            iframe {{ width: 100%; height: 100vh; border: none; }}
        </style>
    </head>
    <body>
        <iframe src="{stream_url}" allowfullscreen></iframe>
    </body>
    </html>
    '''
    
    return HttpResponse(html, content_type='text/html')

@csrf_exempt
def camera_stream_view(request, camera_id):
    """
    Player de v√≠deo ao vivo - Abre quando usu√°rio clica na c√¢mera
    """
    # Normalizar ID
    camera_id_padded = camera_id.zfill(6)
    
    # Buscar info da c√¢mera (opcional)
    try:
        from aplicativo.models import Cameras
        camera = Cameras.objects.get(id_c=camera_id_padded)
        nome = camera.nome
        bairro = camera.bairro
    except:
        nome = f"C√¢mera {camera_id_padded}"
        bairro = ""
    
    # URL do stream
    stream_url = f'https://dev.tixxi.rio/outvideo2/?CODE={camera_id_padded}&KEY=B0914'
    
    # HTML responsivo com design moderno
    html = f'''
    <!DOCTYPE html>
    <html lang="pt-BR">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>{nome} - Ao Vivo</title>
        <style>
            * {{
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }}
            body {{
                background: #0f172a;
                overflow: hidden;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            }}
            .header {{
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
                padding: 20px 30px;
                color: white;
                z-index: 100;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }}
            .camera-info {{
                display: flex;
                align-items: center;
                gap: 15px;
            }}
            .live-badge {{
                background: #10b981;
                padding: 6px 14px;
                border-radius: 6px;
                font-size: 13px;
                font-weight: 600;
                display: flex;
                align-items: center;
                gap: 6px;
                box-shadow: 0 0 20px rgba(16, 185, 129, 0.4);
            }}
            .live-dot {{
                width: 8px;
                height: 8px;
                background: white;
                border-radius: 50%;
                animation: pulse 2s infinite;
            }}
            @keyframes pulse {{
                0%, 100% {{ opacity: 1; transform: scale(1); }}
                50% {{ opacity: 0.6; transform: scale(0.9); }}
            }}
            .camera-name {{
                font-size: 18px;
                font-weight: 600;
            }}
            .camera-location {{
                font-size: 14px;
                color: #94a3b8;
            }}
            .close-btn {{
                background: rgba(255,255,255,0.1);
                border: 1px solid rgba(255,255,255,0.2);
                color: white;
                padding: 10px 20px;
                border-radius: 8px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 500;
                transition: all 0.3s;
                display: flex;
                align-items: center;
                gap: 8px;
            }}
            .close-btn:hover {{
                background: rgba(255,255,255,0.2);
                border-color: rgba(255,255,255,0.3);
                transform: translateY(-1px);
            }}
            .player-container {{
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
            }}
            iframe {{
                width: 100%;
                height: 100%;
                border: none;
            }}
            .loading {{
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-size: 16px;
                display: none;
            }}
        </style>
    </head>
    <body>
        <div class="header">
            <div class="camera-info">
                <div class="live-badge">
                    <div class="live-dot"></div>
                    AO VIVO
                </div>
                <div>
                    <div class="camera-name">{nome}</div>
                    <div class="camera-location">üìç {bairro}</div>
                </div>
            </div>
            <button class="close-btn" onclick="window.close()">
                <span>‚úï</span>
                <span>Fechar</span>
            </button>
        </div>
        
        <div class="player-container">
            <div class="loading">Carregando transmiss√£o...</div>
            <iframe src="{stream_url}" allowfullscreen></iframe>
        </div>
    </body>
    </html>
    '''
    
    return HttpResponse(html, content_type='text/html')



# ============================================
# LOGIN SEGURO COM PROTE√á√ÉO
# ============================================
from django.contrib.auth import login as auth_login, logout as auth_logout, authenticate
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.shortcuts import render, redirect
from django.views.decorators.cache import never_cache
from django.views.decorators.csrf import csrf_protect
from django.views.decorators.http import require_http_methods
import logging

logger = logging.getLogger(__name__)

@never_cache
@csrf_protect
@require_http_methods(["GET", "POST"])
def login_view(request):
    """View de login com seguran√ßa refor√ßada"""
    # Se j√° est√° autenticado, redirecionar
    if request.user.is_authenticated:
        return redirect('cor_dashboard')
    
    if request.method == 'POST':
        username = request.POST.get('username', '').strip()
        password = request.POST.get('password', '')
        
        # Valida√ß√£o b√°sica
        if not username or not password:
            messages.error(request, 'Por favor, preencha todos os campos.')
            logger.warning(f'Tentativa de login sem credenciais completas')
            return render(request, 'login.html')
        
        # Limitar tamanho do username (prevenir ataques)
        if len(username) > 150:
            messages.error(request, 'Credenciais inv√°lidas.')
            logger.warning(f'Tentativa de login com username muito longo')
            return render(request, 'login.html')
        
        # Tentar autenticar
        user = authenticate(request, username=username, password=password)
        
        if user is not None:
            # Login bem-sucedido
            auth_login(request, user)
            
            # Configurar sess√£o segura
            request.session.set_expiry(43200)  # 12 horas
            request.session['last_activity'] = str(user.last_login)
            
            # Log de sucesso
            logger.info(f'Login bem-sucedido: {username}')
            messages.success(request, f'Bem-vindo, {user.username}!')
            
            # Redirecionar
            next_url = request.GET.get('next', 'cor_dashboard')
            return redirect(next_url)
        else:
            # Login falhou
            logger.warning(f'Tentativa de login falhou: {username} (IP: {request.META.get("REMOTE_ADDR")})')
            messages.error(request, 'Usu√°rio ou senha inv√°lidos.')
    
    return render(request, 'login.html')

@login_required(login_url='login')
@never_cache
def logout_view(request):
    """View de logout segura"""
    username = request.user.username
    auth_logout(request)
    logger.info(f'Logout: {username}')
    messages.info(request, 'Voc√™ saiu do sistema com seguran√ßa.')
    return redirect('login')

@login_required(login_url='login')
@never_cache
def dashboard(request):
    """Dashboard principal"""
    return redirect('cor_dashboard')

# ============================================
# APIS COM DADOS DE EXEMPLO PARA O MAPA COR
# ============================================

from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.http import JsonResponse


@api_view(['GET'])
def ventos_api(request):
    """API de ventos com dados de exemplo"""
    dados_exemplo = [
        {
            "id": 1,
            "nome": "Esta√ß√£o Ventos Centro",
            "latitude": -22.9035,
            "longitude": -43.2096,
            "velocidade": 15.5,
            "direcao": "NE",
            "rajada": 22.0
        },
        {
            "id": 2,
            "nome": "Esta√ß√£o Ventos Zona Sul",
            "latitude": -22.9711,
            "longitude": -43.1822,
            "velocidade": 18.2,
            "direcao": "SE",
            "rajada": 25.5
        }
    ]
    return Response({
        'success': True,
        'data': dados_exemplo,
        'count': len(dados_exemplo)
    })


@api_view(['GET'])
def waze_api(request):
    """API do Waze com dados de exemplo"""
    alertas_exemplo = [
        {
            "id": 1,
            "type": "ACCIDENT",
            "latitude": -22.9068,
            "longitude": -43.1729,
            "street": "Av. Rio Branco",
            "city": "Rio de Janeiro",
            "subtype": "ACCIDENT_MINOR",
            "reliability": 8
        },
        {
            "id": 2,
            "type": "JAM",
            "latitude": -22.9133,
            "longitude": -43.2096,
            "street": "Av. Presidente Vargas",
            "city": "Rio de Janeiro",
            "level": 4,
            "speed": 5
        }
    ]
    
    jams_exemplo = [
        {
            "id": 1,
            "level": 3,
            "street": "Av. Brasil",
            "city": "Rio de Janeiro",
            "speed": 10,
            "length": 500,
            "line": [
                {"latitude": -22.8708, "longitude": -43.2772},
                {"latitude": -22.8712, "longitude": -43.2780}
            ]
        }
    ]
    
    return Response({
        'success': True,
        'alerts': alertas_exemplo,
        'jams': jams_exemplo,
        'count': len(alertas_exemplo) + len(jams_exemplo)
    })


@api_view(['GET'])
def pluviometros_view(request):
    """API de pluvi√¥metros com dados de exemplo"""
    dados_exemplo = [
        {
            "id": 1,
            "nome": "Pluvi√¥metro Centro",
            "latitude": -22.9035,
            "longitude": -43.2096,
            "chuva_15min": 2.5,
            "chuva_1h": 8.0,
            "chuva_24h": 25.0,
            "status": "normal"
        },
        {
            "id": 2,
            "nome": "Pluvi√¥metro Tijuca",
            "latitude": -22.9256,
            "longitude": -43.2378,
            "chuva_15min": 5.2,
            "chuva_1h": 15.5,
            "chuva_24h": 45.0,
            "status": "atencao"
        },
        {
            "id": 3,
            "nome": "Pluvi√¥metro Zona Sul",
            "latitude": -22.9711,
            "longitude": -43.1822,
            "chuva_15min": 1.0,
            "chuva_1h": 3.5,
            "chuva_24h": 12.0,
            "status": "normal"
        }
    ]
    return Response({
        'success': True,
        'data': dados_exemplo,
        'count': len(dados_exemplo)
    })


@api_view(['GET'])
def eventos_view(request):
    """API de eventos com dados de exemplo"""
    eventos_exemplo = [
        {
            "id": 1,
            "tipo": "Alagamento",
            "descricao": "Alagamento na Av. Brasil",
            "latitude": -22.8708,
            "longitude": -43.2772,
            "status": "ativo",
            "data_hora": "2025-11-19T17:00:00"
        },
        {
            "id": 2,
            "tipo": "Deslizamento",
            "descricao": "Risco de deslizamento na Rocinha",
            "latitude": -22.9881,
            "longitude": -43.2489,
            "status": "monitoramento",
            "data_hora": "2025-11-19T16:30:00"
        }
    ]
    return Response({
        'success': True,
        'data': eventos_exemplo,
        'count': len(eventos_exemplo)
    })


@api_view(['GET'])
def ocorrencias_view(request):
    """API de ocorr√™ncias com dados de exemplo"""
    ocorrencias_exemplo = [
        {
            "id": 1,
            "tipo": "Queda de √°rvore",
            "endereco": "Rua das Laranjeiras, 340",
            "latitude": -22.9324,
            "longitude": -43.1812,
            "status": "em_atendimento",
            "prioridade": "media",
            "data_hora": "2025-11-19T15:45:00"
        },
        {
            "id": 2,
            "tipo": "Falta de energia",
            "endereco": "Av. Atl√¢ntica, 1500",
            "latitude": -22.9711,
            "longitude": -43.1822,
            "status": "pendente",
            "prioridade": "alta",
            "data_hora": "2025-11-19T16:20:00"
        }
    ]
    return Response({
        'success': True,
        'data': ocorrencias_exemplo,
        'count': len(ocorrencias_exemplo)
    })


@api_view(['GET'])
def calor_api(request):
    """API de dados de calor"""
    return Response({
        'success': True,
        'temperatura': 32.5,
        'sensacao_termica': 38.0,
        'umidade': 65,
        'nivel_alerta': 'moderado'
    })


@api_view(['GET'])
def mobilidade_api(request):
    """API de mobilidade"""
    return Response({
        'nivel': 'normal',
        'transito': {
            'nivel': 'normal',
            'descricao': 'Tr√¢nsito fluindo normalmente'
        },
        'metro': {
            'status': 'normal',
            'descricao': 'Opera√ß√£o normal em todas as linhas'
        },
        'onibus': {
            'status': 'normal',
            'descricao': 'Frota operando normalmente'
        }
    })

# ============================================
# VIEW DE TESTE - SEM PROTE√á√ÉO
# ============================================
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny

@api_view(['GET'])
@permission_classes([AllowAny])
def test_api_sem_protecao(request):
    """API de teste sem prote√ß√£o"""
    return Response({
        'status': 'OK',
        'message': 'API funcionando sem prote√ß√£o!',
        'user_authenticated': request.user.is_authenticated,
        'username': request.user.username if request.user.is_authenticated else 'An√¥nimo'
    })

# ============================================
# APIs DE MOBILIDADE
# ============================================

@api_view(['GET'])
def api_transito_status(request):
    """API de status do tr√¢nsito"""
    import datetime
    
    hora_atual = datetime.datetime.now().hour
    
    # Simular status baseado na hora
    if 7 <= hora_atual <= 9 or 17 <= hora_atual <= 19:
        nivel = 3
        descricao = "Tr√¢nsito Intenso"
        cor = "#ef4444"
        lentidao = 45
        velocidade = 25
    elif 10 <= hora_atual <= 16:
        nivel = 2
        descricao = "Tr√¢nsito Moderado"
        cor = "#f59e0b"
        lentidao = 20
        velocidade = 40
    else:
        nivel = 1
        descricao = "Tr√¢nsito Normal"
        cor = "#10b981"
        lentidao = 5
        velocidade = 55
    
    return Response({
        'success': True,
        'data': {
            'nivel': nivel,
            'descricao': descricao,
            'cor': cor,
            'lentidao_km': lentidao,
            'velocidade_media': velocidade,
            'hora': hora_atual
        }
    })


@api_view(['GET'])
def api_brt(request):
    """API de linhas BRT"""
    linhas = [
        {
            'nome': 'TransCarioca',
            'cor': '#0066cc',
            'status': 'Normal',
            'status_code': 'normal',
            'estacoes': 45,
            'extensao': '39 km',
            'tempo_medio': '60 min',
            'intervalo': '8-12 min'
        },
        {
            'nome': 'TransOeste',
            'cor': '#00a651',
            'status': 'Normal',
            'status_code': 'normal',
            'estacoes': 52,
            'extensao': '56 km',
            'tempo_medio': '75 min',
            'intervalo': '10-15 min'
        },
        {
            'nome': 'TransOl√≠mpica',
            'cor': '#f7941e',
            'status': 'Normal',
            'status_code': 'normal',
            'estacoes': 18,
            'extensao': '26 km',
            'tempo_medio': '35 min',
            'intervalo': '5-8 min'
        },
        {
            'nome': 'TransBrasil',
            'cor': '#ed1c24',
            'status': 'Normal',
            'status_code': 'normal',
            'estacoes': 28,
            'extensao': '32 km',
            'tempo_medio': '45 min',
            'intervalo': '7-10 min'
        }
    ]
    
    return Response({
        'success': True,
        'data': linhas,
        'count': len(linhas)
    })


@api_view(['GET'])
def api_metro(request):
    """API de linhas de metr√¥"""
    linhas = [
        {
            'nome': 'Linha 1 (Laranja)',
            'cor': '#ff6600',
            'status': 'Normal',
            'status_code': 'normal',
            'estacoes': 19,
            'extensao': '20,4 km',
            'intervalo': '4-6 min',
            'origem': 'Ipanema/General Os√≥rio',
            'destino': 'Uruguai'
        },
        {
            'nome': 'Linha 2 (Verde)',
            'cor': '#00a651',
            'status': 'Normal',
            'status_code': 'normal',
            'estacoes': 18,
            'extensao': '31,7 km',
            'intervalo': '5-8 min',
            'origem': 'Pavuna',
            'destino': 'Botafogo'
        },
        {
            'nome': 'Linha 4 (Amarela)',
            'cor': '#ffcc00',
            'status': 'Normal',
            'status_code': 'normal',
            'estacoes': 6,
            'extensao': '16 km',
            'intervalo': '6-10 min',
            'origem': 'Ipanema/General Os√≥rio',
            'destino': 'Jardim Oce√¢nico'
        }
    ]
    
    return Response({
        'success': True,
        'data': linhas,
        'count': len(linhas)
    })


@api_view(['GET'])
def api_bike_rio(request):
    """API de esta√ß√µes Bike Rio"""
    import random
    
    estacoes = []
    nomes = [
        'Copacabana - Siqueira Campos', 'Ipanema - Pra√ßa General Os√≥rio',
        'Leblon - Ataulfo de Paiva', 'Botafogo - Volunt√°rios da P√°tria',
        'Flamengo - Praia do Flamengo', 'Centro - Pra√ßa XV'
    ]
    
    for i, nome in enumerate(nomes):
        bikes = random.randint(0, 15)
        vagas = random.randint(5, 20)
        
        estacoes.append({
            'id': i + 1,
            'nome': nome,
            'bikes_disponiveis': bikes,
            'vagas_disponiveis': vagas,
            'status': 'Operacional' if bikes > 0 else 'Sem Bikes'
        })
    
    total_bikes = sum(e['bikes_disponiveis'] for e in estacoes)
    
    return Response({
        'success': True,
        'data': estacoes,
        'count': len(estacoes),
        'total_bikes': total_bikes
    })