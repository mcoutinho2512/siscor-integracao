{% load static %}
<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobilidade Urbana - SISCOR</title>

    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">

    <!-- COR Styles -->
    <link rel="stylesheet" href="{% static 'mapa_novo/css/cor_navbar.css' %}">
    <link rel="stylesheet" href="{% static 'mapa_novo/css/cor_menu.css' %}">
    <link rel="stylesheet" href="{% static 'mapa_novo/css/dark_theme.css' %}">
    <link rel="stylesheet" href="{% static 'mapa_novo/css/dark_mode.css' %}">
    <link rel="icon" type="image/svg+xml" href="{% static 'favicon.svg' %}">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />

    <!-- Design System Padronizado COR -->
    <link rel="stylesheet" href="{% static 'mapa_novo/css/cor_design_system.css' %}">
    <link rel="stylesheet" href="{% static 'mapa_novo/css/cor_components.css' %}">
    <link rel="stylesheet" href="{% static 'mapa_novo/css/sistemas_padronizados.css' %}">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            overflow-x: hidden;
            overflow-y: auto;
            height: auto;
            min-height: 100vh;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
        }

        /* Container Principal */
        .dashboard-container {
            padding: 160px 20px 20px 20px;
            max-width: 1600px;
            margin: 0 auto;
            height: auto;
            min-height: calc(100vh - 160px);
        }

        /* Header Padronizado */
        .dashboard-header {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border-radius: 16px;
            padding: 32px;
            margin-bottom: 24px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .header-title h1 {
            font-size: 28px;
            font-weight: 700;
            color: #f8fafc;
            margin: 0;
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .header-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #f8fafc;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .header-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .header-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
        }

        .header-stat {
            text-align: center;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #f59e0b;
            margin-bottom: 4px;
        }

        .header-stat-label {
            font-size: 12px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Sections */
        .mob-section {
            background: #1e293b;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mob-section-title {
            color: #f8fafc;
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mob-section-title i {
            color: #f59e0b;
        }

        /* Cards Grid */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }

        .linha-card {
            background: linear-gradient(135deg, #334155 0%, #1e293b 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .linha-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--linha-cor, #f59e0b);
        }

        .linha-card:hover {
            transform: translateY(-4px);
            border-color: var(--linha-cor, #f59e0b);
            box-shadow: 0 8px 24px rgba(245, 158, 11, 0.2);
        }

        .linha-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .linha-nome {
            font-weight: 700;
            color: #f8fafc;
            font-size: 18px;
        }

        .linha-status {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .linha-status.normal {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .linha-status.alerta {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .linha-status.obras {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .linha-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .linha-info-item {
            font-size: 13px;
            color: #94a3b8;
        }

        .linha-info-item strong {
            color: #f8fafc;
            display: block;
            margin-top: 2px;
            font-size: 16px;
        }

        /* Bike Rio Cards */
        .bike-card {
            background: linear-gradient(135deg, #334155 0%, #1e293b 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s;
        }

        .bike-card:hover {
            border-color: #10b981;
            transform: translateY(-2px);
        }

        .bike-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .bike-nome {
            font-weight: 600;
            color: #f8fafc;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bike-nome i {
            color: #10b981;
        }

        .bike-status {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .bike-status.sem-bikes {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .bike-stats {
            display: flex;
            gap: 16px;
            margin-top: 12px;
        }

        .bike-stat {
            flex: 1;
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .bike-stat-value {
            font-size: 20px;
            font-weight: 700;
            color: #10b981;
        }

        .bike-stat-label {
            font-size: 11px;
            color: #94a3b8;
            margin-top: 4px;
        }

        /* Status do transito */
        .transito-status {
            background: linear-gradient(135deg, #334155 0%, #1e293b 100%);
            border-radius: 12px;
            padding: 32px;
            text-align: center;
            border: 2px solid;
        }

        .transito-status.Nível-1 {
            border-color: #10b981;
        }

        .transito-status.Nível-2 {
            border-color: #f59e0b;
        }

        .transito-status.Nível-3 {
            border-color: #ef4444;
        }

        .transito-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
        }

        .transito-descricao {
            font-size: 24px;
            font-weight: 700;
            color: #f8fafc;
            margin-bottom: 8px;
        }

        .transito-detalhes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 16px;
            margin-top: 24px;
        }

        .transito-detail {
            text-align: center;
        }

        .transito-detail-value {
            font-size: 20px;
            font-weight: 700;
            color: #f8fafc;
        }

        .transito-detail-label {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 4px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #94a3b8;
        }

        .loading i {
            font-size: 48px;
            animation: spin 1s linear infinite;
            color: #f59e0b;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Modal de Rotas */
        .rota-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .rota-modal.active {
            display: flex;
        }

        .rota-modal-content {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 16px;
            padding: 0;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .rota-modal-header {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            padding: 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .rota-modal-title {
            display: flex;
            align-items: center;
            gap: 12px;
            color: white;
            font-size: 20px;
            font-weight: 700;
        }

        .rota-modal-title i {
            font-size: 24px;
        }

        .rota-modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 20px;
            transition: all 0.2s;
        }

        .rota-modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .nova-rota-body {
            padding: 24px;
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            max-height: calc(90vh - 180px);
            position: relative;
            /* … ADICIONAR */
            z-index: 1;
            /* … ADICIONAR */
        }

        /* Estilizar scrollbar */
        .nova-rota-body::-webkit-scrollbar {
            width: 8px;
        }

        .nova-rota-body::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .nova-rota-body::-webkit-scrollbar-thumb {
            background: rgba(16, 185, 129, 0.5);
            border-radius: 4px;
        }

        .nova-rota-body::-webkit-scrollbar-thumb:hover {
            background: rgba(16, 185, 129, 0.7);
        }

        .rota-info-grid {
            display: grid;
            gap: 16px;
        }

        .rota-info-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .rota-info-label {
            color: #94a3b8;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .rota-info-label i {
            color: #f59e0b;
        }

        .rota-info-value {
            color: #f8fafc;
            font-size: 16px;
            font-weight: 500;
            line-height: 1.5;
        }

        .rota-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .rota-stat-card {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .rota-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #f59e0b;
        }

        .rota-stat-label {
            font-size: 11px;
            color: #94a3b8;
            margin-top: 4px;
            text-transform: uppercase;
        }

        .rota-modal-footer {
            padding: 16px 24px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .rota-modal-btn {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rota-modal-btn-primary {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .rota-modal-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }

        .rota-modal-btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #f8fafc;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .rota-modal-btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Painel de Controle de Rotas - CORRIGIDO */
        .rotas-control-panel {
            position: fixed;
            top: 160px;
            right: 20px;
            width: 320px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 999;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        .rotas-control-panel.minimized {
            transform: translateX(360px);
        }

        .rotas-panel-header {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            padding: 16px 20px;
            border-radius: 16px 16px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .rotas-panel-title {
            color: white;
            font-size: 16px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rotas-panel-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .rotas-panel-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .rotas-panel-body {
            padding: 20px;
        }

        .rotas-section {
            margin-bottom: 24px;
        }

        .rotas-section-title {
            color: #f8fafc;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rotas-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .rotas-stat-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .rotas-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #f59e0b;
        }

        .rotas-stat-label {
            font-size: 11px;
            color: #94a3b8;
            margin-top: 4px;
        }

        .rotas-filter {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s;
        }

        .rotas-filter:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .rotas-filter-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .rotas-filter-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }

        .rotas-filter-text {
            color: #f8fafc;
            font-size: 14px;
            font-weight: 500;
        }

        .rotas-filter-count {
            color: #94a3b8;
            font-size: 12px;
        }

        .rotas-toggle-switch {
            width: 44px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            position: relative;
            transition: background 0.2s;
        }

        .rotas-toggle-switch.active {
            background: #10b981;
        }

        .rotas-toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 10px;
            transition: transform 0.2s;
        }

        .rotas-toggle-switch.active .rotas-toggle-slider {
            transform: translateX(20px);
        }

        .rotas-action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #f8fafc;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
            margin-bottom: 8px;
        }

        .rotas-action-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }

        .rotas-action-btn i {
            font-size: 14px;
        }

        /* Legenda de cores */
        .rotas-legend {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
        }

        .rotas-legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }

        .rotas-legend-item:last-child {
            margin-bottom: 0;
        }

        .rotas-legend-line {
            width: 30px;
            height: 4px;
            border-radius: 2px;
        }

        .rotas-legend-label {
            color: #cbd5e1;
            font-size: 13px;
            flex: 1;
        }

        .rotas-legend-count {
            color: #64748b;
            font-size: 12px;
            font-weight: 600;
        }

        /* Botao flutuante de controle */
        .map-control-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 8px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
            z-index: 999;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .map-control-btn.visible {
            display: flex;
        }

        .map-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(245, 158, 11, 0.5);
        }

        .map-control-btn .badge {
            position: absolute;
            top: -6px;
            right: -6px;
            background: #ef4444;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #0f172a;
        }

        /* Modo de desenho */
        .desenho-mode-indicator {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            z-index: 1000;
            display: none;
            align-items: center;
            gap: 8px;
            animation: pulse 2s infinite;
        }

        .desenho-mode-indicator.active {
            display: flex;
        }

        #mobilidade-map {
            position: relative;
            z-index: 1;
        }

        /* Garantir que o mapa capture eventos quando em modo de desenho */
        #mobilidade-map.desenho-ativo {
            z-index: 1000 !important;
        }

        .leaflet-container {
            cursor: inherit !important;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            }

            50% {
                box-shadow: 0 4px 20px rgba(16, 185, 129, 0.6);
            }
        }

        /* Animacao para quando o modal fechar */
        .nova-rota-modal.fechando {
            animation: modalFadeOut 0.3s ease forwards;
        }

        @keyframes modalFadeOut {
            from {
                opacity: 1;
                transform: scale(1);
            }

            to {
                opacity: 0;
                transform: scale(0.95);
            }
        }

        /* Indicador mais visivel */
        .desenho-mode-indicator {
            animation: pulse-draw 2s infinite, slideDown 0.5s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translate(-50%, -20px);
            }

            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        @keyframes pulse-draw {

            0%,
            100% {
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            }

            50% {
                box-shadow: 0 4px 25px rgba(16, 185, 129, 0.7);
            }
        }

        /* Animacao para marcadores do Waze */
        @keyframes pulse-waze {

            0%,
            100% {
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
                transform: scale(1.1);
            }
        }

        /* Hover suave para marcadores Waze */
        .waze-marker-icon:hover {
            transform: scale(1.15) !important;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5) !important;
            z-index: 10000 !important;
        }

        .waze-marker-icon:active {
            transform: scale(1.05) !important;
        }

        /* Garantir que o marcador esteja sempre visivel */
        .waze-marker {
            z-index: 1000 !important;
            pointer-events: auto !important;
        }

        .waze-marker .waze-marker-icon {
            pointer-events: auto !important;
        }

        .desenho-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 12px;
            z-index: 1000;
        }

        .desenho-controls.active {
            display: flex;
        }

        .desenho-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #10b981;
            color: #0f172a;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .desenho-btn:hover {
            background: #10b981;
            color: white;
            transform: translateY(-2px);
        }

        .desenho-btn.cancel {
            border-color: #ef4444;
        }

        .desenho-btn.cancel:hover {
            background: #ef4444;
        }

        /* Modal de Nova Rota */
        .nova-rota-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10001;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .nova-rota-modal.active {
            display: flex;
        }

        .nova-rota-content {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 16px;
            padding: 0;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            /* … AUMENTADO */
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: modalSlideIn 0.3s ease;
            display: flex;
            flex-direction: column;
            /* … IMPORTANTE */
        }

        .nova-rota-header {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            padding: 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 16px 16px 0 0;
        }

        .nova-rota-header h3 {
            color: white;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 20px;
        }

        .nova-rota-body {
            padding: 24px;
            max-height: calc(85vh - 160px);
            /* … AJUSTADO */
            overflow-y: auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            color: #f8fafc;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            color: #f8fafc;
            font-size: 14px;
            transition: all 0.2s;
        }

        .form-input:focus {
            outline: none;
            border-color: #10b981;
            background: rgba(255, 255, 255, 0.08);
        }

        .form-select {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            color: #f8fafc;
            font-size: 14px;
            cursor: pointer;
        }

        .form-select option {
            background: #1e293b;
            color: #f8fafc;
        }

        .nova-rota-footer {
            padding: 20px 24px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            background: rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
            /* … NAƒO ENCOLHE */
        }

        .nova-rota-btn {
            padding: 12px 24px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: 700;
            font-size: 14px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .nova-rota-btn.primary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .nova-rota-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.5);
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }

        .nova-rota-btn.primary:active {
            transform: translateY(0);
        }

        .nova-rota-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #f8fafc;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .nova-rota-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .nova-rota-btn.secondary:active {
            transform: translateY(0);
        }

        .search-btn {
            width: 100%;
            margin-top: 8px;
            padding: 10px 16px;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15) 0%, rgba(5, 150, 105, 0.15) 100%);
            border: 2px solid rgba(16, 185, 129, 0.3);
            color: #10b981;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 700;
            font-size: 14px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-btn:hover {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.25) 0%, rgba(5, 150, 105, 0.25) 100%);
            border-color: #10b981;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .search-btn:active {
            transform: translateY(0);
        }

        .btn-calcular-rota {
            width: 100%;
            padding: 16px 24px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border: none;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            font-size: 16px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 16px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }

        .btn-calcular-rota:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        }

        .btn-calcular-rota:active {
            transform: translateY(-1px);
        }

        .btn-calcular-rota i {
            font-size: 20px;
            animation: pulse-icon 2s infinite;
        }

        @keyframes pulse-icon {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        .btn-iniciar-desenho {
            padding: 18px 40px;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            border: none;
            color: white;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700;
            font-size: 17px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4);
            position: relative;
            overflow: hidden;
            pointer-events: auto !important;
            /* … JA EXISTE */
            z-index: 10000 !important;
            /* … AUMENTAR MUITO O Z-INDEX */
        }

        .btn-iniciar-desenho::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn-iniciar-desenho:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn-iniciar-desenho:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.6);
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
        }

        .btn-iniciar-desenho:active {
            transform: translateY(-2px) scale(1.02);
        }

        .btn-iniciar-desenho i {
            font-size: 22px;
            position: relative;
            z-index: 1;
        }

        .btn-iniciar-desenho span {
            position: relative;
            z-index: 1;
        }


        /* MODAL SUPER PROFISSIONAL */
        .rota-modal-body {
            padding: 0;
            overflow-y: auto;
            overflow-x: hidden;
            max-height: calc(80vh - 160px);
            background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
        }

        /* Estilizar scrollbar */
        .rota-modal-body::-webkit-scrollbar {
            width: 8px;
        }

        .rota-modal-body::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .rota-modal-body::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.5);
            border-radius: 4px;
        }

        .rota-modal-body::-webkit-scrollbar-thumb:hover {
            background: rgba(59, 130, 246, 0.7);
        }

        /* Modal Waze - Layout Profissional */
        .waze-modal-section {
            padding: 20px 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .waze-modal-section:last-child {
            border-bottom: none;
        }

        .waze-section-title {
            color: #94a3b8;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .waze-hero {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2) 0%, rgba(37, 99, 235, 0.1) 100%);
            padding: 24px;
            text-align: center;
            border-bottom: 2px solid rgba(59, 130, 246, 0.3);
        }

        .waze-hero-icon {
            font-size: 48px;
            margin-bottom: 12px;
            animation: pulse-icon 2s infinite;
        }

        .waze-hero-title {
            font-size: 24px;
            font-weight: 700;
            color: #f8fafc;
            margin-bottom: 4px;
        }

        .waze-hero-subtitle {
            font-size: 14px;
            color: #94a3b8;
        }

        .waze-info-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .waze-info-row:hover {
            background: rgba(255, 255, 255, 0.06);
            transform: translateX(4px);
        }

        .waze-info-icon {
            width: 40px;
            height: 40px;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            flex-shrink: 0;
        }

        .waze-info-content {
            flex: 1;
        }

        .waze-info-label {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
        }

        .waze-info-value {
            font-size: 15px;
            color: #f8fafc;
            font-weight: 500;
        }

        .waze-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
        }

        .waze-stat-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 16px 12px;
            text-align: center;
            transition: all 0.2s;
        }

        .waze-stat-box:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(59, 130, 246, 0.3);
            transform: translateY(-2px);
        }

        .waze-stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #3b82f6;
            margin-bottom: 4px;
            line-height: 1;
        }

        .waze-stat-label {
            font-size: 11px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .waze-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .waze-badge.danger {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .waze-badge.warning {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .waze-badge.info {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .waze-badge.success {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .waze-source {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(37, 99, 235, 0.05) 100%);
            padding: 16px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .waze-source img {
            height: 24px;
        }

        .waze-source-text {
            flex: 1;
            font-size: 13px;
            color: #cbd5e1;
        }


        /* ===== CARD DE STATUS DAS VIAS ===== */
        .via-status-card {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .via-status-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--status-cor);
        }

        .via-status-card:hover {
            transform: translateY(-2px);
            border-color: var(--status-cor);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .via-status-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .via-status-info {
            flex: 1;
        }

        .via-nome {
            font-size: 18px;
            font-weight: 700;
            color: #f8fafc;
            margin-bottom: 4px;
        }

        .via-hierarquia {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.1);
            color: #cbd5e1;
        }

        .via-status-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .via-status-badge.normal {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.4);
        }

        .via-status-badge.moderado {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.4);
        }

        .via-status-badge.intenso {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.4);
        }

        .via-status-badge.critico {
            background: rgba(220, 38, 38, 0.2);
            color: #dc2626;
            border: 1px solid rgba(220, 38, 38, 0.4);
        }

        .via-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }

        .via-metric {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .via-metric-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--metric-color, #f8fafc);
            margin-bottom: 4px;
        }

        .via-metric-label {
            font-size: 11px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .via-alertas {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .via-alerta-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .via-alerta-badge.acidente {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .via-alerta-badge.congestionamento {
            background: rgba(245, 158, 11, 0.15);
            border-color: rgba(245, 158, 11, 0.3);
            color: #f59e0b;
        }

        .via-alerta-badge.perigo {
            background: rgba(245, 158, 11, 0.15);
            border-color: rgba(245, 158, 11, 0.3);
            color: #f59e0b;
        }

        .via-alerta-badge.obra {
            background: rgba(99, 102, 241, 0.15);
            border-color: rgba(99, 102, 241, 0.3);
            color: #6366f1;
        }

        .via-sem-dados {
            text-align: center;
            padding: 40px;
            color: #64748b;
        }

        .via-sem-dados i {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Detalhes Expandidos */
        .via-detalhes {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .via-detalhes.expanded {
            max-height: 2000px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .via-detalhes-lista {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .alerta-detalhe-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid var(--alerta-cor);
            border-radius: 8px;
            padding: 16px;
            transition: all 0.2s;
        }

        .alerta-detalhe-item:hover {
            background: rgba(255, 255, 255, 0.06);
            transform: translateX(4px);
        }

        .alerta-detalhe-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .alerta-detalhe-tipo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            font-weight: 700;
            color: #f8fafc;
        }

        .alerta-detalhe-horario {
            font-size: 12px;
            color: #64748b;
        }

        .alerta-detalhe-info {
            font-size: 14px;
            color: #cbd5e1;
            line-height: 1.6;
        }

        .alerta-detalhe-info strong {
            color: #f8fafc;
        }

        .via-toggle-btn {
            margin-top: 16px;
            padding: 10px 20px;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: #3b82f6;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .via-toggle-btn:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: translateY(-2px);
        }

        .via-sem-alertas {
            text-align: center;
            padding: 24px;
            color: #64748b;
            font-size: 14px;
        }

        /* ===== CARDS DAS VIAS EM GRID ===== */
        #status-vias-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            padding: 20px;
            max-height: 800px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #vias-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
            padding: 20px;
        }

        .via-card {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid rgba(77, 208, 225, 0.3);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .via-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(77, 208, 225, 0.2);
            border-color: rgba(77, 208, 225, 0.5);
        }

        .via-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #fff 0%, rgba(255, 255, 255, 0.5) 100%);
        }

        .via-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .via-card-title {
            font-size: 18px;
            font-weight: 700;
            color: white;
            margin-bottom: 4px;
        }

        .via-card-hierarquia {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #64748b;
            font-weight: 600;
        }

        .via-card-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .via-card-status.normal {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.4);
        }

        .via-card-status.atencao {
            background: rgba(245, 158, 11, 0.3);
            color: #f59e0b;
        }

        .via-card-status.intenso {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.4);
        }

        .via-card-status.critico {
            background: rgba(220, 38, 38, 0.2);
            color: #dc2626;
            border: 1px solid rgba(220, 38, 38, 0.4);
        }

        .via-card-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .via-card-stat {
            background: rgba(255, 255, 255, 0.05);
            padding: 16px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .via-card-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: white;
            margin-bottom: 4px;
        }

        .via-card-stat-label {
            font-size: 11px;
            text-transform: uppercase;
            color: #94a3b8;
            letter-spacing: 0.5px;
        }

        .via-card-button {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .via-card-button:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        /* Estilizar scrollbar */
        #status-vias-container::-webkit-scrollbar {
            width: 8px;
        }

        #status-vias-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        #status-vias-container::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-radius: 4px;
        }

        #status-vias-container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        }

        /* ===== ROTAS ALTERNATIVAS ===== */
        .rota-card {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
        }

        .rota-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--rota-cor);
        }

        .rota-card:hover {
            transform: translateY(-4px);
            border-color: var(--rota-cor);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
        }

        .rota-card.selecionada {
            border-color: var(--rota-cor);
            background: linear-gradient(135deg, rgba(var(--rota-cor-rgb), 0.1) 0%, #0f172a 100%);
            box-shadow: 0 0 20px rgba(var(--rota-cor-rgb), 0.3);
        }

        .rota-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .rota-titulo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .rota-icone {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: rgba(var(--rota-cor-rgb), 0.2);
            color: var(--rota-cor);
        }

        .rota-nome {
            font-size: 18px;
            font-weight: 700;
            color: #f8fafc;
        }

        .rota-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .rota-badge.recomendada {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.4);
        }

        .rota-tempo-principal {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            margin-bottom: 16px;
        }

        .rota-tempo-valor {
            font-size: 48px;
            font-weight: 700;
            color: var(--rota-cor);
            line-height: 1;
            margin-bottom: 8px;
        }

        .rota-tempo-label {
            font-size: 14px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .rota-metricas {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }

        .rota-metrica {
            text-align: center;
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .rota-metrica-valor {
            font-size: 20px;
            font-weight: 700;
            color: #f8fafc;
            margin-bottom: 4px;
        }

        .rota-metrica-label {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
        }

        .rota-vias-lista {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .rota-via-item {
            padding: 8px;
            font-size: 13px;
            color: #cbd5e1;
            border-left: 3px solid var(--rota-cor);
            margin-bottom: 6px;
            padding-left: 12px;
        }

        .rota-via-item:last-child {
            margin-bottom: 0;
        }

        .marcador-origem,
        .marcador-destino {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 700;
            color: white;
            border: 3px solid white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .marcador-origem {
            background: #10b981;
        }

        .marcador-destino {
            background: #ef4444;
        }

        .rota-tooltip {
            background: rgba(15, 23, 42, 0.95) !important;
            border: 2px solid rgba(255, 255, 255, 0.2) !important;
            border-radius: 8px !important;
            padding: 8px 12px !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
        }

        .rota-tooltip::before {
            border-top-color: rgba(15, 23, 42, 0.95) !important;
        }

        .rota-polyline {
            transition: all 0.3s;
        }

        .rota-polyline:hover {
            weight: 10 !important;
            opacity: 1 !important;
        }

        /* Modal de Rotas Alternativas */
        .rota-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            z-index: 999999;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .rota-modal-content {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 16px;
            border: 2px solid rgba(59, 130, 246, 0.3);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            animation: modalSlideIn 0.3s ease;
            max-width: 1200px;
            width: 100%;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .rota-modal-header {
            padding: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .rota-modal-title {
            font-size: 24px;
            font-weight: 700;
            color: white;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .rota-modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .rota-modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(90deg);
        }

        .rota-modal-body {
            padding: 0;
            max-height: calc(90vh - 200px);
            overflow-y: auto;
        }

        .rota-modal-footer {
            padding: 20px 24px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .rota-modal-btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rota-modal-btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .rota-modal-btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #modal-mapa-rotas {
            height: 400px;
            width: 100%;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }
        }

        .rota-card:hover {
            transform: translateX(8px) !important;
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.3) !important;
        }

        /* ===== RESPONSIVIDADE MOBILE - CONSERVADOR ===== */

        /* Corrigir grid em mobile */
        @Média (max-width: 768px) {
            .cards-grid {
                grid-template-columns: 1fr !important;
                gap: 12px;
            }

            .header-stats {
                grid-template-columns: repeat(2, 1fr) !important;
            }

            .linha-info {
                grid-template-columns: 1fr !important;
            }

            .bike-stats {
                flex-direction: column !important;
            }
        }

        @Média (max-width: 480px) {
            .header-stats {
                grid-template-columns: 1fr !important;
            }

            .rota-stats {
                grid-template-columns: 1fr !important;
            }
        }
    </style>
</head>

<body>

    <!-- Normalizador de acentuaçío e logs (evita símbolos estranhos no DOM e console) -->


    {% include 'includes/navbar_top.html' %}
    {% include 'includes/navbar_menu.html' %}



    <li class="cor-menu-item">
        <a href="#" class="cor-menu-link">
            Meteorologia
            <i class="bi bi-chevron-down dropdown-icon"></i>
        </a>
        <ul class="cor-submenu">
            <li class="cor-submenu-item">
                <a href="/meteorologia/" class="cor-submenu-link">
                    <i class="bi bi-cloud-sun"></i>
                    Dashboard
                </a>
            </li>
        </ul>
    </li>

    <li class="cor-menu-item">
        <a href="#" class="cor-menu-link">
            Defesa Civil
            <i class="bi bi-chevron-down dropdown-icon"></i>
        </a>
        <ul class="cor-submenu">
            <li class="cor-submenu-item">
                <a href="#" class="cor-submenu-link">
                    <i class="bi bi-megaphone"></i>
                    Sirenes
                </a>
            </li>
            <li class="cor-submenu-item">
                <a href="#" class="cor-submenu-link">
                    <i class="bi bi-exclamation-triangle"></i>
                    OcorrAªncias
                </a>
            </li>
        </ul>
    </li>

    </ul>
    </nav>

    <!-- CONTEAšDO PRINCIPAL -->
    <div class="dashboard-container">

        <!-- Header Padronizado -->
        <div class="dashboard-header">
            <div class="header-top">
                <div class="header-title">
                    <div class="header-icon">
                        <i class="bi bi-car-front-fill"></i>
                    </div>
                    <div>
                        <h1>Mobilidade Urbana</h1>
                        <p style="margin:0;color:#94a3b8;font-size:14px;">Sistema de transporte e transito em tempo real
                        </p>
                    </div>
                </div>
                <div class="header-actions">
                    <button class="header-btn" onclick="window.location.reload()">
                        <i class="bi bi-arrow-clockwise"></i>
                        Atualizar
                    </button>
                    <button class="header-btn" style="font-size: 12px; padding: 6px 12px;" onclick="toggleWazeLayer()">
                        <i class="bi bi-exclamation-triangle-fill"></i>
                        <span id="waze-toggle-text">Waze Alerts</span>
                    </button>
                    <button class="header-btn">
                        <i class="bi bi-download"></i>
                        Exportar
                    </button>
                </div>
            </div>

            <div class="header-stats">
                <div class="header-stat">
                    <div class="header-stat-value" id="brt-total">4</div>
                    <div class="header-stat-label">Linhas BRT</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-value" id="metro-total">3</div>
                    <div class="header-stat-label">Linhas MetrA´</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-value" id="bike-total">42</div>
                    <div class="header-stat-label">Bikes Disponiveis</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-value" id="transito-Nível">Normal</div>
                    <div class="header-stat-label">Status transito</div>
                </div>
            </div>
        </div>

        <!-- Mapa de Mobilidade -->
        <div class="mob-section" style="padding: 0; overflow: hidden;">
            <div style="padding: 24px 24px 16px 24px;">
                <div class="mob-section-title">
                    <i class="bi bi-map-fill"></i>
                    Mapa de Mobilidade
                    <div style="margin-left: auto; display: flex; gap: 12px;">
                        <button class="header-btn" style="font-size: 12px; padding: 6px 12px;"
                            onclick="toggleKMLLayer()">
                            <i class="bi bi-bezier2"></i>
                            <span id="kml-toggle-text">Mostrar Rotas</span>
                        </button>
                        <button class="header-btn" style="font-size: 12px; padding: 6px 12px;" onclick="fitMapBounds()">
                            <i class="bi bi-arrows-fullscreen"></i>
                            Centralizar
                        </button>
                    </div>
                </div>
            </div>
            <div id="mobilidade-map" style="height: 500px; width: 100%; position: relative;">
                <!-- Botao de controle flutuante -->
                <button class="map-control-btn" id="map-control-btn" onclick="toggleControlPanel()"
                    title="Controle de Rotas">
                    <i class="bi bi-layers-fill"></i>
                    <div class="badge" id="rotas-badge">0</div>
                </button>

                <!-- … ADICIONE ISTO: -->
                <!-- Indicador de modo de desenho -->
                <div class="desenho-mode-indicator" id="desenho-indicator">
                    <i class="bi bi-pencil-fill"></i>
                    <span>Clique em pontos-chave - A rota seguira as ruas automaticamente</span>
                </div>

                <!-- Controles de desenho -->
                <div class="desenho-controls" id="desenho-controls">
                    <button class="desenho-btn" onclick="finalizarDesenho()">
                        <i class="bi bi-check-circle-fill"></i>
                        Finalizar Rota
                    </button>
                    <button class="desenho-btn" onclick="desfazerPonto()">
                        <i class="bi bi-arrow-counterclockwise"></i>
                        Desfazer
                    </button>
                    <button class="desenho-btn cancel" onclick="cancelarDesenho()">
                        <i class="bi bi-x-circle-fill"></i>
                        Cancelar
                    </button>
                </div>

            </div>
        </div>

        <!-- Status do transito -->
        <div class="mob-section">
            <div class="mob-section-title">
                <i class="bi bi-traffic-cone-fill"></i>
                Status do transito
            </div>
            <div id="transito-container">
                <div class="loading">
                    <i class="bi bi-hourglass-split"></i>
                    <p>Carregando status...</p>
                </div>
            </div>
        </div>

        <!-- Status das Vias com Waze -->
        <div class="mob-section">
            <div class="mob-section-title">
                <i class="bi bi-route"></i>
                Status das Vias em Tempo Real
                <div style="margin-left: auto; display: flex; gap: 8px; align-items: center;">
                    <span id="ultima-atualizacao-vias"
                        style="font-size: 11px; color: #64748b; font-weight: 400;"></span>
                    <button class="header-btn" style="font-size: 12px; padding: 6px 12px;"
                        onclick="atualizarStatusVias()">
                        <i class="bi bi-arrow-clockwise"></i>
                        Atualizar
                    </button>
                </div>
            </div>

            <!-- Barra de Pesquisa e Filtros -->
            <div style="margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: 1fr auto; gap: 12px; margin-bottom: 12px;">
                    <!-- Barra de Pesquisa -->
                    <div style="position: relative;">
                        <input type="text" id="pesquisa-vias" placeholder="🔍 Pesquisar vias por nome..." style="
                    width: 100%;
                    padding: 14px 48px 14px 20px;
                    background: rgba(255, 255, 255, 0.05);
                    border: 2px solid rgba(255, 255, 255, 0.1);
                    border-radius: 12px;
                    color: #f8fafc;
                    font-size: 15px;
                    transition: all 0.3s;
                " oninput="aplicarFiltrosVias()"
                            onfocus="this.style.borderColor='#3b82f6'; this.style.background='rgba(59, 130, 246, 0.1)';"
                            onblur="this.style.borderColor='rgba(255, 255, 255, 0.1)'; this.style.background='rgba(255, 255, 255, 0.05)';">
                        <i class="bi bi-search" style="
                position: absolute;
                right: 20px;
                top: 50%;
                transform: translateY(-50%);
                color: #64748b;
                font-size: 18px;
                pointer-events: none;
            "></i>
                    </div>

                    <!-- Botão Filtros -->
                    <button id="btn-toggle-filtros" onclick="toggleFiltrosVias()" style="
                padding: 14px 24px;
                background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
                border: none;
                border-radius: 12px;
                color: white;
                font-weight: 700;
                font-size: 14px;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 8px;
                white-space: nowrap;
                transition: all 0.3s;
                box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(59, 130, 246, 0.4)';"
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(59, 130, 246, 0.3)';">
                        <i class="bi bi-funnel-fill"></i>
                        <span>Filtros</span>
                        <span id="filtros-ativos-badge" style="
                display: none;
                background: rgba(255, 255, 255, 0.3);
                padding: 2px 8px;
                border-radius: 10px;
                font-size: 12px;
                font-weight: 700;
            ">0</span>
                    </button>
                </div>

                <!-- Painel de Filtros (Oculto por padrão) -->
                <div id="painel-filtros-vias" style="
                 display: none;
                background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 16px;
                animation: slideDown 0.3s ease;
                ">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
                        <!-- Filtro por Status -->
                        <div>
                            <label
                                style="display: block; color: #94a3b8; font-size: 12px; font-weight: 700; text-transform: uppercase; margin-bottom: 8px;">
                                <i class="bi bi-traffic-cone-fill"></i> Status
                            </label>
                            <select id="filtro-status" onchange="aplicarFiltrosVias()" style="
                    width: 100%;
                    padding: 10px 12px;
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 8px;
                    color: #f8fafc;
                    font-size: 14px;
                    cursor: pointer;
                ">
                                <option value="">Todos</option>
                                <option value="critico">🔴 Crítico</option>
                                <option value="intenso">🟠 Intenso</option>
                                <option value="moderado">🟡 Moderado</option>
                                <option value="normal">🟢 Normal</option>
                            </select>
                        </div>

                        <!-- Filtro por Hierarquia -->
                        <div>
                            <label
                                style="display: block; color: #94a3b8; font-size: 12px; font-weight: 700; text-transform: uppercase; margin-bottom: 8px;">
                                <i class="bi bi-diagram-3-fill"></i> Hierarquia
                            </label>
                            <select id="filtro-hierarquia" onchange="aplicarFiltrosVias()" style="
                    width: 100%;
                    padding: 10px 12px;
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 8px;
                    color: #f8fafc;
                    font-size: 14px;
                    cursor: pointer;
                ">
                                <option value="">Todas</option>
                                <option value="estrutural">Estrutural</option>
                                <option value="arterial primária">Arterial Primária</option>
                                <option value="arterial secundária">Arterial Secundária</option>
                            </select>
                        </div>

                        <!-- Filtro por Alertas -->
                        <div>
                            <label
                                style="display: block; color: #94a3b8; font-size: 12px; font-weight: 700; text-transform: uppercase; margin-bottom: 8px;">
                                <i class="bi bi-exclamation-triangle-fill"></i> Alertas
                            </label>
                            <select id="filtro-alertas" onchange="aplicarFiltrosVias()" style="
                    width: 100%;
                    padding: 10px 12px;
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 8px;
                    color: #f8fafc;
                    font-size: 14px;
                    cursor: pointer;
                ">
                                <option value="">Todas</option>
                                <option value="com">Com alertas</option>
                                <option value="sem">Sem alertas</option>
                            </select>
                        </div>

                        <!-- Ordenar por -->
                        <div>
                            <label
                                style="display: block; color: #94a3b8; font-size: 12px; font-weight: 700; text-transform: uppercase; margin-bottom: 8px;">
                                <i class="bi bi-sort-down"></i> Ordenar por
                            </label>
                            <select id="filtro-ordenar" onchange="aplicarFiltrosVias()" style="
                    width: 100%;
                    padding: 10px 12px;
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 8px;
                    color: #f8fafc;
                    font-size: 14px;
                    cursor: pointer;
                ">
                                <option value="criticidade">Criticidade</option>
                                <option value="nome">Nome (A-Z)</option>
                                <option value="distancia">Distância</option>
                                <option value="alertas">Mais alertas</option>
                            </select>
                        </div>
                    </div>

                    <!-- Botão Limpar Filtros -->
                    <button onclick="limparFiltrosVias()" style="
                        margin-top: 16px;
                        padding: 10px 20px;
                        background: rgba(239, 68, 68, 0.1);
                        border: 1px solid rgba(239, 68, 68, 0.3);
                        border-radius: 8px;
                        color: #ef4444;
                        font-weight: 600;
                        font-size: 14px;
                        cursor: pointer;
                        display: flex;
                         align-items: center;
                        gap: 8px;
                        transition: all 0.2s;
                        " onmouseover="this.style.background='rgba(239, 68, 68, 0.2)';"
                        onmouseout="this.style.background='rgba(239, 68, 68, 0.1)';">
                        <i class="bi bi-x-circle"></i>
                        Limpar Filtros
                    </button>
                </div>

                <!-- Resultado da Pesquisa/Filtro -->
                <div id="resultado-pesquisa" style="
                margin-top: 8px;
                font-size: 13px;
                color: #94a3b8;
                display: none;
                "></div>
            </div>

            <style>
                @keyframes slideDown {
                    from {
                        opacity: 0;
                        transform: translateY(-10px);
                    }

                    to {
                        opacity: 1;
                        transform: translateY(0);
                    }
                }
            </style>

            <div id="status-vias-container">
                <div class="loading">
                    <i class="bi bi-hourglass-split"></i>
                    <p>Carregando status das vias...</p>
                </div>
            </div>
        </div>

        <!-- BRT -->
        <div class="mob-section">
            <div class="mob-section-title">
                <i class="bi bi-bus-front-fill"></i>
                Linhas de BRT
            </div>
            <div class="cards-grid" id="brt-container">
                <div class="loading">
                    <i class="bi bi-hourglass-split"></i>
                    <p>Carregando linhas...</p>
                </div>
            </div>
        </div>

        <!-- MetrA´ -->
        <div class="mob-section">
            <div class="mob-section-title">
                <i class="bi bi-train-front-fill"></i>
                Linhas de MetrA
            </div>
            <div class="cards-grid" id="metro-container">
                <div class="loading">
                    <i class="bi bi-hourglass-split"></i>
                    <p>Carregando linhas...</p>
                </div>
            </div>
        </div>

        <!-- Bike Rio -->
        <div class="mob-section">
            <div class="mob-section-title">
                <i class="bi bi-bicycle"></i>
                Bike Rio - Estações
            </div>
            <div class="cards-grid" id="bike-container">
                <div class="loading">
                    <i class="bi bi-hourglass-split"></i>
                    <p>Carregando estações...</p>
                </div>
            </div>
        </div>

    </div>

    <!-- Painel de Controle de Rotas -->
    <div class="rotas-control-panel" id="rotas-control-panel">
        <div class="rotas-panel-header" onclick="toggleControlPanel()">
            <div class="rotas-panel-title">
                <i class="bi bi-layers-fill"></i>
                Controle de Rotas
            </div>
            <button class="rotas-panel-toggle" id="panel-toggle-btn">
                <i class="bi bi-chevron-left"></i>
            </button>
        </div>

        <!-- Alertas do Waze -->
        <div class="rotas-section">
            <div class="rotas-section-title">
                <i class="bi bi-exclamation-triangle-fill" style="color: #f59e0b;"></i>
                Alertas Waze
            </div>

            <div class="rotas-stats" style="grid-template-columns: repeat(2, 1fr);">
                <div class="rotas-stat-item">
                    <div class="rotas-stat-value" style="color: #ef4444;" id="waze-acidentes">0</div>
                    <div class="rotas-stat-label">Acidentes</div>
                </div>
                <div class="rotas-stat-item">
                    <div class="rotas-stat-value" style="color: #f59e0b;" id="waze-jams">0</div>
                    <div class="rotas-stat-label">Congestionamentos</div>
                </div>
            </div>

            <button class="rotas-action-btn" onclick="toggleWazeLayer()" style="margin-top: 12px;">
                <i class="bi bi-exclamation-triangle-fill"></i>
                <span id="waze-panel-text">Mostrar Alertas</span>
            </button>
        </div>

        <!-- Modal de Rotas Alternativas Automáticas -->
        <div class="rota-modal" id="modal-rotas-alternativas" style="display: none;">
            <div class="rota-modal-content" style="max-width: 1400px; max-height: 95vh; width: 95%;">
                <div class="rota-modal-header" style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);">
                    <div class="rota-modal-title">
                        <i class="bi bi-signpost-split-fill"></i>
                        <span id="modal-rotas-titulo">Rotas Alternativas Inteligentes</span>
                    </div>
                    <button class="rota-modal-close" onclick="fecharModalRotas()">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>

                <div class="rota-modal-body" style="padding: 0; display: flex; height: calc(95vh - 200px);">
                    <!-- Mapa à esquerda (50%) -->
                    <div style="flex: 1; position: relative; border-right: 2px solid rgba(255,255,255,0.1);">
                        <div id="modal-mapa-rotas" style="height: 100%; width: 100%;"></div>

                        <!-- Info overlay no mapa -->
                        <div
                            style="position: absolute; top: 20px; left: 20px; background: rgba(15, 23, 42, 0.95); padding: 16px; border-radius: 12px; border: 1px solid rgba(59, 130, 246, 0.3); max-width: 300px;">
                            <div
                                style="font-size: 13px; color: #94a3b8; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">
                                <i class="bi bi-info-circle-fill"></i> Via Analisada
                            </div>
                            <div id="modal-via-nome" style="font-size: 16px; font-weight: 700; color: #f8fafc;"></div>
                        </div>
                    </div>

                    <!-- Cards à direita (50%) -->
                    <div
                        style="flex: 1; overflow-y: auto; padding: 24px; background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);">
                        <div id="modal-rotas-cards" style="display: flex; flex-direction: column; gap: 20px;">
                            <!-- Cards serão inseridos aqui -->
                        </div>
                    </div>
                </div>

                <div class="rota-modal-footer" style="border-top: 1px solid rgba(255,255,255,0.1); padding: 20px 24px;">
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <div style="color: #94a3b8; font-size: 13px;">
                            <i class="bi bi-lightbulb-fill" style="color: #f59e0b;"></i>
                            Clique em uma rota para visualizá-la no mapa principal
                        </div>
                        <button class="rota-modal-btn rota-modal-btn-secondary" onclick="fecharModalRotas()">
                            <i class="bi bi-x-circle"></i>
                            Fechar
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="rotas-panel-body">

            <!-- Estatísticas -->
            <div class="rotas-section">
                <div class="rotas-section-title">
                    <i class="bi bi-graph-up"></i>
                    Estatísticas
                </div>
                <div class="rotas-stats">
                    <div class="rotas-stat-item">
                        <div class="rotas-stat-value" id="total-rotas">0</div>
                        <div class="rotas-stat-label">Total de Rotas</div>
                    </div>
                    <div class="rotas-stat-item">
                        <div class="rotas-stat-value" id="rotas-visiveis">0</div>
                        <div class="rotas-stat-label">Visiveis</div>
                    </div>
                </div>
            </div>

            <!-- Filtros por Hierarquia -->
            <div class="rotas-section">
                <div class="rotas-section-title">
                    <i class="bi bi-funnel-fill"></i>
                    Filtrar por Hierarquia
                </div>

                <div class="rotas-filter" onclick="toggleHierarquia('Estrutural')">
                    <div class="rotas-filter-info">
                        <div class="rotas-filter-color" style="background: #ef4444;"></div>
                        <div>
                            <div class="rotas-filter-text">Estrutural</div>
                            <div class="rotas-filter-count" id="count-estrutural">0 rotas</div>
                        </div>
                    </div>
                    <div class="rotas-toggle-switch active" id="toggle-estrutural">
                        <div class="rotas-toggle-slider"></div>
                    </div>
                </div>

                <div class="rotas-filter" onclick="toggleHierarquia('Arterial primária')">
                    <div class="rotas-filter-info">
                        <div class="rotas-filter-color" style="background: #f59e0b;"></div>
                        <div>
                            <div class="rotas-filter-text">Arterial primária</div>
                            <div class="rotas-filter-count" id="count-arterial-primária">0 rotas</div>
                        </div>
                    </div>
                    <div class="rotas-toggle-switch active" id="toggle-arterial-primária">
                        <div class="rotas-toggle-slider"></div>
                    </div>
                </div>

                <div class="rotas-filter" onclick="toggleHierarquia('Arterial secundária')">
                    <div class="rotas-filter-info">
                        <div class="rotas-filter-color" style="background: #10b981;"></div>
                        <div>
                            <div class="rotas-filter-text">Arterial secundária</div>
                            <div class="rotas-filter-count" id="count-arterial-secundária">0 rotas</div>
                        </div>
                    </div>
                    <div class="rotas-toggle-switch active" id="toggle-arterial-secundária">
                        <div class="rotas-toggle-slider"></div>
                    </div>
                </div>
            </div>

            <!-- AcAµes Rapidas -->
            <div class="rotas-section">
                <div class="rotas-section-title">
                    <i class="bi bi-lightning-fill"></i>
                    AcAµes Rapidas
                </div>

                <!-- … ADICIONE ESTE BOTAƒO NOVO -->
                <button class="rotas-action-btn" onclick="iniciarDesenhoRota()"
                    style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); border-color: #10b981;">
                    <i class="bi bi-plus-circle-fill"></i>
                    Adicionar Nova Rota
                </button>

                <button class="rotas-action-btn" onclick="mostrarTodasRotas()">
                    <i class="bi bi-eye-fill"></i>
                    Mostrar Todas
                </button>

                <button class="rotas-action-btn" onclick="ocultarTodasRotas()">
                    <i class="bi bi-eye-slash-fill"></i>
                    Ocultar Todas
                </button>

                <button class="rotas-action-btn" onclick="resetarCores()">
                    <i class="bi bi-palette-fill"></i>
                    Aplicar Cores
                </button>

                <button class="rotas-action-btn" onclick="centralizarTodasRotas()">
                    <i class="bi bi-bullseye"></i>
                    Centralizar Mapa
                </button>

                <!-- … NOVOS BOTA•ES DE GERENCIAMENTO -->
                <button class="rotas-action-btn" onclick="exportarRotas()"
                    style="background: rgba(59, 130, 246, 0.2); border-color: #3b82f6;">
                    <i class="bi bi-download"></i>
                    Exportar Rotas
                </button>

                <button class="rotas-action-btn" onclick="limparRotasSalvas()"
                    style="background: rgba(239, 68, 68, 0.2); border-color: #ef4444;">
                    <i class="bi bi-trash-fill"></i>
                    Limpar Todas
                </button>
            </div>

            <!-- Legenda -->
            <div class="rotas-section">
                <div class="rotas-section-title">
                    <i class="bi bi-info-circle-fill"></i>
                    Legenda
                </div>
                <div class="rotas-legend">
                    <div class="rotas-legend-item">
                        <div class="rotas-legend-line" style="background: #ef4444;"></div>
                        <div class="rotas-legend-label">Estrutural</div>
                        <div class="rotas-legend-count" id="legend-estrutural">0</div>
                    </div>
                    <div class="rotas-legend-item">
                        <div class="rotas-legend-line" style="background: #f59e0b;"></div>
                        <div class="rotas-legend-label">Arterial primária</div>
                        <div class="rotas-legend-count" id="legend-arterial-primária">0</div>
                    </div>
                    <div class="rotas-legend-item">
                        <div class="rotas-legend-line" style="background: #10b981;"></div>
                        <div class="rotas-legend-label">Arterial secundária</div>
                        <div class="rotas-legend-count" id="legend-arterial-secundária">0</div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <!-- Modal de InformacAµes da Rota -->
    <div class="rota-modal" id="rota-modal">
        <div class="rota-modal-content">
            <div class="rota-modal-header">
                <div class="rota-modal-title">
                    <i class="bi bi-bezier2"></i>
                    <span id="rota-modal-title">InformacAµes da Rota</span>
                </div>
                <button class="rota-modal-close" onclick="closeRotaModal()">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>

            <div class="rota-modal-body">
                <div class="rota-info-grid" id="rota-modal-body">
                    <!-- Conteudo sera inserido dinamicamente -->
                </div>
            </div>

            <div class="rota-modal-footer">
                <button class="rota-modal-btn rota-modal-btn-secondary" onclick="closeRotaModal()">
                    <i class="bi bi-x-circle"></i>
                    Fechar
                </button>
                <button class="rota-modal-btn rota-modal-btn-primary" onclick="centerRotaOnMap()">
                    <i class="bi bi-crosshair"></i>
                    Centralizar no Mapa
                </button>
            </div>
        </div>
    </div>
    <!-- Modal de Detalhes do Alerta Waze -->
    <div class="rota-modal" id="waze-modal">
        <div class="rota-modal-content">
            <div class="rota-modal-header" style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);">
                <div class="rota-modal-title">
                    <i class="bi bi-exclamation-triangle-fill"></i>
                    <span id="waze-modal-title">Alerta Waze</span>
                </div>
                <button class="rota-modal-close" onclick="closeWazeModal()">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>

            <div class="rota-modal-body">
                <div class="rota-info-grid" id="waze-modal-body">
                    <!-- Conteudo sera inserido dinamicamente -->
                </div>
            </div>

            <div class="rota-modal-footer">
                <button class="rota-modal-btn rota-modal-btn-secondary" onclick="closeWazeModal()">
                    <i class="bi bi-x-circle"></i>
                    Fechar
                </button>
                <button class="rota-modal-btn rota-modal-btn-primary"
                    style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);" onclick="centerWazeOnMap()">
                    <i class="bi bi-crosshair"></i>
                    Centralizar no Mapa
                </button>
            </div>
        </div>
    </div>

    <!-- Modal de Detalhes do Alerta Waze -->
    <div class="rota-modal" id="waze-modal">
        <div class="rota-modal-content">
            <div class="rota-modal-header" style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);">
                <div class="rota-modal-title">
                    <i class="bi bi-exclamation-triangle-fill"></i>
                    <span id="waze-modal-title">Alerta Waze</span>
                </div>
                <button class="rota-modal-close" onclick="closeWazeModal()">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>

            <div class="rota-modal-body">
                <div class="rota-info-grid" id="waze-modal-body">
                    <!-- Conteudo sera inserido dinamicamente -->
                </div>
            </div>

            <div class="rota-modal-footer">
                <button class="rota-modal-btn rota-modal-btn-secondary" onclick="closeWazeModal()">
                    <i class="bi bi-x-circle"></i>
                    Fechar
                </button>
                <button class="rota-modal-btn rota-modal-btn-primary"
                    style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);" onclick="centerWazeOnMap()">
                    <i class="bi bi-crosshair"></i>
                    Centralizar no Mapa
                </button>
            </div>
        </div>
    </div>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>

    <!-- Leaflet Omnivore (para KML) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-omnivore/0.3.4/leaflet-omnivore.min.js"></script>

    <script>
        // ===== INICIALIZAR MAPA =====
        let mobilidadeMap;
        let kmlLayer;
        let kmlVisible = false;
        let selectedRotaLayer = null;
        let selectedWazeMarker = null;

        // … ADICIONE ESTAS VARIAVEIS:
        // Sistema de desenho de rotas
        let desenhoModeAtivo = false;
        let pontosDesenho = [];
        let pontosChave = [];
        let modoInterativo = false;
        let linhaTemporaria = null;
        let marcadoresTemporarios = [];


        // ===== ROTAS ALTERNATIVAS INTELIGENTES =====

        let pontoOrigem = null;
        let pontoDestino = null;
        let marcadorOrigem = null;
        let marcadorDestino = null;
        let rotasCalculadas = [];
        let polylineRotas = [];
        let modoSelecao = null; // 'origem' ou 'destino'
        let modalRotasMap = null;

        function fecharModalRotas() {
            const modal = document.getElementById('modal-rotas-alternativas');
            if (modal) {
                modal.style.display = 'none';
            }

            // RESTAURAR PAINEL DE CONTROLE
            const painel = document.getElementById('rotas-control-panel');
            if (painel) {
                painel.classList.remove('minimized');
                painel.style.display = 'block';
                painel.style.visibility = 'visible';
            }

            const btn = document.getElementById('map-control-btn');
            if (btn) {
                btn.classList.add('visible');
            }

            // Limpar rotas do mapa modal
            if (modalRotasMap) {
                modalRotasMap.eachLayer(layer => {
                    if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                        modalRotasMap.removeLayer(layer);
                    } W
                });
            }
        }

        async function calcularRotasOSRM(inicio, fim) {
            const url = `https://router.project-osrm.org/route/v1/driving/${inicio.lng},${inicio.lat};${fim.lng},${fim.lat}?alternatives=2&overview=full&geometries=geojson`;

            const response = await fetch(url);
            const data = await response.json();

            if (data.code !== 'Ok') {
                throw new Error('Erro ao calcular rotas');
            }

            return data.routes.map(route => ({
                coordinates: route.geometry.coordinates.map(c => [c[1], c[0]]),
                distancia: (route.distance / 1000).toFixed(2),
                tempo: Math.round(route.duration / 60)
            }));
        }

        function contarAlertasNaRota(coordinates) {
            let acidentes = 0, congestionamentos = 0, outros = 0;

            if (wazeMarkers && wazeMarkers.length > 0) {
                wazeMarkers.forEach(marker => {
                    if (!marker || !marker.wazeData) return;

                    const markerPos = marker.getLatLng();
                    let menorDist = Infinity;

                    coordinates.forEach(coord => {
                        const dist = mobilidadeMap.distance(markerPos, L.latLng(coord));
                        if (dist < menorDist) menorDist = dist;
                    });

                    if (menorDist <= 200) {
                        const tipo = marker.wazeData.tipo || '';
                        if (tipo.includes('Acidente')) acidentes++;
                        else if (tipo.includes('Congestionamento')) congestionamentos++;
                        else outros++;
                    }
                });
            }

            return { acidentes, congestionamentos, outros, total: acidentes + congestionamentos + outros };
        }

        function renderizarCardsRotas(rotas) {
            const container = document.getElementById('modal-rotas-cards');

            container.innerHTML = rotas.map(rota => `
        <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border: 2px solid ${rota.cor}; border-radius: 12px; padding: 20px; transition: transform 0.3s;" onmouseover="this.style.transform='translateY(-4px)'" onmouseout="this.style.transform='translateY(0)'">
            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                <div style="width: 40px; height: 40px; background: ${rota.cor}; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: 700; color: white;">
                    ${rota.index}
                </div>
                <div>
                    <div style="font-size: 18px; font-weight: 700; color: #f8fafc;">${rota.nome}</div>
                    <div style="font-size: 13px; color: #64748b;">Via alternativa</div>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 24px; font-weight: 700; color: ${rota.cor};">${rota.tempo}</div>
                    <div style="font-size: 12px; color: #94a3b8;">minutos</div>
                </div>
                <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 24px; font-weight: 700; color: ${rota.cor};">${rota.distancia}</div>
                    <div style="font-size: 12px; color: #94a3b8;">km</div>
                </div>
            </div>
            
            <div style="padding: 12px; background: rgba(255,255,255,0.03); border-radius: 8px;">
                <div style="font-size: 12px; color: #94a3b8; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">Alertas na Rota</div>
                <div style="display: flex; gap: 16px; flex-wrap: wrap;">
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <i class="bi bi-car-front-fill" style="color: #ef4444;"></i>
                        <span style="color: #f8fafc; font-weight: 600;">${rota.alertas.acidentes}</span>
                    </span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <i class="bi bi-truck-front" style="color: #f59e0b;"></i>
                        <span style="color: #f8fafc; font-weight: 600;">${rota.alertas.congestionamentos}</span>
                    </span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <i class="bi bi-exclamation-triangle-fill" style="color: #64748b;"></i>
                        <span style="color: #f8fafc; font-weight: 600;">${rota.alertas.outros}</span>
                    </span>
                </div>
            </div>
        </div>
    `).join('');
        }

        async function calcularRotasOSRM(inicio, fim) {
            // Usar OSRM para calcular 3 rotas alternativas
            const url = `https://router.project-osrm.org/route/v1/driving/${inicio.lng},${inicio.lat};${fim.lng},${fim.lat}?alternatives=2&overview=full&geometries=geojson`;

            const response = await fetch(url);
            const data = await response.json();

            if (data.code !== 'Ok') {
                throw new Error('Erro ao calcular rotas');
            }

            return data.routes.map(route => ({
                coordinates: route.geometry.coordinates.map(c => [c[1], c[0]]),
                distancia: (route.distance / 1000).toFixed(2),
                tempo: Math.round(route.duration / 60)
            }));
        }

        function contarAlertasNaRota(coordinates) {
            let acidentes = 0, congestionamentos = 0, outros = 0;

            wazeMarkers.forEach(marker => {
                if (!marker || !marker.wazeData) return;

                const markerPos = marker.getLatLng();
                let menorDist = Infinity;

                coordinates.forEach(coord => {
                    const dist = mobilidadeMap.distance(markerPos, L.latLng(coord));
                    if (dist < menorDist) menorDist = dist;
                });

                if (menorDist <= 200) {
                    const tipo = marker.wazeData.tipo || '';
                    if (tipo.includes('Acidente')) acidentes++;
                    else if (tipo.includes('Congestionamento')) congestionamentos++;
                    else outros++;
                }
            });

            return { acidentes, congestionamentos, outros, total: acidentes + congestionamentos + outros };
        }

        function renderizarCardsRotas(rotas) {
            const container = document.getElementById('modal-rotas-cards');
            if (!container) {
                console.error('❌ Container de cards não encontrado');
                return;
            }

            let html = '';

            rotas.forEach((rota, index) => {
                const icone = index === 0 ? 'rocket-takeoff' : (index === 1 ? 'speedometer2' : 'shuffle');

                html += `
            <div class="rota-card" 
                 data-index="${index}"
                 onmouseover="destacarRota(${index})" 
                 onmouseout="restaurarRotas()"
                 onclick="centralizarRota(${index})"
                 style="
                     background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
                     border-left: 4px solid ${rota.cor};
                     border-radius: 12px;
                     padding: 20px;
                     margin-bottom: 16px;
                     cursor: pointer;
                     transition: all 0.3s ease;
                 ">
                
                <!-- Cabeçalho -->
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                    <div style="
                        width: 48px;
                        height: 48px;
                        background: ${rota.cor}20;
                        border-radius: 12px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">
                        <i class="bi bi-${icone}" style="font-size: 24px; color: ${rota.cor};"></i>
                    </div>
                    <div style="flex: 1;">
                        <h3 style="margin: 0; color: #f1f5f9; font-size: 18px; font-weight: 600;">
                            ${rota.nome}
                        </h3>
                        <p style="margin: 4px 0 0 0; color: #94a3b8; font-size: 14px;">
                            ${rota.vias ? rota.vias.slice(0, 2).join(' • ') : 'Via principal'}
                        </p>
                    </div>
                </div>
                
                <!-- Métricas -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 16px;">
                    <div style="text-align: center; padding: 12px; background: #0f172a; border-radius: 8px;">
                        <div style="color: #64748b; font-size: 12px; margin-bottom: 4px;">Distância</div>
                        <div style="color: #f1f5f9; font-size: 20px; font-weight: 700;">
                            ${rota.distancia}
                            <span style="font-size: 14px; color: #94a3b8;">km</span>
                        </div>
                    </div>
                    <div style="text-align: center; padding: 12px; background: #0f172a; border-radius: 8px;">
                        <div style="color: #64748b; font-size: 12px; margin-bottom: 4px;">Tempo</div>
                        <div style="color: #f1f5f9; font-size: 20px; font-weight: 700;">
                            ${rota.tempo}
                            <span style="font-size: 14px; color: #94a3b8;">min</span>
                        </div>
                    </div>
                    <div style="text-align: center; padding: 12px; background: #0f172a; border-radius: 8px;">
                        <div style="color: #64748b; font-size: 12px; margin-bottom: 4px;">Alertas</div>
                        <div style="color: ${rota.alertas?.total > 5 ? '#ef4444' : '#10b981'}; font-size: 20px; font-weight: 700;">
                            ${rota.alertas?.total || 0}
                        </div>
                    </div>
                </div>
                
                <!-- Detalhes dos Alertas -->
                ${rota.alertas?.total > 0 ? `
                    <div style="display: flex; gap: 12px; padding: 12px; background: #0f172a; border-radius: 8px; font-size: 13px;">
                        ${rota.alertas.acidentes > 0 ? `
                            <span style="color: #ef4444;">
                                <i class="bi bi-exclamation-triangle-fill"></i> ${rota.alertas.acidentes} acidentes
                            </span>
                        ` : ''}
                        ${rota.alertas.congestionamentos > 0 ? `
                            <span style="color: #f59e0b;">
                                <i class="bi bi-hourglass-split"></i> ${rota.alertas.congestionamentos} congestionamentos
                            </span>
                        ` : ''}
                        ${rota.alertas.outros > 0 ? `
                            <span style="color: #64748b;">
                                <i class="bi bi-info-circle"></i> ${rota.alertas.outros} outros
                            </span>
                        ` : ''}
                    </div>
                ` : `
                    <div style="padding: 12px; background: #0f172a; border-radius: 8px; text-align: center; color: #10b981;">
                        <i class="bi bi-check-circle-fill"></i> Via livre
                    </div>
                `}
                
                <!-- Dica de interação -->
                <div style="margin-top: 12px; text-align: center; color: #64748b; font-size: 12px;">
                    <i class="bi bi-hand-index"></i> Passe o mouse para destacar no mapa
                </div>
            </div>
        `;
            });

            container.innerHTML = html;
            console.log('✅ Cards renderizados com hover interativo!');
        }

        // ===== DESTACAR ROTA NO MAPA =====
        function destacarRota(index) {
            if (!window.modalPolylines || !window.modalPolylines[index]) return;

            console.log(`👆 Destacando rota ${index}...`);

            // Deixar todas as outras mais fracas
            window.modalPolylines.forEach((polyline, i) => {
                if (i === index) {
                    // Rota destacada
                    polyline.setStyle({
                        weight: 8,
                        opacity: 1,
                        color: polyline.options.color,
                        dashArray: null
                    });
                    polyline.bringToFront();
                } else {
                    // Outras rotas ficam fracas
                    polyline.setStyle({
                        weight: 3,
                        opacity: 0.3,
                        dashArray: '10, 5'
                    });
                }
            });

            // Animar o card
            const card = document.querySelector(`[data-index="${index}"]`);
            if (card) {
                card.style.transform = 'translateX(8px)';
                card.style.boxShadow = `0 8px 32px ${window.rotasCalculadas[index]?.cor}40`;
            }
        }

        // ===== RESTAURAR TODAS AS ROTAS =====
        function restaurarRotas() {
            if (!window.modalPolylines) return;

            console.log('👋 Restaurando rotas...');

            window.modalPolylines.forEach((polyline, i) => {
                polyline.setStyle({
                    weight: i === 0 ? 6 : 5,
                    opacity: i === 0 ? 0.9 : 0.7,
                    dashArray: i === 0 ? null : '10, 5'
                });
            });

            // Remover animação dos cards
            document.querySelectorAll('.rota-card').forEach(card => {
                card.style.transform = 'translateX(0)';
                card.style.boxShadow = 'none';
            });
        }

        // ===== CENTRALIZAR ROTA NO MAPA =====
        function centralizarRota(index) {
            if (!window.modalPolylines || !window.modalPolylines[index]) return;

            console.log(`🎯 Centralizando rota ${index}...`);

            const polyline = window.modalPolylines[index];
            const bounds = polyline.getBounds();

            window.modalMapa.fitBounds(bounds, {
                padding: [50, 50],
                animate: true,
                duration: 0.5
            });

            // Feedback visual
            const card = document.querySelector(`[data-index="${index}"]`);
            if (card) {
                card.style.animation = 'pulse 0.3s ease';
                setTimeout(() => {
                    card.style.animation = '';
                }, 300);
            }
        }

        // ===== FUNÇÕES DE INTERAÇÃO COM AS ROTAS =====

        function highlightRota(index) {
            // Destacar a rota no mapa
            if (polylineRotas[index]) {
                polylineRotas[index].setStyle({
                    weight: 8,
                    opacity: 1
                });
                polylineRotas[index].bringToFront();
            }

            // Destacar o card
            const card = document.querySelector(`[data-rota-index="${index}"]`);
            if (card) {
                card.style.transform = 'scale(1.02)';
                card.style.boxShadow = '0 8px 32px rgba(59, 130, 246, 0.4)';
            }
        }

        function unhighlightRota(index) {
            // Restaurar estilo da rota
            if (polylineRotas[index] && rotasCalculadas[index]) {
                polylineRotas[index].setStyle({
                    weight: 5,
                    opacity: 0.8
                });
            }

            // Restaurar o card
            const card = document.querySelector(`[data-rota-index="${index}"]`);
            if (card) {
                card.style.transform = 'scale(1)';
                card.style.boxShadow = 'none';
            }
        }

        function selecionarRota(index) {
            const rota = rotasCalculadas[index];
            if (!rota) {
                alert('⚠️ Rota não encontrada!');
                return;
            }

            // VERIFICAR SE TEM COORDENADAS
            if (!rota.coordenadas || rota.coordenadas.length === 0) {
                console.error('❌ Rota sem coordenadas:', rota);
                alert('⚠️ Esta rota não possui coordenadas válidas!');
                return;
            }

            console.log(`✅ Rota selecionada: ${rota.nome}`, rota);

            // Fechar modal
            fecharModalRotas();

            // Desenhar a rota no mapa principal
            setTimeout(() => {
                try {
                    // Limpar rotas anteriores do mapa principal
                    mobilidadeMap.eachLayer(layer => {
                        if (layer._rotaUsuario) {
                            mobilidadeMap.removeLayer(layer);
                        }
                    });

                    // Desenhar a rota selecionada
                    const polyline = L.polyline(rota.coordenadas, {
                        color: rota.cor,
                        weight: 6,
                        opacity: 0.9,
                        dashArray: '10, 5'
                    });

                    if (!polyline) {
                        throw new Error('Erro ao criar polyline!');
                    }

                    polyline.addTo(mobilidadeMap);
                    polyline._rotaUsuario = true;

                    // Ajustar zoom
                    mobilidadeMap.fitBounds(polyline.getBounds(), { padding: [50, 50] });

                    // Notificação
                    mostrarNotificacao(`Rota "${rota.nome}" aplicada ao mapa!`, 'success');

                    // Adicionar marcadores de início e fim
                    const inicio = rota.coordenadas[0];
                    const fim = rota.coordenadas[rota.coordenadas.length - 1];

                    const marcadorInicio = L.marker(inicio, {
                        icon: L.divIcon({
                            className: 'custom-marker',
                            html: `<div style="background: #10b981; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">A</div>`,
                            iconSize: [30, 30]
                        })
                    }).addTo(mobilidadeMap);
                    marcadorInicio._rotaUsuario = true;

                    const marcadorFim = L.marker(fim, {
                        icon: L.divIcon({
                            className: 'custom-marker',
                            html: `<div style="background: #ef4444; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">B</div>`,
                            iconSize: [30, 30]
                        })
                    }).addTo(mobilidadeMap);
                    marcadorFim._rotaUsuario = true;

                } catch (error) {
                    console.error('❌ Erro ao desenhar rota:', error);
                    alert('⚠️ Erro ao aplicar rota ao mapa!');
                }
            }, 300);
        }

        function mostrarNotificacao(mensagem, tipo = 'info') {
            // Criar notificação toast
            const toast = document.createElement('div');
            toast.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: ${tipo === 'success' ? '#10b981' : '#3b82f6'};
        color: white;
        padding: 16px 24px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 99999999;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 12px;
        animation: slideIn 0.3s ease;
    `;

            toast.innerHTML = `
        <i class="bi bi-check-circle-fill" style="font-size: 20px;"></i>
        <span>${mensagem}</span>
    `;

            document.body.appendChild(toast);

            // Remover após 3 segundos
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Adicionar animações CSS
        const style = document.createElement('style');
        style.textContent = `
    @keyframes slideIn {
        from {
            transform: translateX(400px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes slideOut {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(400px);
            opacity: 0;
        }
    }
    
    .rota-card-alt:hover {
        transform: translateY(-4px) !important;
        box-shadow: 0 12px 24px rgba(59, 130, 246, 0.3) !important;
    }
`;
        document.head.appendChild(style);

        function selecionarPontoOrigem() {
            modoSelecao = 'origem';
            mobilidadeMap.getContainer().style.cursor = 'crosshair';

            document.getElementById('input-origem').style.borderColor = 'rgba(16, 185, 129, 0.8)';
            document.getElementById('input-origem').value = 'Clique no mapa para definir origem...';

            alert('📍 Clique no mapa para definir o ponto de ORIGEM');
        }

        function selecionarPontoDestino() {
            modoSelecao = 'destino';
            mobilidadeMap.getContainer().style.cursor = 'crosshair';

            document.getElementById('input-destino').style.borderColor = 'rgba(239, 68, 68, 0.8)';
            document.getElementById('input-destino').value = 'Clique no mapa para definir destino...';

            alert('📍 Clique no mapa para definir o ponto de DESTINO');
        }



        function limparRotas() {
            pontoOrigem = null;
            pontoDestino = null;

            if (marcadorOrigem) mobilidadeMap.removeLayer(marcadorOrigem);
            if (marcadorDestino) mobilidadeMap.removeLayer(marcadorDestino);

            marcadorOrigem = null;
            marcadorDestino = null;

            polylineRotas.forEach(p => mobilidadeMap.removeLayer(p));
            polylineRotas = [];

            rotasCalculadas = [];

            document.getElementById('input-origem').value = '';
            document.getElementById('input-destino').value = '';
            document.getElementById('btn-calcular-rotas').disabled = true;
            document.getElementById('btn-calcular-rotas').style.opacity = '0.5';

            document.getElementById('rotas-resultado').style.display = 'none';
            document.getElementById('rotas-mensagem-inicial').style.display = 'block';

            mobilidadeMap.getContainer().style.cursor = '';
            modoSelecao = null;
        }

        // … VARIAVEIS DO WAZE
        let wazeLayer = null;
        let wazeMarkers = [];
        let wazeVisible = false;
        let wazeUpdateInterval = null;

        function initMapa() {
            mobilidadeMap = L.map('mobilidade-map', {
                center: [-22.9068, -43.1729],
                zoom: 11,
                zoomControl: true
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: ' OpenStreetMap contributors',
                maxZoom: 18
            }).addTo(mobilidadeMap);

            // 🛡️ INTERCEPTOR ANTI-COLETORAS - BLOQUEIA ROTAS AZUIS AUTOMATICAMENTE!
            setInterval(() => {
                let removidas = 0;
                mobilidadeMap.eachLayer(layer => {
                    if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                        const cor = layer.options.color;
                        // Bloquear qualquer tom de azul (#3388ff, blue, etc)
                        if (cor === '#3388ff' || cor === 'blue' || cor === '#0000ff') {
                            mobilidadeMap.removeLayer(layer);
                            removidas++;
                        }
                    }
                });
                if (removidas > 0) {
                    console.log(`🛡️ Interceptor: ${removidas} coletoras bloqueadas`);
                }
            }, 200); // Verifica a cada 200ms

            console.log('🛡️ Interceptor anti-coletoras ATIVO!');

            loadKMLLayer();
            // console.log('… Mapa de mobilidade inicializado');
        }

        function loadKMLLayer() {
            try {
                console.log('📦 Carregando KML...');

                kmlLayer = omnivore.kml('{% static "mobilidade/kml/rotas.kml" %}')
                    .on('ready', function () {
                        console.log('✅ KML carregado');

                        let rotasClicaveis = [];

                        kmlLayer.eachLayer(function (layer) {
                            if (layer instanceof L.Polyline) {

                                // 🔍 VERIFICAR HIERARQUIA
                                const h1 = layer.feature.properties.Hierarquia;
                                const h2 = layer.feature.properties.hierarquia;
                                const h3 = layer.feature.properties['CLASSIFICACAO VIARIA'];

                                const hierarquia = h1 || h2 || h3 || 'Sem classificacao';
                                const hierarquiaLower = hierarquia.toLowerCase().trim();

                                // 🚫 IGNORAR COLETORAS E SEM CLASSIFICAÇÃO
                                if (hierarquiaLower === 'coletora' || hierarquiaLower === 'sem classificacao') {
                                    return;
                                }

                                // ✅ SETAR HIERARQUIA
                                layer._hierarquia = hierarquia;

                                // ✅ APLICAR COR CORRETA
                                const cor = hierarquiaCores[hierarquia] || '#64748b';

                                layer.setStyle({
                                    color: cor,
                                    weight: hierarquia === 'Estrutural' ? 4 : 3,
                                    opacity: 0.8,
                                    interactive: true
                                });

                                rotasClicaveis.push(layer);

                                // 🗺️ ADICIONAR AO MAPA INDIVIDUALMENTE
                                layer.addTo(mobilidadeMap);

                                // EVENTOS
                                layer.on('click', function (e) {
                                    L.DomEvent.stopPropagation(e);
                                    showRotaModal(layer);
                                });

                                layer.on('mouseover', function (e) {
                                    this.setStyle({
                                        color: '#fbbf24',
                                        weight: 5,
                                        opacity: 1
                                    });
                                });

                                layer.on('mouseout', function (e) {
                                    if (selectedRotaLayer !== this) {
                                        const hierarquia = this._hierarquia || 'Sem classificacao';
                                        const cor = hierarquiaCores[hierarquia] || '#64748b';
                                        this.setStyle({
                                            color: cor,
                                            weight: hierarquia === 'Estrutural' ? 4 : 3,
                                            opacity: 0.8
                                        });
                                    }
                                });
                            }
                        });

                        console.log(`✅ ${rotasClicaveis.length} rotas adicionadas ao mapa`);
                        window.rotasClicaveis = rotasClicaveis;

                        // Aplicar cores
                        aplicarCoresPorHierarquia();

                        // 🚫 REMOVER O kmlLayer DO MAPA
                        if (mobilidadeMap.hasLayer(kmlLayer)) {
                            mobilidadeMap.removeLayer(kmlLayer);
                            console.log('🗑️ kmlLayer removido - usando apenas rotas individuais');
                        }

                        // 🧹 LIMPEZA AUTOMÁTICA DE ROTAS AZUIS (BACKUP)
                        setTimeout(() => {
                            let removidas = 0;
                            mobilidadeMap.eachLayer(layer => {
                                if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                                    if (layer.options.color === '#3388ff') {
                                        mobilidadeMap.removeLayer(layer);
                                        removidas++;
                                    }
                                }
                            });
                            if (removidas > 0) {
                                console.log(`🧹 Limpeza automática: ${removidas} coletoras azuis removidas`);
                            }
                        }, 500); // Limpar após 500ms
                    })
                    .on('error', function (e) {
                        console.error('❌ Erro ao carregar KML:', e);
                    });

            } catch (error) {
                console.error('❌ Erro ao processar KML:', error);
            }
        }

        async function loadWazeAlerts() {
            try {
                const response = await fetch('/api/waze/');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (!data || !data.success) {
                    throw new Error(data.error || 'API retornou success=false');
                }

                const alertas = Array.isArray(data.alertas) ? data.alertas : [];
                const congestionamentos = Array.isArray(data.congestionamentos) ? data.congestionamentos : [];

                const todosAlertas = [...alertas, ...congestionamentos];

                if (todosAlertas.length === 0) {
                    console.warn('⚠️ Nenhum alerta disponível');
                    alert('ℹ️ Nenhum alerta do Waze disponível no momento.');
                    return;
                }

                // Limpar marcadores antigos
                wazeMarkers.forEach(marker => {
                    try {
                        if (marker && mobilidadeMap.hasLayer(marker)) {
                            mobilidadeMap.removeLayer(marker);
                        }
                    } catch (e) {
                        console.warn('Erro ao remover marcador:', e);
                    }
                });
                wazeMarkers = [];

                // ✨ FILTRAR: APENAS ALERTAS PRÓXIMOS DAS VIAS
                const raioMetros = 200; // Distância máxima da via (200 metros)
                let marcadoresAdicionados = 0;
                let alertasFiltrados = 0;

                todosAlertas.forEach((alert, index) => {
                    try {
                        const lat = alert.lat || alert.location?.y;
                        const lng = alert.lng || alert.location?.x;

                        if (!lat || !lng) return;

                        // ✅ VERIFICAR SE ESTÁ PRÓXIMO DE ALGUMA VIA
                        let estaPróximoDeVia = false;

                        if (window.rotasClicaveis && window.rotasClicaveis.length > 0) {
                            for (let rota of window.rotasClicaveis) {
                                // Ignorar rotas coletoras
                                if (rota._hierarquia === 'Coletora') continue;

                                const latlngs = rota.getLatLngs();
                                const alertLatLng = L.latLng(lat, lng);

                                // Calcular distância mínima até a rota
                                let menorDistancia = Infinity;
                                latlngs.forEach(ponto => {
                                    const distancia = mobilidadeMap.distance(alertLatLng, ponto);
                                    if (distancia < menorDistancia) {
                                        menorDistancia = distancia;
                                    }
                                });

                                // Se estiver a menos de 200m de qualquer ponto da via
                                if (menorDistancia <= raioMetros) {
                                    estaPróximoDeVia = true;
                                    break;
                                }
                            }
                        } else {
                            // Se não tem rotas carregadas, mostrar todos
                            estaPróximoDeVia = true;
                        }

                        // ❌ SE NÃO ESTÁ PRÓXIMO, IGNORAR
                        if (!estaPróximoDeVia) {
                            alertasFiltrados++;
                            return;
                        }

                        // ✅ CRIAR MARCADOR
                        const marker = criarMarcadorWaze(alert);

                        if (marker) {
                            if (wazeVisible) {
                                marker.addTo(mobilidadeMap);
                                marcadoresAdicionados++;
                            }
                            wazeMarkers.push(marker);
                        }
                    } catch (err) {
                        console.error('Erro ao processar alerta:', err);
                    }
                });

                console.log('');
                console.log('📊 RESUMO WAZE:');
                console.log('   Total de alertas:', todosAlertas.length);
                console.log('   ✅ Nas vias:', wazeMarkers.length);
                console.log('   ❌ Filtrados:', alertasFiltrados);
                console.log('   👁️ Visíveis:', marcadoresAdicionados);
                console.log('');

                atualizarEstatisticasWaze(todosAlertas.filter((alert, index) => {
                    const lat = alert.lat || alert.location?.y;
                    const lng = alert.lng || alert.location?.x;
                    if (!lat || !lng) return false;

                    // Verificar novamente se está próximo
                    if (!window.rotasClicaveis || window.rotasClicaveis.length === 0) return true;

                    for (let rota of window.rotasClicaveis) {
                        if (rota._hierarquia === 'Coletora') continue;

                        const latlngs = rota.getLatLngs();
                        const alertLatLng = L.latLng(lat, lng);

                        let menorDistancia = Infinity;
                        latlngs.forEach(ponto => {
                            const distancia = mobilidadeMap.distance(alertLatLng, ponto);
                            if (distancia < menorDistancia) {
                                menorDistancia = distancia;
                            }
                        });

                        if (menorDistancia <= raioMetros) {
                            return true;
                        }
                    }
                    return false;
                }));

                alert(`✅ Waze carregado!\n\n📍 ${wazeMarkers.length} alertas nas vias\n❌ ${alertasFiltrados} alertas filtrados (fora das vias)`);

            } catch (error) {
                console.error('❌ ERRO:', error);
                alert('❌ Erro ao carregar Waze:\n\n' + error.message);
            }
        }

        // ===== ALGORITMO DE CÁLCULO DE ROTAS =====

        async function calcularRotasAlternativas() {
            if (!pontoOrigem || !pontoDestino) {
                alert('❌ Defina origem e destino primeiro!');
                return;
            }

            if (!window.rotasClicaveis || window.rotasClicaveis.length === 0) {
                alert('❌ Carregue as rotas no mapa primeiro!');
                return;
            }

            // Mostrar loading
            document.getElementById('rotas-mensagem-inicial').innerHTML = `
            <div class="loading">
            <i class="bi bi-hourglass-split"></i>
            <p>Calculando rotas alternativas...</p>
            <p style="font-size: 13px; margin-top: 8px;">Analisando ${window.rotasClicaveis.length} vias e ${wazeMarkers ? wazeMarkers.length : 0} alertas</p>
            </div>
             `;

            await new Promise(resolve => setTimeout(resolve, 500));

            // Construir grafo de vias
            const grafo = construirGrafoVias();

            // Calcular 3 rotas diferentes
            const rotas = [];

            // Rota 1: Rápida (evita alertas críticos)
            const rotaRapida = calcularMelhorRota(grafo, pontoOrigem, pontoDestino, 'rapida');
            if (rotaRapida) {
                rotas.push({
                    tipo: 'rapida',
                    nome: 'Rota Rápida',
                    icone: 'bi-lightning-charge-fill',
                    cor: '#10b981',
                    corRgb: '16, 185, 129',
                    ...rotaRapida
                });
            }

            // Rota 2: Equilibrada
            const rotaEquilibrada = calcularMelhorRota(grafo, pontoOrigem, pontoDestino, 'equilibrada');
            if (rotaEquilibrada) {
                rotas.push({
                    tipo: 'equilibrada',
                    nome: 'Rota Equilibrada',
                    icone: 'bi-graph-up',
                    cor: '#f59e0b',
                    corRgb: '245, 158, 11',
                    ...rotaEquilibrada
                });
            }

            // Rota 3: Alternativa (vias secundárias)
            const rotaAlternativa = calcularMelhorRota(grafo, pontoOrigem, pontoDestino, 'alternativa');
            if (rotaAlternativa) {
                rotas.push({
                    tipo: 'alternativa',
                    nome: 'Rota Alternativa',
                    icone: 'bi-shuffle',
                    cor: '#3b82f6',
                    corRgb: '59, 130, 246',
                    ...rotaAlternativa
                });
            }

            if (rotas.length === 0) {
                alert('❌ Não foi possível calcular rotas entre estes pontos!');
                document.getElementById('rotas-mensagem-inicial').innerHTML = `
            <div style="text-align: center; padding: 40px; color: #ef4444;">
                <i class="bi bi-x-circle" style="font-size: 48px; margin-bottom: 16px;"></i>
                <p style="font-size: 16px; margin-bottom: 8px;">Não há rotas disponíveis</p>
                <p style="font-size: 13px;">Tente selecionar pontos mais próximos das vias</p>
            </div>
            `;
                return;
            }

            rotasCalculadas = rotas;

            // Renderizar rotas
            renderizarRotas(rotas);

            // Desenhar no mapa
            desenharRotasNoMapa(rotas);

            // Ajustar visualização
            const bounds = L.latLngBounds([pontoOrigem, pontoDestino]);
            rotas.forEach(rota => {
                rota.coordenadas.forEach(coord => bounds.extend(coord));
            });
            mobilidadeMap.fitBounds(bounds, { padding: [50, 50] });
        }

        async function calcularRotasAlternativasVia(nomeVia, lat, lng) {
            console.log('🗺️ Abrindo modal de rotas para:', nomeVia);

            const modal = document.getElementById('modal-rotas-alternativas');
            if (!modal) {
                console.error('❌ Modal não encontrado!');
                return;
            }

            // Mover para body e forçar CSS
            document.body.appendChild(modal);
            modal.removeAttribute('style');
            modal.style.cssText = `
        display: flex !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999999 !important;
        background: rgba(0, 0, 0, 0.95) !important;
        align-items: center !important;
        justify-content: center !important;
    `;

            // Atualizar título
            const tituloModal = document.getElementById('modal-rotas-titulo');
            if (tituloModal) {
                tituloModal.innerHTML = `Rotas alternativas para <strong>${nomeVia}</strong>`;
            }

            // Loading nos cards
            const cardsContainer = document.getElementById('modal-rotas-cards');
            if (cardsContainer) {
                cardsContainer.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #94a3b8;">
                <i class="bi bi-hourglass-split" style="font-size: 48px; animation: spin 1s linear infinite;"></i>
                <p style="margin-top: 16px;">Calculando rotas alternativas...</p>
            </div>
        `;
            }

            // Inicializar mapa e processar
            if (!window.modalMapa) {
                setTimeout(async () => {
                    try {
                        window.modalMapa = L.map('modal-mapa-rotas').setView([lat, lng], 13);
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(window.modalMapa);

                        // 🔥 PROCESSAR ROTAS
                        await processarRotasModal(nomeVia, lat, lng);
                    } catch (error) {
                        console.error('❌ Erro ao criar mapa:', error);
                        alert('❌ Erro ao criar mapa do modal');
                    }
                }, 100);
            } else {
                window.modalMapa.setView([lat, lng], 13);

                // 🔥 PROCESSAR ROTAS
                await processarRotasModal(nomeVia, lat, lng);
            }
        }

        async function processarRotasModal(nomeVia, lat, lng) {
            try {
                console.log('⚙️ Processando rotas...');

                // 1. CALCULAR (já existe e está correta)
                const rotas = await calcularRotasInteligentes(nomeVia, lat, lng);

                if (!rotas || rotas.length === 0) {
                    console.error('❌ Nenhuma rota calculada');

                    const cardsContainer = document.getElementById('modal-rotas-cards');
                    if (cardsContainer) {
                        cardsContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #ef4444;">
                        <i class="bi bi-x-circle" style="font-size: 48px;"></i>
                        <p style="margin-top: 16px;">Não foi possível calcular rotas</p>
                    </div>
                `;
                    }
                    return;
                }

                console.log('✅ Rotas calculadas:', rotas.length);

                // 2. SALVAR globalmente
                window.rotasCalculadas = rotas;

                // 3. RENDERIZAR cards
                renderizarCardsRotas(rotas);

                // 4. DESENHAR no mapa
                desenharRotasNoMapaModal(rotas);

                console.log('✅ Modal completo!');

            } catch (error) {
                console.error('❌ Erro ao processar:', error);

                const cardsContainer = document.getElementById('modal-rotas-cards');
                if (cardsContainer) {
                    cardsContainer.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #ef4444;">
                    <i class="bi bi-exclamation-triangle" style="font-size: 48px;"></i>
                    <p style="margin-top: 16px;">Erro: ${error.message}</p>
                </div>
            `;
                }
            }
        }

        function contarAlertasNaRota(coordenadas) {
            let acidentes = 0;
            let congestionamentos = 0;
            let outros = 0;

            if (!window.wazeMarkers || coordenadas.length === 0) {
                return { acidentes: 0, congestionamentos: 0, outros: 0, total: 0 };
            }

            // Para cada alerta do Waze, verificar se está próximo da rota
            window.wazeMarkers.forEach(marker => {
                if (!marker) return;

                const posMarker = marker.getLatLng();
                const distanciaMinima = Math.min(...coordenadas.map(coord => {
                    return mobilidadeMap.distance(posMarker, coord);
                }));

                // Se está a menos de 100m da rota
                if (distanciaMinima < 100) {
                    const tipo = marker.options.alertType;
                    if (tipo === 'ACCIDENT') acidentes++;
                    else if (tipo === 'JAM') congestionamentos++;
                    else outros++;
                }
            });

            return {
                acidentes,
                congestionamentos,
                outros,
                total: acidentes + congestionamentos + outros
            };
        }

        function calcularDistanciaRota(coordenadas) {
            let distanciaTotal = 0;
            for (let i = 0; i < coordenadas.length - 1; i++) {
                distanciaTotal += mobilidadeMap.distance(coordenadas[i], coordenadas[i + 1]);
            }
            return distanciaTotal / 1000; // Converter para km
        }

        function buscarViaParalela(viaOriginal, raioMetros, excluir = []) {
            const coordsOriginal = viaOriginal.getLatLngs();
            if (coordsOriginal.length === 0) return null;

            const inicioOriginal = coordsOriginal[0];
            const fimOriginal = coordsOriginal[coordsOriginal.length - 1];
            const distanciaOriginal = calcularDistanciaRota(coordsOriginal.map(c => [c.lat, c.lng]));

            let melhorVia = null;
            let melhorScore = -1;

            window.rotasClicaveis.forEach(rota => {
                // Não considerar a própria via ou vias excluídas
                if (rota === viaOriginal || excluir.includes(rota)) return;

                // Não considerar coletoras
                if (rota._hierarquia === 'Coletora') return;

                const coordsRota = rota.getLatLngs();
                if (coordsRota.length < 10) return; // Vias muito curtas

                const inicioRota = coordsRota[0];
                const fimRota = coordsRota[coordsRota.length - 1];
                const distanciaRota = calcularDistanciaRota(coordsRota.map(c => [c.lat, c.lng]));

                // A via deve ter tamanho similar (entre 50% e 150% da original)
                const ratioTamanho = distanciaRota / distanciaOriginal;
                if (ratioTamanho < 0.5 || ratioTamanho > 1.5) return;

                // Calcular se começa e termina próximo
                const distInicio = mobilidadeMap.distance(inicioOriginal, inicioRota);
                const distFim = mobilidadeMap.distance(fimOriginal, fimRota);

                // Ou se os pontos estão invertidos (via no sentido contrário)
                const distInicioInvertido = mobilidadeMap.distance(inicioOriginal, fimRota);
                const distFimInvertido = mobilidadeMap.distance(fimOriginal, inicioRota);

                const distTotal = Math.min(
                    distInicio + distFim,
                    distInicioInvertido + distFimInvertido
                );

                // A via deve começar e terminar próximo (dentro do raio)
                if (distTotal > raioMetros * 2) return;

                // Calcular score: quanto mais próxima dos extremos e mais similar em tamanho, melhor
                const score = 1000000 - distTotal - Math.abs(distanciaOriginal - distanciaRota) * 100;

                if (score > melhorScore) {
                    melhorVia = rota;
                    melhorScore = score;
                }
            });

            return melhorVia;
        }

        function desenharRotasNoMapaModal(rotas) {
            if (!rotas || rotas.length === 0) {
                console.error('❌ Nenhuma rota para desenhar');
                return;
            }

            console.log(`🗺️ Desenhando ${rotas.length} rotas no mapa modal...`);

            // Limpar polylines antigas
            if (window.modalPolylines) {
                window.modalPolylines.forEach(p => window.modalMapa.removeLayer(p));
            }
            window.modalPolylines = [];

            const bounds = L.latLngBounds();

            // Desenhar TODAS as rotas
            rotas.forEach((rota, index) => {
                const polyline = L.polyline(rota.coordenadas, {
                    color: rota.cor,
                    weight: index === 0 ? 6 : 5,
                    opacity: index === 0 ? 0.9 : 0.7,
                    dashArray: index === 0 ? null : '10, 5' // Primeira sólida, outras tracejadas
                }).addTo(window.modalMapa);

                // Adicionar popup
                polyline.bindPopup(`
            <div style="font-family: 'Inter', sans-serif;">
                <strong>${rota.nome}</strong><br>
                📏 ${rota.distancia} km<br>
                ⏱️ ${rota.tempo} min<br>
                🚨 ${rota.alertas?.total || 0} alertas
            </div>
        `);

                window.modalPolylines.push(polyline);

                // Adicionar coordenadas ao bounds
                rota.coordenadas.forEach(coord => bounds.extend(coord));
            });

            // Ajustar mapa para mostrar todas as rotas
            if (bounds.isValid()) {
                window.modalMapa.fitBounds(bounds, { padding: [50, 50] });
                console.log('✅ Mapa ajustado aos bounds');
            }
        }

        async function calcularRotasInteligentes(nomeVia, lat, lng) {
            console.log('📍 Calculando rotas alternativas para:', nomeVia);

            try {
                // 1. Encontrar a via original
                const viaOriginal = window.rotasClicaveis?.find(r => r.feature?.properties?.name === nomeVia);

                if (!viaOriginal) {
                    console.error('❌ Via não encontrada');
                    return [];
                }

                const coordsOriginais = viaOriginal.getLatLngs ? viaOriginal.getLatLngs() : viaOriginal._latlngs;
                const coords = coordsOriginais.map(c => [c.lat, c.lng]);
                const pontoInicio = coords[0];
                const pontoFim = coords[coords.length - 1];

                console.log('🎯 Origem:', pontoInicio);
                console.log('🎯 Destino:', pontoFim);

                // 2. ENCONTRAR 3 VIAS ALTERNATIVAS PRÓXIMAS
                const viasAlternativas = encontrarViasAlternativas(pontoInicio, pontoFim, nomeVia);

                console.log(`✅ Encontradas ${viasAlternativas.length} vias alternativas`);

                // 3. CALCULAR ROTA PARA CADA VIA (usando OSRM com waypoints)
                const rotas = [];
                const nomes = ['Rota Rápida', 'Rota Equilibrada', 'Rota Alternativa'];
                const cores = ['#10b981', '#f59e0b', '#3b82f6'];
                const tipos = ['rapida', 'equilibrada', 'alternativa'];

                for (let i = 0; i < Math.min(3, viasAlternativas.length); i++) {
                    const via = viasAlternativas[i];

                    // Ponto médio da via alternativa como waypoint
                    const waypoint = via.pontoMedio;

                    // Calcular rota: origem → via alternativa → destino
                    const rota = await calcularRotaComWaypoint(pontoInicio, waypoint, pontoFim);

                    if (rota) {
                        rotas.push({
                            nome: nomes[i],
                            tipo: tipos[i],
                            cor: cores[i],
                            coordenadas: rota.coordenadas,
                            distancia: rota.distancia,
                            tempo: rota.tempo,
                            alertas: contarAlertasNaRota(rota.coordenadas),
                            vias: [nomeVia, via.nome]
                        });
                        console.log(`✅ ${nomes[i]}: ${rota.distancia}km, ${rota.tempo}min`);
                    }
                }

                // 4. FALLBACK: usar OSRM direto se não encontrou vias alternativas
                if (rotas.length === 0) {
                    console.warn('⚠️ Usando OSRM direto...');
                    const rotasOSRM = await calcularRotasComOSRM(pontoInicio, pontoFim);

                    rotasOSRM.forEach((rota, i) => {
                        if (i < 3) {
                            rotas.push({
                                nome: nomes[i],
                                tipo: tipos[i],
                                cor: cores[i],
                                ...rota
                            });
                        }
                    });
                }

                // 5. Completar com via original se necessário
                while (rotas.length < 3) {
                    const i = rotas.length;
                    rotas.push({
                        nome: nomes[i],
                        tipo: 'original',
                        cor: cores[i],
                        coordenadas: coords,
                        distancia: calcularDistanciaTotal(coords),
                        tempo: Math.round(calcularDistanciaTotal(coords) * 60 / 40),
                        alertas: contarAlertasNaRota(coords),
                        vias: [nomeVia]
                    });
                }

                console.log(`✅ ${rotas.length} rotas prontas!`);
                return rotas;

            } catch (error) {
                console.error('❌ Erro:', error);
                return [];
            }
        }

        // ===== ENCONTRAR VIAS PARALELAS/PRÓXIMAS =====
        function encontrarViasAlternativas(origem, destino, viaAtual) {
            console.log('🔍 Procurando vias paralelas...');

            if (!window.rotasClicaveis || window.rotasClicaveis.length === 0) {
                return [];
            }

            const candidatas = [];

            // Calcular direção da rota original
            const direcaoOriginal = Math.atan2(
                destino[1] - origem[1],
                destino[0] - origem[0]
            );

            // Distância da rota original
            const distanciaOriginal = mobilidadeMap.distance(origem, destino);

            window.rotasClicaveis.forEach(rota => {
                const nome = rota.feature?.properties?.name;

                // Ignorar via atual e coletoras
                if (nome === viaAtual) return;
                if (rota._hierarquia === 'Coletora') return;

                const latlngs = rota.getLatLngs();
                if (!latlngs || latlngs.length < 5) return; // Precisa ter comprimento razoável

                // Pegar início e fim da via candidata
                const inicioVia = [latlngs[0].lat, latlngs[0].lng];
                const fimVia = [latlngs[latlngs.length - 1].lat, latlngs[latlngs.length - 1].lng];

                // Calcular direção da via candidata
                const direcaoCandidата = Math.atan2(
                    fimVia[1] - inicioVia[1],
                    fimVia[0] - inicioVia[0]
                );

                // Diferença angular (em radianos)
                let difAngular = Math.abs(direcaoOriginal - direcaoCandidата);
                if (difAngular > Math.PI) difAngular = 2 * Math.PI - difAngular;

                // Só aceitar vias com direção similar (até 45 graus de diferença)
                if (difAngular > Math.PI / 4) return;

                // Distância da via candidata
                const distanciaVia = mobilidadeMap.distance(inicioVia, fimVia);

                // Só aceitar vias com comprimento similar (50% a 150% da original)
                if (distanciaVia < distanciaOriginal * 0.5 || distanciaVia > distanciaOriginal * 1.5) return;

                // Calcular distância perpendicular (o quão paralela é)
                const distInicioOrigem = mobilidadeMap.distance(inicioVia, origem);
                const distInicioDestino = mobilidadeMap.distance(inicioVia, destino);
                const distFimOrigem = mobilidadeMap.distance(fimVia, origem);
                const distFimDestino = mobilidadeMap.distance(fimVia, destino);

                // Via deve estar relativamente próxima ao corredor original (máx 3km)
                const distanciaMedia = (distInicioOrigem + distFimDestino) / 2;
                if (distanciaMedia > 3000) return;

                // Ponto médio da via para usar como waypoint
                const pontoMedio = [
                    (inicioVia[0] + fimVia[0]) / 2,
                    (inicioVia[1] + fimVia[1]) / 2
                ];

                // Contar alertas Waze
                let alertas = 0;
                let penalidade = 1;

                if (window.wazeMarkers) {
                    window.wazeMarkers.forEach(marker => {
                        if (!marker?.wazeData) return;

                        const markerLatLng = marker.getLatLng();
                        latlngs.forEach(ponto => {
                            const dist = mobilidadeMap.distance(markerLatLng, [ponto.lat, ponto.lng]);
                            if (dist <= 200) {
                                alertas++;
                                const tipo = marker.wazeData.tipo || '';
                                if (tipo.includes('Acidente')) penalidade *= 1.5;
                                else if (marker.wazeData.velocidade < 20) penalidade *= 1.3;
                            }
                        });
                    });
                }

                // Calcular score (quanto menor, melhor)
                let score = distanciaMedia * penalidade;

                // Bonus para vias estruturais/arteriais
                if (rota._hierarquia === 'Estrutural') score *= 0.7;
                else if (rota._hierarquia === 'Arterial primária') score *= 0.85;

                candidatas.push({
                    nome: nome,
                    pontoMedio: pontoMedio,
                    distancia: distanciaMedia,
                    hierarquia: rota._hierarquia,
                    alertas: alertas,
                    penalidade: penalidade,
                    score: score,
                    direcao: direcaoCandidата,
                    comprimento: distanciaVia
                });
            });

            // Ordenar por score (menor = melhor)
            candidatas.sort((a, b) => a.score - b.score);

            const selecionadas = candidatas.slice(0, 3);

            console.log(`✅ Encontradas ${selecionadas.length} vias paralelas:`);
            selecionadas.forEach(v => {
                console.log(`  📍 ${v.nome}: ${(v.distancia / 1000).toFixed(1)}km de distância, ${v.alertas} alertas, ${v.hierarquia}`);
            });

            return selecionadas;
        }

        // ===== CALCULAR ROTA COM WAYPOINT =====
        async function calcularRotaComWaypoint(origem, waypoint, destino) {
            const [lng1, lat1] = [origem[1], origem[0]];
            const [lng2, lat2] = [waypoint[1], waypoint[0]];
            const [lng3, lat3] = [destino[1], destino[0]];

            const url = `https://router.project-osrm.org/route/v1/driving/${lng1},${lat1};${lng2},${lat2};${lng3},${lat3}?overview=full&geometries=geojson`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
                    return null;
                }

                const route = data.routes[0];

                return {
                    coordenadas: route.geometry.coordinates.map(c => [c[1], c[0]]),
                    distancia: parseFloat((route.distance / 1000).toFixed(1)),
                    tempo: Math.round(route.duration / 60)
                };
            } catch (error) {
                console.error('Erro OSRM waypoint:', error);
                return null;
            }
        }

        // ===== CONSTRUIR GRAFO DE VIAS =====
        function construirGrafoVias() {
            const grafo = { arestas: [] };

            if (!window.rotasClicaveis || window.rotasClicaveis.length === 0) {
                return grafo;
            }

            window.rotasClicaveis.forEach(rota => {
                // Ignorar coletoras
                if (rota._hierarquia === 'Coletora') return;

                const properties = rota.feature?.properties || {};
                const nome = properties.name || 'Via sem nome';
                const hierarquia = rota._hierarquia || 'Sem classificação';
                const latlngs = rota.getLatLngs();

                if (!latlngs || latlngs.length < 2) return;

                // Velocidade base por hierarquia
                let velocidadeBase = 40;
                if (hierarquia === 'Estrutural') velocidadeBase = 60;
                else if (hierarquia === 'Arterial primária') velocidadeBase = 50;
                else if (hierarquia === 'Arterial secundária') velocidadeBase = 40;

                // Analisar alertas Waze
                let penalidade = 1;
                let alertasNaVia = 0;

                if (window.wazeMarkers && window.wazeMarkers.length > 0) {
                    window.wazeMarkers.forEach(marker => {
                        if (!marker?.wazeData) return;

                        const markerLatLng = marker.getLatLng();
                        let menorDist = Infinity;

                        latlngs.forEach(ponto => {
                            const dist = mobilidadeMap.distance(markerLatLng, ponto);
                            if (dist < menorDist) menorDist = dist;
                        });

                        if (menorDist <= 200) {
                            alertasNaVia++;
                            const tipo = marker.wazeData.tipo || '';

                            if (tipo.includes('Acidente')) penalidade *= 2.5;
                            else if (marker.wazeData.velocidade < 15) penalidade *= 2;
                            else if (marker.wazeData.velocidade < 30) penalidade *= 1.5;
                            else penalidade *= 1.2;
                        }
                    });
                }

                // Criar segmentos
                for (let i = 0; i < latlngs.length - 1; i++) {
                    const inicio = latlngs[i];
                    const fim = latlngs[i + 1];
                    const dist = mobilidadeMap.distance(inicio, fim);
                    const distKm = dist / 1000;
                    const tempo = (distKm / velocidadeBase) * 60 * penalidade;

                    grafo.arestas.push({
                        inicio: inicio,
                        fim: fim,
                        distancia: dist,
                        tempo: tempo,
                        velocidade: velocidadeBase / penalidade,
                        hierarquia: hierarquia,
                        nomeVia: nome,
                        alertas: alertasNaVia,
                        penalidade: penalidade,
                        rota: rota
                    });
                }
            });

            return grafo;
        }

        // ===== CALCULAR MELHOR ROTA NO GRAFO =====
        function calcularMelhorRota(grafo, origem, destino, tipo, viasEvitar = []) {
            console.log(`  Buscando rota ${tipo}...`);

            // Encontrar segmentos mais próximos da origem e destino
            let segmentoInicio = null;
            let segmentoFim = null;
            let menorDistInicio = Infinity;
            let menorDistFim = Infinity;

            grafo.arestas.forEach(seg => {
                const distInicio = Math.min(
                    mobilidadeMap.distance(origem, seg.inicio),
                    mobilidadeMap.distance(origem, seg.fim)
                );
                const distFim = Math.min(
                    mobilidadeMap.distance(destino, seg.inicio),
                    mobilidadeMap.distance(destino, seg.fim)
                );

                if (distInicio < menorDistInicio) {
                    menorDistInicio = distInicio;
                    segmentoInicio = seg;
                }
                if (distFim < menorDistFim) {
                    menorDistFim = distFim;
                    segmentoFim = seg;
                }
            });

            if (!segmentoInicio || !segmentoFim) {
                console.warn('  Não encontrou segmentos próximos');
                return null;
            }

            // Construir caminho (simplificado - conectar vias próximas)
            const caminho = [];
            const viasUsadas = [];  // ✅ MUDOU AQUI: array ao invés de Set
            let segmentoAtual = segmentoInicio;
            const maxIteracoes = 50;
            let iteracoes = 0;

            while (segmentoAtual && iteracoes < maxIteracoes) {
                // Evitar usar a mesma via
                if (viasUsadas.includes(segmentoAtual.nomeVia)) break;  // ✅ USANDO .includes()

                // Evitar vias que devem ser evitadas
                if (viasEvitar.includes(segmentoAtual.nomeVia)) break;  // ✅ USANDO .includes()

                caminho.push(segmentoAtual);
                viasUsadas.push(segmentoAtual.nomeVia);  // ✅ USANDO .push()

                // Se chegou perto do destino, parar
                const distAoDestino = Math.min(
                    mobilidadeMap.distance(destino, segmentoAtual.inicio),
                    mobilidadeMap.distance(destino, segmentoAtual.fim)
                );

                if (distAoDestino < 500) break;

                // Procurar próximo segmento
                let proximoSegmento = null;
                let menorDist = Infinity;

                grafo.arestas.forEach(seg => {
                    if (viasUsadas.includes(seg.nomeVia)) return;  // ✅ USANDO .includes()
                    if (viasEvitar.includes(seg.nomeVia)) return;  // ✅ USANDO .includes()

                    const dist = mobilidadeMap.distance(segmentoAtual.fim, seg.inicio);

                    // Aplicar peso baseado no tipo de rota
                    let peso = dist;
                    if (tipo === 'rapida') peso = dist + (seg.tempo * 100);
                    else if (tipo === 'equilibrada') peso = dist + (seg.alertas * 1000);
                    else if (tipo === 'alternativa') peso = dist + (seg.hierarquia === 'Estrutural' ? 5000 : 0);

                    if (peso < menorDist) {
                        menorDist = peso;
                        proximoSegmento = seg;
                    }
                });

                segmentoAtual = proximoSegmento;
                iteracoes++;
            }

            if (caminho.length === 0) {
                console.warn('  Caminho vazio');
                return null;
            }

            // Montar resultado
            const coordenadas = [origem];
            const vias = [];
            let distTotal = menorDistInicio;
            let tempoTotal = (menorDistInicio / 1000 / 40) * 60;
            let alertasTotal = 0;

            caminho.forEach(seg => {
                coordenadas.push(seg.inicio, seg.fim);
                if (!vias.includes(seg.nomeVia)) vias.push(seg.nomeVia);
                distTotal += seg.distancia;
                tempoTotal += seg.tempo;
                alertasTotal += seg.alertas;
            });

            coordenadas.push(destino);
            distTotal += menorDistFim;
            tempoTotal += (menorDistFim / 1000 / 40) * 60;

            console.log(`  ✓ ${vias.length} vias, ${(distTotal / 1000).toFixed(1)}km`);

            return {
                coordenadas: coordenadas,
                vias: vias,
                distancia: parseFloat((distTotal / 1000).toFixed(1)),
                tempo: Math.round(tempoTotal),
                alertas: contarAlertasNaRota(coordenadas),
                velocidadeMedia: Math.round((distTotal / 1000) / (tempoTotal / 60))
            };
        }

        // ===== CALCULAR ROTAS COM OSRM (BACKUP) =====
        async function calcularRotasComOSRM(inicio, fim) {
            const [lng1, lat1] = [inicio[1], inicio[0]];
            const [lng2, lat2] = [fim[1], fim[0]];

            const url = `https://router.project-osrm.org/route/v1/driving/${lng1},${lat1};${lng2},${lat2}?alternatives=2&overview=full&geometries=geojson`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.code !== 'Ok' || !data.routes) return [];

                return data.routes.map(route => ({
                    coordenadas: route.geometry.coordinates.map(c => [c[1], c[0]]),
                    distancia: parseFloat((route.distance / 1000).toFixed(1)),
                    tempo: Math.round(route.duration / 60),
                    alertas: contarAlertasNaRota(route.geometry.coordinates.map(c => [c[1], c[0]])),
                    vias: ['OSRM (rota externa)']
                }));
            } catch (error) {
                console.error('Erro OSRM:', error);
                return [];
            }
        }

        // ===== CALCULAR DISTÂNCIA TOTAL =====
        function calcularDistanciaTotal(coords) {
            let total = 0;
            for (let i = 0; i < coords.length - 1; i++) {
                total += mobilidadeMap.distance(coords[i], coords[i + 1]);
            }
            return parseFloat((total / 1000).toFixed(1));
        }

        function construirGrafoVias() {
            const grafo = {
                nos: new Map(),
                arestas: []
            };

            window.rotasClicaveis.forEach(rota => {
                if (rota._hierarquia === 'Coletora') return;

                const properties = rota.feature.properties || {};
                const nome = properties.name || 'Via sem nome';
                const hierarquia = rota._hierarquia || 'Sem classificação';
                const latlngs = rota.getLatLngs();

                // Velocidade média por hierarquia (km/h)
                let velocidadeBase = 40;
                if (hierarquia === 'Estrutural') velocidadeBase = 60;
                else if (hierarquia === 'Arterial primária') velocidadeBase = 50;
                else if (hierarquia === 'Arterial secundária') velocidadeBase = 40;

                // Analisar alertas Waze nesta via
                let penalidade = 1;
                let alertasNaVia = 0;

                if (wazeMarkers && wazeMarkers.length > 0) {
                    wazeMarkers.forEach(marker => {
                        if (!marker || !marker.wazeData) return;

                        const markerLatLng = marker.getLatLng();
                        let menorDistancia = Infinity;

                        latlngs.forEach(ponto => {
                            const distancia = mobilidadeMap.distance(markerLatLng, ponto);
                            if (distancia < menorDistancia) {
                                menorDistancia = distancia;
                            }
                        });

                        if (menorDistancia <= 200) {
                            alertasNaVia++;
                            const data = marker.wazeData;

                            // Penalidades por tipo de alerta
                            if (data.tipo && data.tipo.includes('Acidente')) {
                                penalidade *= 2.5; // Acidente = +150% tempo
                            } else if (data.velocidade !== undefined && data.velocidade < 15) {
                                penalidade *= 2; // Congestionamento severo = +100% tempo
                            } else if (data.velocidade !== undefined && data.velocidade < 30) {
                                penalidade *= 1.5; // Congestionamento moderado = +50% tempo
                            } else {
                                penalidade *= 1.2; // Outros alertas = +20% tempo
                            }
                        }
                    });
                }

                // Adicionar segmentos da via como arestas
                for (let i = 0; i < latlngs.length - 1; i++) {
                    const inicio = latlngs[i];
                    const fim = latlngs[i + 1];

                    const distanciaMetros = mobilidadeMap.distance(inicio, fim);
                    const distanciaKm = distanciaMetros / 1000;

                    // Tempo = distância / velocidade (em horas), depois converter para minutos
                    const tempoBase = (distanciaKm / velocidadeBase) * 60;
                    const tempoReal = tempoBase * penalidade;

                    grafo.arestas.push({
                        inicio: inicio,
                        fim: fim,
                        distancia: distanciaMetros,
                        tempo: tempoReal,
                        velocidade: velocidadeBase / penalidade,
                        hierarquia: hierarquia,
                        nomeVia: nome,
                        alertas: alertasNaVia,
                        penalidade: penalidade
                    });
                }
            });

            return grafo;
        }

        function calcularMelhorRota(grafo, origem, destino, tipoRota, viasBloqueadas = new Set()) {
            // Encontrar via mais próxima da origem
            let viaInicioMaisProxima = null;
            let menorDistanciaInicio = Infinity;
            let pontoInicioMaisProximo = null;

            grafo.arestas.forEach(aresta => {
                const distInicio = mobilidadeMap.distance(origem, aresta.inicio);
                const distFim = mobilidadeMap.distance(origem, aresta.fim);

                if (distInicio < menorDistanciaInicio) {
                    menorDistanciaInicio = distInicio;
                    viaInicioMaisProxima = aresta;
                    pontoInicioMaisProximo = aresta.inicio;
                }
                if (distFim < menorDistanciaInicio) {
                    menorDistanciaInicio = distFim;
                    viaInicioMaisProxima = aresta;
                    pontoInicioMaisProximo = aresta.fim;
                }
            });

            // Encontrar via mais próxima do destino
            let viaFimMaisProxima = null;
            let menorDistanciaFim = Infinity;
            let pontoFimMaisProximo = null;

            grafo.arestas.forEach(aresta => {
                const distInicio = mobilidadeMap.distance(destino, aresta.inicio);
                const distFim = mobilidadeMap.distance(destino, aresta.fim);

                if (distInicio < menorDistanciaFim) {
                    menorDistanciaFim = distInicio;
                    viaFimMaisProxima = aresta;
                    pontoFimMaisProximo = aresta.inicio;
                }
                if (distFim < menorDistanciaFim) {
                    menorDistanciaFim = distFim;
                    viaFimMaisProxima = aresta;
                    pontoFimMaisProximo = aresta.fim;
                }
            });

            if (!viaInicioMaisProxima || !viaFimMaisProxima) {
                return null;
            }

            // Calcular caminho (simplificado - usa arestas conectadas)
            const caminho = encontrarCaminho(grafo, pontoInicioMaisProximo, pontoFimMaisProximo, tipoRota, viasBloqueadas);

            if (!caminho || caminho.length === 0) {
                // Se não encontrou caminho direto, usar linha reta com as vias encontradas
                caminho.push(viaInicioMaisProxima);
                if (viaFimMaisProxima !== viaInicioMaisProxima) {
                    caminho.push(viaFimMaisProxima);
                }
            }

            // Construir coordenadas da rota
            const coordenadas = [origem];
            const vias = new Set();
            let distanciaTotal = menorDistanciaInicio; // Distância da origem até a via
            let tempoTotal = (menorDistanciaInicio / 1000 / 40) * 60; // Tempo até a via (40 km/h)
            let alertasTotal = 0;
            let velocidadeMedia = 0;

            caminho.forEach(aresta => {
                if (!coordenadas.some(c => c.lat === aresta.inicio.lat && c.lng === aresta.inicio.lng)) {
                    coordenadas.push(aresta.inicio);
                }
                if (!coordenadas.some(c => c.lat === aresta.fim.lat && c.lng === aresta.fim.lng)) {
                    coordenadas.push(aresta.fim);
                }

                vias.add(aresta.nomeVia);
                distanciaTotal += aresta.distancia;
                tempoTotal += aresta.tempo;
                alertasTotal += aresta.alertas;
                velocidadeMedia += aresta.velocidade;
            });

            coordenadas.push(destino);
            distanciaTotal += menorDistanciaFim; // Distância da via até o destino
            tempoTotal += (menorDistanciaFim / 1000 / 40) * 60;

            velocidadeMedia = caminho.length > 0 ? velocidadeMedia / caminho.length : 40;

            return {
                coordenadas: coordenadas,
                vias: Array.from(vias),
                distancia: (distanciaTotal / 1000).toFixed(1), // em km
                tempo: Math.round(tempoTotal), // em minutos
                alertas: alertasTotal,
                velocidadeMedia: Math.round(velocidadeMedia)
            };
        }

        function encontrarCaminho(grafo, inicio, fim, tipoRota, viasBloqueadas = new Set()) {
            console.log(`🔍 Buscando caminho (${tipoRota})...`);
            console.log('   De:', inicio);
            console.log('   Para:', fim);
            console.log('   Distância direta:', (mobilidadeMap.distance(inicio, fim) / 1000).toFixed(1) + 'km');

            // Usar Dijkstra simplificado
            const distancias = new Map();
            const anteriores = new Map();
            const naoVisitados = [];

            // Criar chave para cada ponto
            const chaveInicio = `${inicio.lat.toFixed(6)},${inicio.lng.toFixed(6)}`;
            let chaveFim = `${fim.lat.toFixed(6)},${fim.lng.toFixed(6)}`;

            // Inicializar
            distancias.set(chaveInicio, 0);
            naoVisitados.push({ chave: chaveInicio, ponto: inicio, custo: 0 });

            // Mapear todas as arestas por ponto inicial
            const arestasPorPonto = new Map();
            grafo.arestas.forEach(aresta => {
                const chaveIni = `${aresta.inicio.lat.toFixed(6)},${aresta.inicio.lng.toFixed(6)}`;
                if (!arestasPorPonto.has(chaveIni)) {
                    arestasPorPonto.set(chaveIni, []);
                }
                arestasPorPonto.get(chaveIni).push(aresta);
            });

            let encontrado = false;
            let iteracoes = 0;
            const maxIteracoes = 10000; // AUMENTADO de 1000 para 10000

            while (naoVisitados.length > 0 && iteracoes < maxIteracoes) {
                iteracoes++;

                // DEBUG: Log detalhado
                if (iteracoes <= 5) {
                    console.log(`\n   === ITERAÇÃO ${iteracoes} ===`);
                    console.log(`   Fila tem ${naoVisitados.length} nós`);
                }

                // Pegar nó com menor custo
                naoVisitados.sort((a, b) => a.custo - b.custo);
                const atual = naoVisitados.shift();

                if (iteracoes <= 5) {
                    console.log(`   Processando ponto:`, atual.ponto);
                }

                const chave = `${atual.ponto.lat.toFixed(6)},${atual.ponto.lng.toFixed(6)}`;

                // Chegou no destino?
                const distAoFim = mobilidadeMap.distance(atual.ponto, fim);
                if (distAoFim < 500) {
                    encontrado = true;
                    chaveFim = atual.chave; // 🔥 USAR A CHAVE DO PONTO ATUAL, NÃO DO DESTINO EXATO!
                    console.log(`✅ Caminho encontrado após ${iteracoes} iterações!`);
                    console.log(`   Chegou a ${(distAoFim / 1000).toFixed(2)}km do destino`);
                    break;
                }

                if (iteracoes <= 5) {
                    console.log(`   Distância ao destino: ${(distAoFim / 1000).toFixed(2)}km`);
                }

                const arestasConectadas = grafo.arestas.filter(aresta => {
                    const dist = mobilidadeMap.distance(atual.ponto, aresta.inicio);
                    // Bloquear vias já usadas
                    if (viasBloqueadas.has(aresta.nomeVia)) return false;
                    return dist < 1000;
                });

                if (iteracoes <= 5) {
                    console.log(`   Encontrou ${arestasConectadas.length} arestas conectadas`);
                }

                let novasAdicionadas = 0;

                arestasConectadas.forEach(aresta => {
                    const chaveFimAresta = `${aresta.fim.lat.toFixed(6)},${aresta.fim.lng.toFixed(6)}`;

                    // Calcular custo
                    let custo = aresta.distancia;
                    if (tipoRota === 'rapida') {
                        custo = aresta.tempo * 1000;
                    } else if (tipoRota === 'equilibrada') {
                        custo = aresta.distancia + (aresta.tempo * 100);
                    } else if (tipoRota === 'alternativa') {
                        custo = aresta.distancia * aresta.penalidade * 2;
                    }

                    const novoCusto = (distancias.get(atual.chave) || 0) + custo;
                    const custoAnterior = distancias.get(chaveFimAresta) || Infinity;

                    if (novoCusto < custoAnterior) {
                        distancias.set(chaveFimAresta, novoCusto);
                        anteriores.set(chaveFimAresta, { chave: atual.chave, aresta: aresta });

                        naoVisitados.push({
                            chave: chaveFimAresta,
                            ponto: aresta.fim,
                            custo: novoCusto
                        });

                        novasAdicionadas++;
                    }
                });

                if (iteracoes <= 5) {
                    console.log(`   Adicionou ${novasAdicionadas} novos nós à fila`);
                    console.log(`   Fila agora tem ${naoVisitados.length} nós`);
                }

                // Log a cada 1000 iterações
                if (iteracoes % 1000 === 0) {
                    console.log(`   Iteração ${iteracoes}, fila: ${naoVisitados.length}, distâncias: ${distancias.size}`);
                }
            }

            if (!encontrado) {
                console.log(`⚠️ Caminho não encontrado após ${iteracoes} iterações`);
                console.log(`   Nós visitados: ${distancias.size}`);
                return [];
            }

            // Reconstruir caminho
            const caminho = [];
            let chaveAtual = chaveFim;

            while (anteriores.has(chaveAtual)) {
                const anterior = anteriores.get(chaveAtual);
                caminho.unshift(anterior.aresta);
                chaveAtual = anterior.chave;
            }

            console.log(`📊 Caminho com ${caminho.length} arestas`);
            return caminho;
        }

        // ===== RENDERIZAÇÃO DAS ROTAS =====

        function renderizarRotas(rotas) {
            const container = document.getElementById('rotas-cards-container');

            // Encontrar a rota mais rápida
            const rotaMaisRapida = rotas.reduce((min, rota) =>
                rota.tempo < min.tempo ? rota : min
                , rotas[0]);

            container.innerHTML = rotas.map((rota, index) => {
                const isRecomendada = rota === rotaMaisRapida;

                // Calcular economia de tempo
                const diferencaTempo = rota.tempo - rotaMaisRapida.tempo;

                // Status do trânsito baseado em alertas
                let statusTransito = 'Livre';
                let statusCor = '#10b981';
                if (rota.alertas > 5) {
                    statusTransito = 'Congestionado';
                    statusCor = '#ef4444';
                } else if (rota.alertas > 2) {
                    statusTransito = 'Moderado';
                    statusCor = '#f59e0b';
                }

                return `
            <div class="rota-card" 
                 style="--rota-cor: ${rota.cor}; --rota-cor-rgb: ${rota.corRgb}"
                 onclick="selecionarRota(${index})"
                 data-rota-index="${index}">
                
                <div class="rota-header">
                    <div class="rota-titulo">
                        <div class="rota-icone">
                            <i class="${rota.icone}"></i>
                        </div>
                        <div>
                            <div class="rota-nome">${rota.nome}</div>
                            <div style="font-size: 12px; color: #64748b; margin-top: 4px;">
                                ${rota.vias.length} via${rota.vias.length > 1 ? 's' : ''}
                            </div>
                        </div>
                    </div>
                    ${isRecomendada ? `
                        <div class="rota-badge recomendada">
                            <i class="bi bi-star-fill"></i> Recomendada
                        </div>
                    ` : diferencaTempo > 0 ? `
                        <div style="font-size: 12px; color: #64748b;">
                            +${diferencaTempo} min
                        </div>
                    ` : ''}
                </div>
                
                <!-- Tempo Principal -->
                <div class="rota-tempo-principal">
                    <div class="rota-tempo-valor">${rota.tempo}</div>
                    <div class="rota-tempo-label">Minutos</div>
                </div>
                
                <!-- Métricas -->
                <div class="rota-metricas">
                    <div class="rota-metrica">
                        <div class="rota-metrica-valor">${rota.distancia}</div>
                        <div class="rota-metrica-label">km</div>
                    </div>
                    
                    <div class="rota-metrica">
                        <div class="rota-metrica-valor">${rota.velocidadeMedia}</div>
                        <div class="rota-metrica-label">km/h média</div>
                    </div>
                    
                    <div class="rota-metrica">
                        <div class="rota-metrica-valor" style="color: ${statusCor}">
                            ${rota.alertas}
                        </div>
                        <div class="rota-metrica-label">Alertas</div>
                    </div>
                </div>
                
                <!-- Status do Trânsito -->
                <div style="
                    text-align: center;
                    padding: 12px;
                    background: rgba(255, 255, 255, 0.03);
                    border-radius: 8px;
                    margin-bottom: 16px;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                ">
                    <div style="display: inline-flex; align-items: center; gap: 8px; padding: 6px 16px; border-radius: 20px; background: ${statusCor}20; border: 1px solid ${statusCor}40;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: ${statusCor};"></div>
                        <span style="font-size: 13px; font-weight: 600; color: ${statusCor};">
                            Trânsito ${statusTransito}
                        </span>
                    </div>
                </div>
                
                <!-- Detalhes Expandíveis -->
                <details style="margin-top: 16px;">
                    <summary style="
                        cursor: pointer;
                        padding: 12px;
                        background: rgba(255, 255, 255, 0.03);
                        border-radius: 8px;
                        font-weight: 600;
                        color: #cbd5e1;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <span><i class="bi bi-list-ul"></i> Ver Vias</span>
                        <i class="bi bi-chevron-down"></i>
                    </summary>
                    
                    <div class="rota-vias-lista" style="margin-top: 12px;">
                        ${rota.vias.map((via, viaIndex) => `
                            <div class="rota-via-item">
                                <strong>${viaIndex + 1}.</strong> ${via}
                            </div>
                        `).join('')}
                    </div>
                </details>
                
                <!-- Botão de Ação -->
                <button onclick="iniciarNavegacao(${index}); event.stopPropagation();" style="
                    margin-top: 16px;
                    width: 100%;
                    padding: 14px;
                    background: linear-gradient(135deg, ${rota.cor} 0%, ${rota.cor}dd 100%);
                    border: none;
                    border-radius: 8px;
                    color: white;
                    font-weight: 700;
                    font-size: 15px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 10px;
                    transition: all 0.2s;
                " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                    <i class="bi bi-play-circle-fill"></i>
                    Selecionar Esta Rota
                </button>
            </div>
        `;
            }).join('');

            document.getElementById('rotas-mensagem-inicial').style.display = 'none';
            document.getElementById('rotas-resultado').style.display = 'block';
        }

        function desenharRotasNoMapa(rotas) {
            // Remover polylines anteriores
            polylineRotas.forEach(p => mobilidadeMap.removeLayer(p));
            polylineRotas = [];

            rotas.forEach((rota, index) => {
                const polyline = L.polyline(rota.coordenadas, {
                    color: rota.cor,
                    weight: 6,
                    opacity: 0.7,
                    dashArray: index === 0 ? null : '10, 10', // Primeira sólida, outras tracejadas
                    className: `rota-polyline rota-${index}`
                }).addTo(mobilidadeMap);

                // Tooltip
                polyline.bindTooltip(`
            <div style="text-align: center;">
                <strong>${rota.nome}</strong><br>
                <span style="font-size: 18px; font-weight: 700;">${rota.tempo} min</span><br>
                ${rota.distancia} km · ${rota.alertas} alertas
            </div>
        `, {
                    sticky: true,
                    className: 'rota-tooltip'
                });

                // Click para selecionar
                polyline.on('click', () => selecionarRota(index));

                polylineRotas.push(polyline);
            });
        }

        function selecionarRota(index) {
            const rota = rotasCalculadas[index];

            // Remover seleção anterior
            document.querySelectorAll('.rota-card').forEach(card => {
                card.classList.remove('selecionada');
            });

            // Adicionar seleção
            const card = document.querySelector(`[data-rota-index="${index}"]`);
            if (card) {
                card.classList.add('selecionada');
                card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Destacar polyline
            polylineRotas.forEach((polyline, i) => {
                if (i === index) {
                    polyline.setStyle({ weight: 10, opacity: 1, zIndexOffset: 1000 });
                } else {
                    polyline.setStyle({ weight: 6, opacity: 0.4 });
                }
            });

            // Ajustar visualização
            mobilidadeMap.fitBounds(polylineRotas[index].getBounds(), { padding: [50, 50] });
        }

        function iniciarNavegacao(index) {
            const rota = rotasCalculadas[index];

            const confirmacao = confirm(
                `🚗 Iniciar navegação pela ${rota.nome}?\n\n` +
                `⏱️ Tempo: ${rota.tempo} minutos\n` +
                `📏 Distância: ${rota.distancia} km\n` +
                `⚠️ Alertas: ${rota.alertas}\n` +
                `🚦 Velocidade média: ${rota.velocidadeMedia} km/h\n\n` +
                `Esta função abrirá o Google Maps com as coordenadas.`
            );

            if (confirmacao) {
                // Criar URL do Google Maps
                const origem = `${pontoOrigem.lat},${pontoOrigem.lng}`;
                const destino = `${pontoDestino.lat},${pontoDestino.lng}`;

                // Pontos intermediários (waypoints)
                const waypoints = rota.coordenadas
                    .slice(1, -1) // Remove origem e destino
                    .filter((coord, i) => i % 3 === 0) // Pega alguns pontos intermediários
                    .map(coord => `${coord.lat},${coord.lng}`)
                    .join('|');

                const urlMaps = `https://www.google.com/maps/dir/?api=1&origin=${origem}&destination=${destino}${waypoints ? `&waypoints=${waypoints}` : ''}&travelmode=driving`;

                window.open(urlMaps, '_blank');
            }
        }

        // ===== FILTROS DE VIAS =====

        function toggleFiltrosVias() {
            const painel = document.getElementById('painel-filtros-vias');
            const btn = document.getElementById('btn-toggle-filtros');

            if (painel.style.display === 'none') {
                painel.style.display = 'block';
                btn.style.background = 'linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%)';
            } else {
                painel.style.display = 'none';
                btn.style.background = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
            }
        }

        function aplicarFiltrosVias() {
            const termo = document.getElementById('pesquisa-vias').value.toLowerCase().trim();
            const filtroStatus = document.getElementById('filtro-status').value;
            const filtroHierarquia = document.getElementById('filtro-hierarquia').value.toLowerCase();
            const filtroAlertas = document.getElementById('filtro-alertas').value;
            const ordenacao = document.getElementById('filtro-ordenar').value;

            // CORRIGIDO: buscar .via-card ao invés de .via-status-card
            const cards = Array.from(document.querySelectorAll('.via-card'));
            const resultado = document.getElementById('resultado-pesquisa');
            const badge = document.getElementById('filtros-ativos-badge');

            let visiveis = 0;
            let filtrosAtivos = 0;

            // Contar filtros ativos
            if (termo !== '') filtrosAtivos++;
            if (filtroStatus !== '') filtrosAtivos++;
            if (filtroHierarquia !== '') filtrosAtivos++;
            if (filtroAlertas !== '') filtrosAtivos++;

            // Atualizar badge
            if (filtrosAtivos > 0) {
                badge.style.display = 'block';
                badge.textContent = filtrosAtivos;
            } else {
                badge.style.display = 'none';
            }

            // Filtrar cards
            cards.forEach(card => {
                const nome = card.dataset.viaNome || '';
                const hierarquia = card.dataset.viaHierarquia || '';
                const status = card.dataset.viaStatus || '';

                // Pegar número de alertas do card
                const alertasEl = card.querySelector('.via-card-stat-value');
                const numAlertas = alertasEl ? parseInt(alertasEl.textContent) || 0 : 0;
                const temAlertas = numAlertas > 0;

                // Filtro por nome
                const matchNome = termo === '' || nome.includes(termo);

                // Filtro por status
                const matchStatus = filtroStatus === '' || status.includes(filtroStatus);

                // Filtro por hierarquia
                const matchHierarquia = filtroHierarquia === '' || hierarquia.includes(filtroHierarquia);

                // Filtro por alertas
                let matchAlertas = true;
                if (filtroAlertas === 'com') matchAlertas = temAlertas;
                if (filtroAlertas === 'sem') matchAlertas = !temAlertas;

                const match = matchNome && matchStatus && matchHierarquia && matchAlertas;

                if (match) {
                    card.style.display = '';
                    visiveis++;
                } else {
                    card.style.display = 'none';
                }
            });

            // Mostrar resultado
            if (filtrosAtivos > 0) {
                resultado.style.display = 'block';
                if (visiveis === 0) {
                    resultado.innerHTML = `<i class="bi bi-x-circle"></i> Nenhuma via encontrada com os filtros aplicados`;
                } else {
                    resultado.innerHTML = `<i class="bi bi-check-circle"></i> ${visiveis} via${visiveis > 1 ? 's' : ''} encontrada${visiveis > 1 ? 's' : ''}`;
                }
            } else {
                resultado.style.display = 'none';
            }
        }

        function limparFiltrosVias() {
            document.getElementById('pesquisa-vias').value = '';
            document.getElementById('filtro-status').value = '';
            document.getElementById('filtro-hierarquia').value = '';
            document.getElementById('filtro-alertas').value = '';
            document.getElementById('filtro-ordenar').value = 'criticidade';

            aplicarFiltrosVias();
        }

        // ===== STATUS DAS VIAS COM WAZE =====
        function analisarViasComWaze() {
            const container = document.getElementById('status-vias-container');

            if (!window.rotasClicaveis || window.rotasClicaveis.length === 0) {
                container.innerHTML = `
            <div class="via-sem-dados">
                <i class="bi bi-map"></i>
                <p>Nenhuma via carregada no mapa</p>
                <p style="font-size: 13px; margin-top: 8px;">Ative a visualização de rotas para ver o status</p>
            </div>
        `;
                return;
            }

            const temWaze = wazeMarkers && wazeMarkers.length > 0;
            const viasComStatus = [];
            const raioMetros = 200;

            // Analisar cada via
            window.rotasClicaveis.forEach(rota => {
                // Ignorar coletoras
                if (rota._hierarquia === 'Coletora') return;

                const properties = rota.feature.properties || {};
                const nome = properties.name || 'Via sem identificação';
                const hierarquia = rota._hierarquia || 'Sem classificação';
                const latlngs = rota.getLatLngs();

                // Calcular distância da via
                let distanciaTotal = 0;
                for (let i = 0; i < latlngs.length - 1; i++) {
                    distanciaTotal += mobilidadeMap.distance(latlngs[i], latlngs[i + 1]);
                }
                distanciaTotal = (distanciaTotal / 1000).toFixed(2);

                // Analisar alertas Waze próximos
                const analise = {
                    acidentes: 0,
                    congestionamentos: 0,
                    perigos: 0,
                    obras: 0,
                    velocidades: [],
                    atrasos: []
                };

                wazeMarkers.forEach(marker => {
                    if (!marker || !marker.wazeData) return;

                    const markerLatLng = marker.getLatLng();
                    let menorDistancia = Infinity;

                    latlngs.forEach(ponto => {
                        const distancia = mobilidadeMap.distance(markerLatLng, ponto);
                        if (distancia < menorDistancia) {
                            menorDistancia = distancia;
                        }
                    });

                    if (menorDistancia <= raioMetros) {
                        const data = marker.wazeData;
                        const tipo = data.tipo || data.type || '';

                        if (tipo.includes('Acidente') || tipo === 'ACCIDENT') {
                            analise.acidentes++;
                        } else if (tipo.includes('Congestionamento') || tipo === 'JAM') {
                            analise.congestionamentos++;
                            if (data.velocidade !== undefined) {
                                analise.velocidades.push(data.velocidade);
                            }
                            if (data.atraso !== undefined) {
                                analise.atrasos.push(data.atraso);
                            }
                        } else if (tipo.includes('Perigo') || tipo === 'HAZARD') {
                            analise.perigos++;
                        } else if (tipo.includes('Obra') || tipo === 'CONSTRUCTION') {
                            analise.obras++;
                        }
                    }
                });

                // Calcular velocidade média
                let velocidadeMedia = null;
                if (analise.velocidades.length > 0) {
                    const soma = analise.velocidades.reduce((a, b) => a + b, 0);
                    velocidadeMedia = Math.round((soma / analise.velocidades.length) * 10) / 10;
                }

                // Calcular atraso total
                let atrasoTotal = 0;
                if (analise.atrasos.length > 0) {
                    atrasoTotal = Math.round(analise.atrasos.reduce((a, b) => a + b, 0) / 60);
                }

                // Determinar status
                let status = 'normal';
                let statusTexto = 'Trânsito Normal';
                let statusIcone = 'check-circle-fill';

                if (analise.acidentes > 0) {
                    status = 'critico';
                    statusTexto = 'Acidente na Via';
                    statusIcone = 'exclamation-octagon-fill';
                } else if (velocidadeMedia !== null && velocidadeMedia < 15) {
                    status = 'critico';
                    statusTexto = 'Trânsito Parado';
                    statusIcone = 'exclamation-octagon-fill';
                } else if (velocidadeMedia !== null && velocidadeMedia < 30) {
                    status = 'intenso';
                    statusTexto = 'Trânsito Intenso';
                    statusIcone = 'exclamation-triangle-fill';
                } else if (analise.congestionamentos >= 2) {
                    status = 'moderado';
                    statusTexto = 'Trânsito Moderado';
                    statusIcone = 'exclamation-circle-fill';
                }

                const totalAlertas = analise.acidentes + analise.congestionamentos + analise.perigos + analise.obras;

                viasComStatus.push({
                    rota,
                    nome,
                    hierarquia,
                    distancia: distanciaTotal,
                    status,
                    statusTexto,
                    statusIcone,
                    velocidadeMedia,
                    atrasoTotal,
                    totalAlertas,
                    analise
                });
            });

            // Ordenar por criticidade
            const ordemStatus = { critico: 0, intenso: 1, moderado: 2, normal: 3 };
            viasComStatus.sort((a, b) => ordemStatus[a.status] - ordemStatus[b.status]);

            // Renderizar cards
            if (viasComStatus.length === 0) {
                container.innerHTML = `
            <div class="via-sem-dados">
                <i class="bi bi-info-circle"></i>
                <p>Nenhuma via com dados disponíveis</p>
            </div>
        `;
                return;
            }

            container.innerHTML = viasComStatus.map((via) => {
                return `
            <div class="via-card" 
                 onclick="centralizarVia('${via.nome}')" 
                 data-via-nome="${via.nome.toLowerCase()}" 
                 data-via-hierarquia="${via.hierarquia.toLowerCase()}" 
                 data-via-status="${via.statusTexto.toLowerCase()}">
                
                <div class="via-card-header">
                    <div>
                        <div class="via-card-title">${via.nome}</div>
                        <div class="via-card-hierarquia">${via.hierarquia}</div>
                    </div>
                    <div class="via-card-status ${via.status}">
                        <i class="bi bi-${via.statusIcone}"></i>
                        ${via.statusTexto}
                    </div>
                </div>
                
                <div class="via-card-stats">
                    <div class="via-card-stat">
                        <div class="via-card-stat-value">${via.distancia}</div>
                        <div class="via-card-stat-label">KM</div>
                    </div>
                    <div class="via-card-stat">
                        <div class="via-card-stat-value">${via.totalAlertas}</div>
                        <div class="via-card-stat-label">Alertas</div>
                    </div>
                </div>
                
                ${via.velocidadeMedia !== null || via.atrasoTotal > 0 ? `
                    <div class="via-card-stats">
                        ${via.velocidadeMedia !== null ? `
                            <div class="via-card-stat">
                                <div class="via-card-stat-value" style="font-size: 20px;">${via.velocidadeMedia}</div>
                                <div class="via-card-stat-label">km/h</div>
                            </div>
                        ` : ''}
                        ${via.atrasoTotal > 0 ? `
                            <div class="via-card-stat">
                                <div class="via-card-stat-value" style="font-size: 20px;">+${via.atrasoTotal}</div>
                                <div class="via-card-stat-label">min</div>
                            </div>
                        ` : ''}
                    </div>
                ` : ''}
                
                <button 
                    onclick="event.stopPropagation(); calcularRotasAlternativasVia('${via.nome}', ${via.rota.getLatLngs()[0].lat}, ${via.rota.getLatLngs()[0].lng})"
                    class="via-card-button">
                    <i class="bi bi-signpost-split-fill"></i>
                    Ver Rotas Alternativas
                </button>
            </div>
        `;
            }).join('');

            // Atualizar timestamp
            const agora = new Date();
            document.getElementById('ultima-atualizacao-vias').textContent =
                `Última atualização: ${agora.toLocaleTimeString('pt-BR')}`;
        }


        // Toggle detalhes da via
        function toggleDetalhesVia(detalhesId, btn) {
            const detalhes = document.getElementById(detalhesId);
            const icone = btn.querySelector('i');
            const texto = btn.querySelector('span');

            if (detalhes.classList.contains('expanded')) {
                detalhes.classList.remove('expanded');
                icone.className = 'bi bi-chevron-down';
                texto.textContent = texto.textContent.replace('Ocultar', 'Ver');
            } else {
                detalhes.classList.add('expanded');
                icone.className = 'bi bi-chevron-up';
                texto.textContent = texto.textContent.replace('Ver', 'Ocultar');
            }
        }

        // Filtrar vias
        function filtrarVias(termo) {
            const termoLower = termo.toLowerCase().trim();
            // CORRIGIDO: buscar .via-card
            const cards = document.querySelectorAll('.via-card');
            const resultado = document.getElementById('resultado-pesquisa');

            let visiveis = 0;

            cards.forEach(card => {
                const nome = card.dataset.viaNome || '';

                if (termoLower === '' || nome.includes(termoLower)) {
                    card.style.display = '';
                    visiveis++;
                } else {
                    card.style.display = 'none';
                }
            });

            if (termoLower !== '') {
                resultado.style.display = 'block';
                resultado.innerHTML = `<i class="bi bi-check-circle"></i> ${visiveis} via${visiveis > 1 ? 's' : ''} encontrada${visiveis > 1 ? 's' : ''}`;
            } else {
                resultado.style.display = 'none';
            }
        }

        function centralizarVia(nomeVia) {
            const rota = window.rotasClicaveis.find(r => {
                const nome = r.feature.properties.name || '';
                return nome === nomeVia;
            });

            if (rota) {
                mobilidadeMap.fitBounds(rota.getBounds(), { padding: [50, 50] });

                // Destacar temporariamente
                const corOriginal = rota.options.color;
                rota.setStyle({ color: '#fbbf24', weight: 6 });

                setTimeout(() => {
                    rota.setStyle({ color: corOriginal, weight: 3 });
                }, 2000);
            }
        }

        function atualizarStatusVias() {
            analisarViasComWaze();
        }

        function abrirModalNovaRota() {
            // console.log('‹ Abrindo modal...');

            // Garantir modo automatico ativo
            modoAtual = 'automatico';
            document.getElementById('tab-automatico').classList.add('active');
            document.getElementById('tab-manual').classList.remove('active');

            const modoAuto = document.getElementById('modo-automatico');
            const modoManual = document.getElementById('modo-manual');

            modoAuto.classList.add('active');
            modoAuto.style.display = 'block';

            modoManual.classList.remove('active');
            modoManual.style.display = 'none';

            // Abrir modal
            const modal = document.getElementById('nova-rota-modal');
            modal.classList.add('active');

            // console.log('… Modal aberto');
        }

        function criarMarcadorWaze(alert) {
            const lat = alert.lat || alert.location?.y;
            const lng = alert.lng || alert.location?.x;

            if (!lat || !lng) {
                return null;
            }

            // ✅ VERIFICAR TIPO E SUBTIPO
            const tipo = (alert.tipo || alert.type || '').toUpperCase();
            const subtipo = (alert.subtipo || alert.subtype || '').toUpperCase();

            // ✅ MAPEAMENTO COMPLETO COM BOOTSTRAP ICONS
            const mapa = {
                // PERIGOS
                'PERIGO': { icon: 'bi-exclamation-diamond-fill', color: '#eab308', título: 'Perigo' },
                'BURACO': { icon: 'bi-sign-stop-fill', color: '#ef4444', título: 'Buraco' },
                'CLIMA': { icon: 'bi-cloud-rain-fill', color: '#6366f1', título: 'Condiçío Climática' },
                'PERIGO NA PISTA': { icon: 'bi-exclamation-octagon-fill', color: '#f59e0b', título: 'Perigo na Pista' },
                'HAZARD_ON_SHOULDER_CAR_STOPPED': { icon: 'bi-car-front-fill', color: '#f59e0b', título: 'Veículo Parado' },
                'HAZARD': { icon: 'bi-exclamation-triangle-fill', color: '#f59e0b', título: 'Perigo' },

                // VIA FECHADA
                'VIA FECHADA': { icon: 'bi-slash-circle-fill', color: '#dc2626', título: 'Via Fechada' },
                'ROAD_CLOSED': { icon: 'bi-slash-circle-fill', color: '#dc2626', título: 'Via Fechada' },

                // CONGESTIONAMENTOS
                'CONGESTIONAMENTO': { icon: 'bi-exclamation-triangle-fill', color: '#f97316', título: 'Congestionamento' },
                'JAM': { icon: 'bi-truck-front', color: '#f97316', título: 'Congestionamento' },
                'JAM_HEAVY_TRAFFIC': { icon: 'bi-truck-front', color: '#f97316', título: 'Trsito Pesado' },
                'JAM_STAND_STILL_TRAFFIC': { icon: 'bi-exclamation-circle-fill', color: '#dc2626', título: 'Trsito Parado' },

                // ACIDENTES
                'ACIDENTE': { icon: 'bi-car-front-fill', color: '#dc2626', título: 'Acidente' },
                'ACCIDENT': { icon: 'bi-car-front-fill', color: '#dc2626', título: 'Acidente' },

                // OBRAS
                'OBRA': { icon: 'bi-cone-striped', color: '#f59e0b', título: 'Obra' },
                'CONSTRUCTION': { icon: 'bi-cone-striped', color: '#f59e0b', título: 'Obra' }
            };

            // ? BUSCAR: subtipo > tipo > padrío
            const cfg = mapa[subtipo] || mapa[tipo] || {
                icon: 'bi-question-circle-fill',
                color: '#94a3b8',
                título: 'Alerta'
            };

            // ✅ CRIAR MARCADOR COM BOOTSTRAP ICON
            const marker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'waze-marker-static',
                    html: `
                <div style="
                    width: 36px;
                    height: 36px;
                    background: ${cfg.color};
                    border: 3px solid white;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    box-shadow: 0 3px 10px rgba(0,0,0,0.4);
                    cursor: pointer;
                ">
                    <i class="bi ${cfg.icon}" style="color: white; font-size: 18px;"></i>
                </div>
            `,
                    iconSize: [36, 36],
                    iconAnchor: [18, 18]
                })
            });

            // ✅ ARMAZENAR DADOS
            marker.wazeData = {
                ...alert,
                icone: `<i class="bi ${cfg.icon}"></i>`,
                cor: cfg.color,
                título: cfg.título
            };

            // ✅ EVENTO DE CLIQUE
            marker.on('click', function (e) {
                L.DomEvent.stopPropagation(e);
                showWazeModal(marker);
            });

            return marker;
        }

        function atualizarEstatisticasWaze(alerts) {
            const stats = {
                acidentes: 0,
                congestionamentos: 0
            };

            alerts.forEach(alert => {
                const tipo = alert.tipo || alert.type || '';

                if (tipo.includes('Acidente') || tipo === 'ACCIDENT') {
                    stats.acidentes++;
                } else if (tipo.includes('Congestionamento') || tipo === 'JAM') {
                    stats.congestionamentos++;
                }
            });

            const elemAcidentes = document.getElementById('waze-acidentes');
            const elemJams = document.getElementById('waze-jams');

            if (elemAcidentes) elemAcidentes.textContent = stats.acidentes;
            if (elemJams) elemJams.textContent = stats.congestionamentos;

            // console.log('Š Waze:', stats.acidentes, 'acidentes |', stats.congestionamentos, 'congestionamentos');
        }

        function toggleWazeLayer() {
            wazeVisible = !wazeVisible;

            // Atualizar status das vias
            setTimeout(() => {
                analisarViasComWaze();
            }, 1000);

            const toggleText = document.getElementById('waze-toggle-text');
            const panelText = document.getElementById('waze-panel-text');

            if (wazeVisible) {
                // Carregar e mostrar alertas
                loadWazeAlerts();

                // Iniciar atualizacao automatica
                wazeUpdateInterval = setInterval(loadWazeAlerts, 2 * 60 * 1000);

                if (toggleText) toggleText.textContent = 'Ocultar Waze';
                if (panelText) panelText.textContent = 'Ocultar Alertas';

                // console.log('… Alertas do Waze ativados');
            } else {
                // Ocultar marcadores
                wazeMarkers.forEach(marker => {
                    if (marker) mobilidadeMap.removeLayer(marker);
                });

                // Parar atualizacao
                if (wazeUpdateInterval) {
                    clearInterval(wazeUpdateInterval);
                    wazeUpdateInterval = null;
                }

                if (toggleText) toggleText.textContent = 'Waze Alerts';
                if (panelText) panelText.textContent = 'Mostrar Alertas';

                // console.log('´ Alertas do Waze ocultos');
            }
        }

        function toggleKMLLayer() {
            kmlVisible = !kmlVisible;
            const toggleText = document.getElementById('kml-toggle-text');
            const panel = document.getElementById('rotas-control-panel');
            const btn = document.getElementById('map-control-btn');

            if (kmlVisible) {
                // MOSTRAR ROTAS
                if (window.rotasClicaveis) {
                    window.rotasClicaveis.forEach(rota => {
                        if (!mobilidadeMap.hasLayer(rota)) {
                            rota.addTo(mobilidadeMap);
                        }
                    });
                }

                // MOSTRAR PAINEL E BOTÃO
                if (panel) {
                    panel.style.display = 'block';
                    panel.classList.remove('minimized');
                }
                if (btn) {
                    btn.classList.add('visible');
                }
                if (toggleText) {
                    toggleText.textContent = 'Ocultar Rotas';
                }

                console.log('✅ Rotas e painel exibidos');
            } else {
                // OCULTAR ROTAS
                if (window.rotasClicaveis) {
                    window.rotasClicaveis.forEach(rota => {
                        if (mobilidadeMap.hasLayer(rota)) {
                            mobilidadeMap.removeLayer(rota);
                        }
                    });
                }

                // OCULTAR PAINEL E BOTÃO
                if (panel) {
                    panel.classList.add('minimized');
                }
                if (btn) {
                    btn.classList.remove('visible');
                }
                if (toggleText) {
                    toggleText.textContent = 'Mostrar Rotas';
                }

                console.log('⚪ Rotas e painel ocultos');
            }

            atualizarEstatisticas();
        }



        function toggleControlPanel() {
            const panel = document.getElementById('rotas-control-panel');
            const btn = document.getElementById('panel-toggle-btn');

            panel.classList.toggle('minimized');

            if (panel.classList.contains('minimized')) {
                btn.innerHTML = '<i class="bi bi-chevron-left"></i>';
                // console.log('¦ Painel minimizado');
            } else {
                btn.innerHTML = '<i class="bi bi-chevron-right"></i>';
                // console.log('‹ Painel expandido');
            }
        }

        function toggleControlPanel() {
            const panel = document.getElementById('rotas-control-panel');
            if (panel) {
                panel.classList.toggle('minimized');
            }
        }

        function fitMapBounds() {
            if (kmlLayer && kmlVisible) {
                try {
                    mobilidadeMap.fitBounds(kmlLayer.getBounds());
                } catch (e) {
                    mobilidadeMap.setView([-22.9068, -43.1729], 11);
                }
            } else {
                mobilidadeMap.setView([-22.9068, -43.1729], 11);
            }
        }

        // ===== SISTEMA DE CORES POR HIERARQUIA =====
        const hierarquiaCores = {
            'Estrutural': '#ef4444',
            'Arterial primária': '#f59e0b',
            'Arterial secundária': '#10b981'
        };

        const filtrosAtivos = {
            'Estrutural': true,
            'Arterial primária': true,
            'Arterial secundária': true,

        };

        function aplicarCoresPorHierarquia() {
            if (!window.rotasClicaveis) return;

            console.log('🔍 Aplicando cores e filtrando...');

            const rotasParaManter = [];

            window.rotasClicaveis.forEach(rota => {
                // PEGAR TODAS AS POSSÍVEIS PROPRIEDADES
                const h1 = rota.feature.properties.Hierarquia;
                const h2 = rota.feature.properties.hierarquia;
                const h3 = rota.feature.properties['CLASSIFICACAO VIARIA'];

                // USAR A PRIMEIRA QUE EXISTIR
                const hierarquia = h1 || h2 || h3 || 'Sem classificacao';

                // SETAR NA ROTA
                rota._hierarquia = hierarquia;

                // 🚫 VERIFICAR SE É COLETORA (case-insensitive)
                const isColetora = (h1 && h1.toLowerCase() === 'coletora') ||
                    (h2 && h2.toLowerCase() === 'coletora') ||
                    (h3 && h3.toLowerCase() === 'coletora') ||
                    hierarquia.toLowerCase() === 'coletora' ||
                    hierarquia.toLowerCase() === 'sem classificacao';

                if (isColetora) {
                    // REMOVER DO MAPA
                    if (mobilidadeMap.hasLayer(rota)) {
                        mobilidadeMap.removeLayer(rota);
                    }
                    console.log('❌ Removida:', rota.feature.properties.name || rota.feature.properties.Name);
                    return; // NÃO ADICIONAR À LISTA
                }

                // ✅ APLICAR COR (APENAS SE NÃO FOR COLETORA)
                const cor = hierarquiaCores[hierarquia];

                if (cor) {
                    rota.setStyle({
                        color: cor,
                        weight: hierarquia === 'Estrutural' ? 4 : 3,
                        opacity: 0.8
                    });
                } else {
                    console.warn('⚠️ Hierarquia desconhecida:', hierarquia);
                }

                rotasParaManter.push(rota);
            });

            // ATUALIZAR O ARRAY GLOBAL
            window.rotasClicaveis = rotasParaManter;

            console.log(`✅ Rotas após filtro: ${rotasParaManter.length}`);
            atualizarEstatisticas();
        }

        function atualizarEstatisticas() {
            if (!window.rotasClicaveis) return;

            const contadores = {};
            let visiveis = 0;

            window.rotasClicaveis.forEach(rota => {
                const hierarquia = rota._hierarquia || 'Sem classificacao';

                // ❌ IGNORAR COLETORAS E SEM CLASSIFICAÇÃO NA CONTAGEM
                const hierarquiaLower = (hierarquia || '').toString().toLowerCase().trim();
                if (hierarquiaLower === 'coletora' || hierarquiaLower === 'sem classificacao') return;

                contadores[hierarquia] = (contadores[hierarquia] || 0) + 1;

                if (mobilidadeMap.hasLayer(rota)) {
                    visiveis++;
                }
            });

            const totalFiltrado = window.rotasClicaveis.filter(r => {
                const h = (r._hierarquia || '').toString().toLowerCase().trim();
                return h !== 'coletora' && h !== 'sem classificacao';
            }).length;

            document.getElementById('total-rotas').textContent = totalFiltrado;
            document.getElementById('rotas-visiveis').textContent = visiveis;

            document.getElementById('count-estrutural').textContent = (contadores['Estrutural'] || 0) + ' rotas';
            document.getElementById('count-arterial-primária').textContent = (contadores['Arterial primária'] || 0) + ' rotas';
            document.getElementById('count-arterial-secundária').textContent = (contadores['Arterial secundária'] || 0) + ' rotas';

            document.getElementById('legend-estrutural').textContent = contadores['Estrutural'] || 0;
            document.getElementById('legend-arterial-primária').textContent = contadores['Arterial primária'] || 0;
            document.getElementById('legend-arterial-secundária').textContent = contadores['Arterial secundária'] || 0;

            document.getElementById('rotas-badge').textContent = visiveis;
        }

        function toggleHierarquia(hierarquia) {
            filtrosAtivos[hierarquia] = !filtrosAtivos[hierarquia];

            const toggleId = 'toggle-' + hierarquia.toLowerCase().replace(' ', '-');
            const toggleElement = document.getElementById(toggleId);

            if (filtrosAtivos[hierarquia]) {
                toggleElement.classList.add('active');
            } else {
                toggleElement.classList.remove('active');
            }

            window.rotasClicaveis.forEach(rota => {
                if (rota._hierarquia === hierarquia) {
                    if (filtrosAtivos[hierarquia]) {
                        rota.addTo(mobilidadeMap);
                    } else {
                        mobilidadeMap.removeLayer(rota);
                    }
                }
            });

            atualizarEstatisticas();
        }

        function mostrarTodasRotas() {
            Object.keys(filtrosAtivos).forEach(h => filtrosAtivos[h] = true);

            window.rotasClicaveis.forEach(rota => {
                rota.addTo(mobilidadeMap);
            });

            ['estrutural', 'arterial-primária', 'arterial-secundária', 'coletora'].forEach(id => {
                document.getElementById('toggle-' + id).classList.add('active');
            });

            atualizarEstatisticas();
            // console.log('… Todas as rotas visiveis');
        }

        function ocultarTodasRotas() {
            Object.keys(filtrosAtivos).forEach(h => filtrosAtivos[h] = false);

            window.rotasClicaveis.forEach(rota => {
                mobilidadeMap.removeLayer(rota);
            });

            ['estrutural', 'arterial-primária', 'arterial-secundária', 'coletora'].forEach(id => {
                document.getElementById('toggle-' + id).classList.remove('active');
            });

            atualizarEstatisticas();
            // console.log('´ Todas as rotas ocultas');
        }

        function resetarCores() {
            aplicarCoresPorHierarquia();
        }

        function centralizarTodasRotas() {
            if (kmlLayer) {
                try {
                    mobilidadeMap.fitBounds(kmlLayer.getBounds());
                } catch (e) {
                    mobilidadeMap.setView([-22.9068, -43.1729], 11);
                }
            }
        }

        function redesenharMarcadores() {
            // console.log('„ Redesenhando marcadores...');

            // Limpar todos os marcadores antigos
            marcadoresTemporarios.forEach(m => {
                try {
                    if (m && mobilidadeMap.hasLayer(m)) {
                        // Remover todos os eventos antes
                        if (m.off) {
                            m.off();
                        }
                        mobilidadeMap.removeLayer(m);
                    }
                } catch (e) {
                    console.warn('Erro ao remover marcador:', e);
                }
            });
            marcadoresTemporarios = [];

            // Criar novos marcadores para cada ponto
            pontosChave.forEach((ponto, index) => {
                // Validacao rigorosa
                if (!ponto ||
                    typeof ponto.lat !== 'number' ||
                    typeof ponto.lng !== 'number' ||
                    isNaN(ponto.lat) ||
                    isNaN(ponto.lng)) {
                    console.warn('Ponto invalido no indice', index);
                    return;
                }

                try {
                    // Circulo visual
                    const circleMarker = L.circleMarker([ponto.lat, ponto.lng], {
                        radius: 8,
                        color: '#ffffff',
                        fillColor: '#ef4444',
                        fillOpacity: 1,
                        weight: 3
                    }).addTo(mobilidadeMap);

                    // Marcador arrastavel com numero
                    const numeroDiv = L.divIcon({
                        className: 'ponto-numero',
                        html: `<div style="
                    background: #ef4444;
                    color: white;
                    width: 28px;
                    height: 28px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    font-size: 14px;
                    border: 3px solid white;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
                    cursor: move;
                ">${index + 1}</div>`,
                        iconSize: [28, 28],
                        iconAnchor: [14, 14]
                    });

                    const numeroMarker = L.marker([ponto.lat, ponto.lng], {
                        icon: numeroDiv,
                        draggable: true
                    }).addTo(mobilidadeMap);

                    // Armazenar referAªncia ao indice
                    numeroMarker._pontoIndex = index;
                    numeroMarker._circleMarker = circleMarker;

                    // ===== EVENTO DE ARRASTAR =====
                    numeroMarker.on('drag', function (e) {
                        const newLatLng = e.target.getLatLng();
                        const idx = numeroMarker._pontoIndex;

                        if (idx >= 0 && idx < pontosChave.length) {
                            pontosChave[idx] = {
                                lat: newLatLng.lat,
                                lng: newLatLng.lng
                            };

                            // Atualizar circulo visual
                            if (numeroMarker._circleMarker) {
                                numeroMarker._circleMarker.setLatLng(newLatLng);
                            }
                        }
                    });

                    // ===== EVENTO DRAGEND (RECALCULAR) =====
                    numeroMarker.on('dragend', async function (e) {
                        // console.log('¯ Ponto arrastado - recalculando...');
                        await recalcularRota();
                    });

                    // ===== DUPLO-CLIQUE PARA REMOVER =====
                    numeroMarker.on('dblclick', function (e) {
                        L.DomEvent.stopPropagation(e);

                        const idx = numeroMarker._pontoIndex;

                        if (confirm(`Remover ponto ${idx + 1}?`)) {
                            // console.log('‘ Removendo ponto', idx + 1);

                            // Remover do array
                            pontosChave.splice(idx, 1);

                            // console.log('… Ponto removido. Restam:', pontosChave.length);

                            // Redesenhar tudo
                            redesenharMarcadores();

                            // Recalcular rota
                            if (pontosChave.length >= 2) {
                                recalcularRota();
                            } else if (pontosChave.length < 2) {
                                // Remover linha
                                if (linhaTemporaria) {
                                    mobilidadeMap.removeLayer(linhaTemporaria);
                                    linhaTemporaria = null;
                                }
                                pontosDesenho = [];
                            }
                        }
                    });

                    marcadoresTemporarios.push(circleMarker, numeroMarker);

                } catch (err) {
                    console.error('<i class="bi bi-x-circle-fill"></i> Erro ao criar marcador', index, ':', err);
                }
            });

            // console.log(icone: '<i class="bi bi-check-circle-fill"></i>', pontosChave.length, 'marcadores redesenhados');
        }

        // ===== ANALISE DE TRA‚NSITO EM ROTAS =====

        function analisartransitoNaRota(layer) {
            // console.log('');
            // console.log(' ANALISANDO TRA‚NSITO NA ROTA');
            // console.log('');

            // console.log('wazeMarkers existe?', !!wazeMarkers);
            // console.log('wazeMarkers.length:', wazeMarkers ? wazeMarkers.length : 0);
            // console.log('wazeVisible:', wazeVisible);

            if (!wazeMarkers || wazeMarkers.length === 0) {
                // console.log('<i class="bi bi-x-circle-fill"></i> Nenhum dado do Waze carregado');
                return null;
            }

            const latlngs = layer.getLatLngs();
            // console.log('Pontos da rota:', latlngs.length);

            if (!latlngs || latlngs.length === 0) {
                // console.log('<i class="bi bi-x-circle-fill"></i> Rota sem pontos');
                return null;
            }

            // Estatísticas
            const Análise = {
                acidentes: 0,
                congestionamentos: 0,
                perigos: 0,
                outros: 0,
                velocidades: [],
                velocidadeMédia: null,
                NívelCongestionamento: 0,
                alertaspróximos: [],
                DistânciaTotal: 0
            };

            // Calcular Distância total da rota
            for (let i = 0; i < latlngs.length - 1; i++) {
                Análise.DistânciaTotal += mobilidadeMap.distance(latlngs[i], latlngs[i + 1]);
            }
            Análise.DistânciaTotal = (Análise.DistânciaTotal / 1000).toFixed(2);

            // console.log(' Distância total da rota:', Análise.DistânciaTotal, 'km');

            // Raio de busca (200 metros)
            const raioMetros = 200;
            // console.log('¯ Raio de busca:', raioMetros, 'metros');

            let marcadoresVerificados = 0;
            let marcadorespróximos = 0;

            // Verificar cada marcador do Waze
            wazeMarkers.forEach((marker, index) => {
                if (!marker || !marker.wazeData) {
                    console.log(`  Marcador ${index} sem dados`);
                    return;
                }

                marcadoresVerificados++;

                const markerLatLng = marker.getLatLng();
                let menorDistância = Infinity;

                // Calcular Distância minima do marcador ate a rota
                latlngs.forEach(ponto => {
                    const Distância = mobilidadeMap.distance(markerLatLng, ponto);
                    if (Distância < menorDistância) {
                        menorDistância = Distância;
                    }
                });

                // Se estiver próximo
                if (menorDistância <= raioMetros) {
                    marcadorespróximos++;

                    const data = marker.wazeData;
                    const tipo = data.tipo || data.type || '';

                    console.log(`… [${marcadorespróximos}] Alerta próximo:`, tipo, `(${Math.round(menorDistância)}m)`);

                    // Contar por tipo
                    if (tipo.includes('Acidente') || tipo === 'ACCIDENT') {
                        Análise.acidentes++;
                    } else if (tipo.includes('Congestionamento') || tipo === 'JAM') {
                        Análise.congestionamentos++;

                        if (data.velocidade !== undefined) {
                            Análise.velocidades.push(data.velocidade);
                            // console.log('  Š Velocidade:', data.velocidade, 'km/h');
                        }

                        if (data.Nível !== undefined) {
                            Análise.NívelCongestionamento += data.Nível;
                            // console.log('  ¦ Nível:', data.Nível);
                        }
                    } else if (tipo.includes('Perigo') || tipo === 'HAZARD' || tipo === 'WEATHERHAZARD' || tipo === 'ROAD_CLOSED') {
                        Análise.perigos++;
                    } else {
                        Análise.outros++;
                    }

                    // Guardar alerta
                    Análise.alertaspróximos.push({
                        tipo: data.título,
                        icone: data.icone,
                        cor: data.cor,
                        rua: data.rua || data.street || 'Via não identificada',
                        Distância: Math.round(menorDistância)
                    });
                }
            });

            // console.log('Š Marcadores verificados:', marcadoresVerificados);
            // console.log(' Marcadores próximos:', marcadorespróximos);

            // Calcular velocidade Média
            if (Análise.velocidades.length > 0) {
                const soma = Análise.velocidades.reduce((a, b) => a + b, 0);
                Análise.velocidadeMédia = Math.round((soma / Análise.velocidades.length) * 10) / 10;
                // console.log('— Velocidade Média:', Análise.velocidadeMédia, 'km/h');
            }

            // Calcular Nível medio
            if (Análise.congestionamentos > 0) {
                Análise.NívelCongestionamento = Math.round(Análise.NívelCongestionamento / Análise.congestionamentos);
            }

            Análise.totalAlertas = Análise.acidentes + Análise.congestionamentos + Análise.perigos + Análise.outros;

            // console.log('');
            // console.log('Š RESUMO DA ANALISE:');
            // console.log('   Total de alertas:', Análise.totalAlertas);
            // console.log('   ¨ Acidentes:', Análise.acidentes);
            // console.log('   — Congestionamentos:', Análise.congestionamentos);
            // console.log('     Perigos:', Análise.perigos);
            // console.log('    Outros:', Análise.outros);
            // console.log('   ™ Velocidade Média:', Análise.velocidadeMédia);
            // console.log('');

            return Análise;
        }

        function getStatustransito(Análise) {
            if (!Análise || Análise.totalAlertas === 0) {
                return {
                    Nível: 0,
                    texto: 'Sem InformacAµes',
                    cor: '#64748b',
                    icone: '“',
                    badge: 'info'
                };
            }

            // Baseado em velocidade Média
            if (Análise.velocidadeMédia !== null) {
                if (Análise.velocidadeMédia < 10) {
                    return {
                        Nível: 4,
                        texto: 'transito Parado',
                        cor: '#dc2626',
                        icone: '<i class="bi bi-exclamation-octagon-fill"></i>',
                        badge: 'danger'
                    };
                } else if (Análise.velocidadeMédia < 20) {
                    return {
                        Nível: 3,
                        texto: 'transito Intenso',
                        cor: '#ef4444',
                        icone: '—',
                        badge: 'danger'
                    };
                } else if (Análise.velocidadeMédia < 40) {
                    return {
                        Nível: 2,
                        texto: 'transito Moderado',
                        cor: '#f59e0b',
                        icone: '™',
                        badge: 'warning'
                    };
                } else {
                    return {
                        Nível: 1,
                        texto: 'transito Fluindo',
                        cor: '#10b981',
                        icone: '<i class="bi bi-check-circle-fill"></i>',
                        badge: 'success'
                    };
                }
            }

            // Baseado em congestionamentos
            if (Análise.congestionamentos >= 3) {
                return {
                    Nível: 3,
                    texto: 'transito Intenso',
                    cor: '#ef4444',
                    icone: '—',
                    badge: 'danger'
                };
            } else if (Análise.congestionamentos >= 1) {
                return {
                    Nível: 2,
                    texto: 'transito Moderado',
                    cor: '#f59e0b',
                    icone: '™',
                    badge: 'warning'
                };
            }

            // Baseado em acidentes
            if (Análise.acidentes >= 1) {
                return {
                    Nível: 3,
                    texto: 'Atencao - Acidente',
                    cor: '#ef4444',
                    icone: '¨',
                    badge: 'danger'
                };
            }

            return {
                Nível: 1,
                texto: 'transito Normal',
                cor: '#10b981',
                icone: '<i class="bi bi-check-circle-fill"></i>',
                badge: 'success'
            };
        }

        function getStatustransito(Análise) {
            if (!Análise || Análise.totalAlertas === 0) {
                return {
                    Nível: 0,
                    texto: 'Sem InformacAµes',
                    cor: '#64748b',
                    icone: '“',
                    badge: 'info'
                };
            }

            // Baseado em velocidade Média
            if (Análise.velocidadeMédia !== null) {
                if (Análise.velocidadeMédia < 10) {
                    return {
                        Nível: 4,
                        texto: 'transito Parado',
                        cor: '#dc2626',
                        icone: '<i class="bi bi-exclamation-octagon-fill"></i>',
                        badge: 'danger'
                    };
                } else if (Análise.velocidadeMédia < 20) {
                    return {
                        Nível: 3,
                        texto: 'transito Intenso',
                        cor: '#ef4444',
                        icone: '—',
                        badge: 'danger'
                    };
                } else if (Análise.velocidadeMédia < 40) {
                    return {
                        Nível: 2,
                        texto: 'transito Moderado',
                        cor: '#f59e0b',
                        icone: '™',
                        badge: 'warning'
                    };
                } else {
                    return {
                        Nível: 1,
                        texto: 'transito Fluindo',
                        cor: '#10b981',
                        icone: '<i class="bi bi-check-circle-fill"></i>',
                        badge: 'success'
                    };
                }
            }

            // Baseado em numero de congestionamentos
            if (Análise.congestionamentos >= 3) {
                return {
                    Nível: 3,
                    texto: 'transito Intenso',
                    cor: '#ef4444',
                    icone: '—',
                    badge: 'danger'
                };
            } else if (Análise.congestionamentos >= 1) {
                return {
                    Nível: 2,
                    texto: 'transito Moderado',
                    cor: '#f59e0b',
                    icone: '™',
                    badge: 'warning'
                };
            }

            // Baseado em acidentes
            if (Análise.acidentes >= 1) {
                return {
                    Nível: 3,
                    texto: 'Atencao - Acidente',
                    cor: '#ef4444',
                    icone: '¨',
                    badge: 'danger'
                };
            }

            // Padrao: OK
            return {
                Nível: 1,
                texto: 'transito Normal',
                cor: '#10b981',
                icone: '<i class="bi bi-check-circle-fill"></i>',
                badge: 'success'
            };
        }

        function showRotaModal(layer) {

            // ===== DEBUG =====
            // console.log('');
            // console.log('‹ ABRINDO MODAL DA ROTA');
            // console.log('');
            // console.log('Layer:', layer);
            // console.log('Layer type:', layer instanceof L.Polyline);
            // console.log('LatLngs:', layer.getLatLngs ? layer.getLatLngs() : 'N/A');
            selectedRotaLayer = layer;

            layer.setStyle({
                color: '#fbbf24',
                weight: 5,
                opacity: 1
            });

            const properties = layer.feature.properties || {};
            const nome = properties.name || 'Rota sem identificacao';
            const trecho = properties.Trecho || properties.trecho || '';
            const hierarquia = properties.Hierarquia || properties.hierarquia || '';

            let distance = 0;
            const latlngs = layer.getLatLngs();
            if (latlngs && latlngs.length > 1) {
                for (let i = 0; i < latlngs.length - 1; i++) {
                    distance += latlngs[i].distanceTo(latlngs[i + 1]);
                }
            }
            distance = (distance / 1000).toFixed(2);

            const hierarquiaCoresModal = {
                'Estrutural': { cor: '#ef4444', icon: 'bi-lightning-charge-fill' },
                'Arterial primária': { cor: '#f59e0b', icon: 'bi-diagram-3-fill' },
                'Arterial secundária': { cor: '#10b981', icon: 'bi-diagram-2-fill' },

            };

            const hierarquiaInfo = hierarquiaCoresModal[hierarquia] || { cor: '#64748b', icon: 'bi-question-circle-fill' };

            document.getElementById('rota-modal-title').textContent = nome;

            let content = `
                <div class="rota-info-item">
                    <div class="rota-info-label">
                        <i class="bi bi-signpost-2-fill"></i>
                        Nome da Via
                    </div>
                    <div class="rota-info-value" style="font-size: 18px; font-weight: 600;">${nome}</div>
                </div>
            `;

            if (hierarquia) {
                content += `
                    <div class="rota-info-item" style="border-left: 4px solid ${hierarquiaInfo.cor};">
                        <div class="rota-info-label">
                            <i class="${hierarquiaInfo.icon}" style="color: ${hierarquiaInfo.cor};"></i>
                            Classificacao Viaria
                        </div>
                        <div class="rota-info-value" style="color: ${hierarquiaInfo.cor}; font-weight: 600;">
                            ${hierarquia}
                        </div>
                    </div>
                `;
            }

            if (trecho && trecho.trim() !== '') {
                content += `
                    <div class="rota-info-item">
                        <div class="rota-info-label">
                            <i class="bi bi-geo-alt-fill"></i>
                            Trecho
                        </div>
                        <div class="rota-info-value">${trecho}</div>
                    </div>
                `;
            }

            content += `
                <div class="rota-stats">
                    <div class="rota-stat-card">
                        <div class="rota-stat-value">${distance}</div>
                        <div class="rota-stat-label">Km de Extensão</div>
                    </div>
                    <div class="rota-stat-card">
                        <div class="rota-stat-value">${latlngs.length}</div>
                        <div class="rota-stat-label">Pontos no Tracado</div>
                    </div>
                </div>
            `;

            // ===== — ANALISE DE TRA‚NSITO WAZE =====
            const Análise = analisartransitoNaRota(layer);

            if (Análise && Análise.totalAlertas > 0) {
                const status = getStatustransito(Análise);

                content += `
                    <div class="rota-info-item" style="background: linear-gradient(135deg, ${status.cor}20 0%, ${status.cor}10 100%); border: 2px solid ${status.cor}40; margin-top: 16px;">
                        <div class="rota-info-label" style="color: ${status.cor};">
                            <i class="bi bi-exclamation-triangle-fill"></i>
                            CondicAµes de transito (Waze)
                        </div>
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <span style="font-size: 32px;">${status.icone}</span>
                            <div>
                                <div style="font-size: 18px; font-weight: 700; color: ${status.cor};">
                                    ${status.texto}
                                </div>
                                <div style="font-size: 13px; color: #94a3b8; margin-top: 4px;">
                                    ${Análise.totalAlertas} alerta(s) detectado(s) nesta via
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                // Estatísticas detalhadas
                content += `<div class="rota-stats" style="margin-top: 12px;">`;

                if (Análise.velocidadeMédia !== null) {
                    content += `
                        <div class="rota-stat-card" style="border-color: ${status.cor};">
                            <div class="rota-stat-value" style="color: ${status.cor};">${Análise.velocidadeMédia}</div>
                            <div class="rota-stat-label">— Velocidade Média (km/h)</div>
                        </div>
                    `;
                }

                if (Análise.acidentes > 0) {
                    content += `
                        <div class="rota-stat-card" style="border-color: #ef4444;">
                            <div class="rota-stat-value" style="color: #ef4444;">${Análise.acidentes}</div>
                            <div class="rota-stat-label">¨ Acidente(s)</div>
                        </div>
                    `;
                }

                if (Análise.congestionamentos > 0) {
                    content += `
                        <div class="rota-stat-card" style="border-color: #f59e0b;">
                            <div class="rota-stat-value" style="color: #f59e0b;">${Análise.congestionamentos}</div>
                            <div class="rota-stat-label">— Congestionamento(s)</div>
                        </div>
                    `;
                }

                if (Análise.perigos > 0) {
                    content += `
                        <div class="rota-stat-card" style="border-color: #f59e0b;">
                            <div class="rota-stat-value" style="color: #f59e0b;">${Análise.perigos}</div>
                            <div class="rota-stat-label">  Perigo(s) na Via</div>
                        </div>
                    `;
                }

                content += `</div>`;

                // Listar alertas próximos (maximo 5)
                if (Análise.alertaspróximos.length > 0) {
                    content += `
                        <div class="rota-info-item" style="margin-top: 16px;">
                            <div class="rota-info-label">
                                <i class="bi bi-list-ul"></i>
                                Alertas próximos
                            </div>
                            <div style="margin-top: 12px;">
                    `;

                    Análise.alertaspróximos.slice(0, 5).forEach(alerta => {
                        content += `
                            <div style="
                                padding: 8px 12px;
                                background: rgba(255,255,255,0.05);
                                border-left: 3px solid ${alerta.cor};
                                border-radius: 4px;
                                margin-bottom: 8px;
                                font-size: 13px;
                            ">
                                <span style="font-size: 16px;">${alerta.icone}</span>
                                <strong>${alerta.tipo}</strong>
                                ${alerta.rua ? `<br><span style="color: #94a3b8;"> ${alerta.rua}</span>` : ''}
                                <br><span style="color: #64748b; font-size: 11px;">” ${alerta.Distância}m da rota</span>
                            </div>
                        `;
                    });

                    if (Análise.alertaspróximos.length > 5) {
                        content += `
                            <div style="text-align: center; color: #64748b; font-size: 12px; margin-top: 8px;">
                                + ${Análise.alertaspróximos.length - 5} alertas adicionais
                            </div>
                        `;
                    }

                    content += `
                            </div>
                        </div>
                    `;
                }

            } else if (wazeVisible && wazeMarkers.length > 0) {
                content += `
                    <div class="rota-info-item" style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); margin-top: 16px;">
                        <div class="rota-info-label" style="color: #10b981;">
                            <i class="bi bi-check-circle-fill"></i>
                            CondicAµes de transito (Waze)
                        </div>
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <span style="font-size: 32px;">…</span>
                            <div>
                                <div style="font-size: 18px; font-weight: 700; color: #10b981;">
                                    transito Normal
                                </div>
                                <div style="font-size: 13px; color: #94a3b8; margin-top: 4px;">
                                    Nenhum alerta detectado nesta via
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                content += `
                    <div class="rota-info-item" style="background: rgba(100, 116, 139, 0.1); border: 1px solid rgba(100, 116, 139, 0.3); margin-top: 16px;">
                        <div class="rota-info-label" style="color: #64748b;">
                            <i class="bi bi-info-circle-fill"></i>
                            Dados de transito
                        </div>
                        <div style="font-size: 13px; color: #94a3b8; margin-top: 8px;">
                            Ative os alertas do Waze para ver condicAµes de transito em tempo real
                        </div>
                    </div>
                `;
            }

            document.getElementById('rota-modal-body').innerHTML = content;
            document.getElementById('rota-modal').classList.add('active');
        }

        function closeRotaModal() {
            document.getElementById('rota-modal').classList.remove('active');

            if (selectedRotaLayer) {
                const hierarquia = selectedRotaLayer._hierarquia || 'Sem classificacao';
                const cor = hierarquiaCores[hierarquia] || '#f59e0b';
                selectedRotaLayer.setStyle({
                    color: cor,
                    weight: hierarquia === 'Estrutural' ? 4 : 3,
                    opacity: 0.8
                });
                selectedRotaLayer = null;
            }
        }

        function centerRotaOnMap() {
            if (selectedRotaLayer) {
                try {
                    mobilidadeMap.fitBounds(selectedRotaLayer.getBounds(), {
                        padding: [50, 50]
                    });
                } catch (e) {
                    // console.log('Não foi possivel centralizar');
                }
            }
        }

        document.addEventListener('click', function (e) {
            const modal = document.getElementById('rota-modal');
            if (e.target === modal) {
                closeRotaModal();
            }
        });

        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                closeRotaModal();
            }
        });


        // ===== SISTEMA DE ROTEAMENTO E DESENHO =====
        let modoAtual = 'automatico';
        let coordOrigem = null;
        let coordDestino = null;
        // marcadorOrigem e marcadorDestino já declarados acima
        let rotaAutomatica = null;

        function iniciarDesenhoRota() {
            if (!kmlVisible) {
                alert(' Ative a visualizacao de rotas primeiro clicando em "Mostrar Rotas"');
                return;
            }

            // Abrir modal e GARANTIR QUE display SEJA FLEX
            const modal = document.getElementById('nova-rota-modal');
            modal.style.display = ''; // … REMOVER display inline
            modal.classList.add('active');

            // Resetar para modo automatico
            modoAtual = 'automatico';
            mudarModo('automatico');

            // console.log('‹ Modal de nova rota aberto');
        }

        function mudarModo(modo) {
            modoAtual = modo;

            // console.log('„ Mudando para modo:', modo);

            // Se escolheu modo manual, FECHAR MODAL E INICIAR DESENHO
            if (modo === 'manual') {
                // console.log('¨ Modo manual selecionado - fechando modal e iniciando desenho');

                // Fechar modal iMédiatamente
                const modal = document.getElementById('nova-rota-modal');
                modal.classList.remove('active');
                modal.style.display = 'none';

                // Aguardar um pouco e iniciar desenho
                setTimeout(() => {
                    iniciarDesenhoManual();
                }, 300);

                return; // … SAIR DA FUNA‡AƒO
            }

            // Se for modo automatico, continuar normalmente
            document.getElementById('tab-automatico').classList.toggle('active', modo === 'automatico');
            document.getElementById('tab-manual').classList.toggle('active', modo === 'manual');

            document.getElementById('modo-automatico').classList.toggle('active', modo === 'automatico');
            document.getElementById('modo-manual').classList.toggle('active', modo === 'manual');

            // console.log('… Modo alterado para:', modo);
        }

        async function buscarEndereço(tipo) {
            const input = tipo === 'origem' ? 'rota-origem' : 'rota-destino';
            const Endereço = document.getElementById(input).value.trim();

            if (!Endereço) {
                alert('  Digite um Endereço!');
                return;
            }

            try {
                // Usar Nominatim do OpenStreetMap (gratuito)
                const url = `https://nominatim.openstreetmap.org/search?` +
                    `format=json&q=${encodeURIComponent(Endereço)}&` +
                    `countrycodes=br&limit=1&` +
                    `viewbox=-43.7963,-23.0828,-43.1015,-22.7460&bounded=1`;

                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'SISCOR-Mobilidade/1.0'
                    }
                });

                const data = await response.json();

                if (data.length === 0) {
                    alert('<i class="bi bi-x-circle-fill"></i> Endereço Não encontrado! Tente ser mais especifico.');
                    return;
                }

                const lat = parseFloat(data[0].lat);
                const lon = parseFloat(data[0].lon);

                if (tipo === 'origem') {
                    coordOrigem = [lat, lon];

                    // Remover marcador anterior
                    if (marcadorOrigem) mobilidadeMap.removeLayer(marcadorOrigem);

                    // Adicionar marcador verde
                    marcadorOrigem = L.marker([lat, lon], {
                        icon: L.divIcon({
                            className: 'marker-origem',
                            html: '<i class="bi bi-geo-alt-fill"></i>',
                            iconSize: [30, 30]
                        })
                    }).addTo(mobilidadeMap);

                    // console.log('… Origem definida:', data[0].display_name);
                } else {
                    coordDestino = [lat, lon];

                    // Remover marcador anterior
                    if (marcadorDestino) mobilidadeMap.removeLayer(marcadorDestino);

                    // Adicionar marcador vermelho
                    marcadorDestino = L.marker([lat, lon], {
                        icon: L.divIcon({
                            className: 'marker-destino',
                            html: '<i class="bi bi-flag-fill"></i>',
                            iconSize: [30, 30]
                        })
                    }).addTo(mobilidadeMap);

                    // console.log('… Destino definido:', data[0].display_name);
                }

                // Centralizar mapa
                mobilidadeMap.setView([lat, lon], 14);

            } catch (error) {
                console.error('Erro ao buscar Endereço:', error);
                alert('<i class="bi bi-x-circle-fill"></i> Erro ao buscar Endereço. Tente novamente.');
            }
        }

        async function calcularRotaAutomatica() {
            if (!coordOrigem || !coordDestino) {
                alert(' Defina a origem e o destino primeiro!');
                return;
            }

            try {
                // Usar OSRM (Open Source Routing Machine) - gratuito
                const url = `https://router.project-osrm.org/route/v1/driving/` +
                    `${coordOrigem[1]},${coordOrigem[0]};${coordDestino[1]},${coordDestino[0]}?` +
                    `overview=full&geometries=geojson`;

                const response = await fetch(url);
                const data = await response.json();

                if (data.code !== 'Ok') {
                    alert('<i class="bi bi-x-circle-fill"></i> Não foi possivel calcular a rota!');
                    return;
                }

                const route = data.routes[0];
                const coords = route.geometry.coordinates.map(c => [c[1], c[0]]);

                // Remover rota anterior
                if (rotaAutomatica) mobilidadeMap.removeLayer(rotaAutomatica);

                // Desenhar rota
                rotaAutomatica = L.polyline(coords, {
                    color: '#3b82f6',
                    weight: 5,
                    opacity: 0.7
                }).addTo(mobilidadeMap);

                // Salvar pontos para uso posterior
                pontosDesenho = coords;

                // Mostrar informacAµes
                const Distância = (route.distance / 1000).toFixed(2);
                const tempo = Math.round(route.duration / 60);

                document.getElementById('rota-Distância').textContent = Distância + ' km';
                document.getElementById('rota-tempo').textContent = tempo + ' min';
                document.getElementById('rota-info').style.display = 'block';
                document.getElementById('dados-rota').style.display = 'block';
                document.getElementById('btn-salvar-rota').style.display = 'flex';

                // Ajustar zoom
                mobilidadeMap.fitBounds(rotaAutomatica.getBounds(), { padding: [50, 50] });

                // console.log('… Rota calculada:', Distância, 'km', tempo, 'min');

            } catch (error) {
                console.error('Erro ao calcular rota:', error);
                alert('<i class="bi bi-x-circle-fill"></i> Erro ao calcular rota. Tente novamente.');
            }
        }

        function iniciarDesenhoManual() {
            // console.log('¨ INICIANDO DESENHO MANUAL COM SNAP-TO-ROAD');

            limparDesenhoTemporario();
            pontosDesenho = [];
            pontosChave = []; // Array para pontos-chave
            marcadoresTemporarios = [];
            linhaTemporaria = null;

            mobilidadeMap.off('click');

            desenhoModeAtivo = true;

            document.getElementById('desenho-indicator').classList.add('active');
            document.getElementById('desenho-controls').classList.add('active');
            document.getElementById('mobilidade-map').style.cursor = 'crosshair';

            document.querySelector('#desenho-indicator span').textContent =
                '¯ Clique no mapa para adicionar pontos ¢ Arraste os pontos para ajustar';

            mobilidadeMap.on('click', async function (e) {
                const latlng = e.latlng;

                // ===== ROTAS ALTERNATIVAS =====
                if (modoSelecao) {
                    if (modoSelecao === 'origem') {
                        pontoOrigem = latlng;

                        if (marcadorOrigem) {
                            mobilidadeMap.removeLayer(marcadorOrigem);
                        }

                        marcadorOrigem = L.marker(latlng, {
                            icon: L.divIcon({
                                className: 'marcador-origem',
                                html: '<i class="bi bi-geo-alt-fill"></i>',
                                iconSize: [40, 40]
                            })
                        }).addTo(mobilidadeMap);

                        document.getElementById('input-origem').value = `📍 ${latlng.lat.toFixed(5)}, ${latlng.lng.toFixed(5)}`;
                        document.getElementById('input-origem').style.borderColor = 'rgba(16, 185, 129, 0.3)';

                    } else if (modoSelecao === 'destino') {
                        pontoDestino = latlng;

                        if (marcadorDestino) {
                            mobilidadeMap.removeLayer(marcadorDestino);
                        }

                        marcadorDestino = L.marker(latlng, {
                            icon: L.divIcon({
                                className: 'marcador-destino',
                                html: '<i class="bi bi-geo-fill"></i>',
                                iconSize: [40, 40]
                            })
                        }).addTo(mobilidadeMap);

                        document.getElementById('input-destino').value = `📍 ${latlng.lat.toFixed(5)}, ${latlng.lng.toFixed(5)}`;
                        document.getElementById('input-destino').style.borderColor = 'rgba(239, 68, 68, 0.3)';
                    }

                    modoSelecao = null;
                    mobilidadeMap.getContainer().style.cursor = '';

                    if (pontoOrigem && pontoDestino) {
                        document.getElementById('btn-calcular-rotas').disabled = false;
                        document.getElementById('btn-calcular-rotas').style.opacity = '1';
                        document.getElementById('btn-calcular-rotas').style.cursor = 'pointer';
                    }

                    return; // Não continuar para desenho
                }

                // ===== DESENHO (código original) =====
                if (!desenhoModeAtivo) return;

                // ... resto do código de desenho continua aqui
            });

            // console.log('… Modo de desenho ativo');
        }

        function adicionarMarcadorArrastavel(latlng, index) {
            // Marcador arrastavel
            const marcador = L.marker(latlng, {
                draggable: true,
                icon: L.divIcon({
                    className: 'ponto-marcador',
                    html: `<div style="
                        background: #ef4444;
                        color: white;
                        width: 32px;
                        height: 32px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: bold;
                        font-size: 16px;
                        border: 3px solid white;
                        box-shadow: 0 3px 10px rgba(0,0,0,0.5);
                        cursor: move;
                    ">${index + 1}</div>`,
                    iconSize: [32, 32],
                    iconAnchor: [16, 16]
                })
            }).addTo(mobilidadeMap);

            // Guardar indice
            marcador._idx = index;

            // Atualizar posicao ao arrastar
            marcador.on('drag', function (e) {
                const marker = e.target;
                const pos = marker.getLatLng();
                pontosDesenho[marker._idx] = pos;
                atualizarLinha();
            });

            // Duplo-clique remove
            marcador.on('dblclick', function (e) {
                L.DomEvent.stopPropagation(e);
                if (confirm('Remover este ponto?')) {
                    removerPonto(marcador._idx);
                }
            });

            marcadoresTemporarios.push(marcador);
        }

        function atualizarLinha() {
            if (linhaTemporaria) {
                mobilidadeMap.removeLayer(linhaTemporaria);
            }

            if (pontosDesenho.length > 1) {
                linhaTemporaria = L.polyline(pontosDesenho, {
                    color: '#3b82f6',
                    weight: 6,
                    opacity: 0.8
                }).addTo(mobilidadeMap);
            }
        }

        function removerPonto(index) {
            pontosDesenho.splice(index, 1);

            // Limpar e redesenhar tudo
            marcadoresTemporarios.forEach(m => mobilidadeMap.removeLayer(m));
            marcadoresTemporarios = [];

            pontosDesenho.forEach((pt, i) => {
                adicionarMarcadorArrastavel(pt, i);
            });

            atualizarLinha();

            // console.log('‘ Ponto removido. Restam:', pontosDesenho.length);
        }

        function desfazerPonto() {
            if (pontosChave.length === 0) {
                alert(' Nenhum ponto para desfazer!');
                return;
            }

            pontosChave.pop();

            // console.log('© Desfeito. Restam:', pontosChave.length);

            // Redesenhar tudo
            redesenharMarcadores();

            // Recalcular rota
            if (pontosChave.length >= 2) {
                recalcularRota();
            } else {
                // Remover linha se menos de 2 pontos
                if (linhaTemporaria) {
                    mobilidadeMap.removeLayer(linhaTemporaria);
                    linhaTemporaria = null;
                }
                pontosDesenho = [];
            }
        }

        function finalizarDesenho() {
            // console.log(' FINALIZANDO');

            if (pontosDesenho.length < 2) {
                alert(' Adicione pelo menos 2 pontos!');
                return;
            }

            desenhoModeAtivo = false;
            document.getElementById('mobilidade-map').style.cursor = '';
            document.getElementById('desenho-indicator').classList.remove('active');
            document.getElementById('desenho-controls').classList.remove('active');

            mobilidadeMap.off('click');

            let DistânciaTotal = 0;
            for (let i = 0; i < pontosDesenho.length - 1; i++) {
                DistânciaTotal += mobilidadeMap.distance(pontosDesenho[i], pontosDesenho[i + 1]);
            }
            const DistânciaKm = (DistânciaTotal / 1000).toFixed(2);

            const nome = prompt(' Nome da rota:');
            if (!nome) {
                cancelarDesenho();
                return;
            }

            const hierarquia = prompt('Š Hierarquia:\n\nEstruturalArterial primária\nArterial secundária\nColetora\n\nDigite:') || 'Coletora';

            salvarRotaDesenhada(nome, hierarquia);
        }

        function salvarRotaDesenhada(nome, hierarquia) {
            const cor = hierarquiaCores[hierarquia] || '#10b981';
            const rotaId = Date.now();

            // Criar rota permanente
            const novaRota = L.polyline(pontosDesenho, {
                color: cor,
                weight: hierarquia === 'Estrutural' ? 4 : 3,
                opacity: 0.8,
                interactive: true
            }).addTo(mobilidadeMap);

            novaRota.feature = {
                properties: {
                    name: nome,
                    Hierarquia: hierarquia,
                    Trecho: 'Toda Extensão',
                    custom: true,
                    id: rotaId,
                    data_criacao: new Date().toISOString()
                }
            };

            novaRota._hierarquia = hierarquia;
            novaRota._rotaId = rotaId;

            novaRota.on('click', function (e) {
                L.DomEvent.stopPropagation(e);
                showRotaModal(novaRota);
            });

            novaRota.on('mouseover', function () {
                this.setStyle({ color: '#fbbf24', weight: 5, opacity: 1 });
            });

            novaRota.on('mouseout', function () {
                if (selectedRotaLayer !== this) {
                    this.setStyle({
                        color: cor,
                        weight: hierarquia === 'Estrutural' ? 4 : 3,
                        opacity: 0.8
                    });
                }
            });

            if (!window.rotasClicaveis) window.rotasClicaveis = [];
            window.rotasClicaveis.push(novaRota);

            if (kmlLayer) kmlLayer.addLayer(novaRota);

            // Salvar no localStorage
            salvarRotaNoStorage(rotaId, nome, hierarquia, '', '', pontosDesenho, cor);

            limparDesenhoTemporario();
            pontosDesenho = [];

            alert(`… Rota "${nome}" salva com sucesso!`);
        }

        function cancelarDesenho() {
            // console.log('<i class="bi bi-x-circle-fill"></i> Cancelado');

            desenhoModeAtivo = false;
            document.getElementById('mobilidade-map').style.cursor = '';
            document.getElementById('desenho-indicator').classList.remove('active');
            document.getElementById('desenho-controls').classList.remove('active');

            mobilidadeMap.off('click');

            limparDesenhoTemporario();
            pontosDesenho = [];
        }

        function adicionarPontoDesenhoManual(e) {
            if (!desenhoModeAtivo) {
                // console.log('  Modo de desenho Não esta ativo!');
                return;
            }

            const latlng = e.latlng;

            // Evitar pontos duplicados muito próximos (menos de 10 metros)
            if (pontosDesenho.length > 0) {
                const ultimoPonto = pontosDesenho[pontosDesenho.length - 1];
                const Distância = mobilidadeMap.distance(ultimoPonto, latlng);
                if (Distância < 10) return;
            }

            pontosDesenho.push(latlng);

            // Log a cada 50 pontos
            if (pontosDesenho.length % 50 === 0) {
                // console.log(' Pontos desenhados:', pontosDesenho.length);
            }

            // Adicionar marcador visual a cada 20 pontos
            if (pontosDesenho.length % 20 === 0) {
                const marker = L.circleMarker(latlng, {
                    radius: 5,
                    color: '#10b981',
                    fillColor: '#10b981',
                    fillOpacity: 1,
                    weight: 2
                }).addTo(mobilidadeMap);

                marcadoresTemporarios.push(marker);
            }

            // Desenhar/atualizar linha
            if (pontosDesenho.length > 1) {
                if (linhaTemporaria) {
                    mobilidadeMap.removeLayer(linhaTemporaria);
                }

                linhaTemporaria = L.polyline(pontosDesenho, {
                    color: '#10b981',
                    weight: 5,
                    opacity: 0.8,
                    smoothFactor: 1
                }).addTo(mobilidadeMap);
            }

            // Primeiro ponto - mostrar confirmacao
            if (pontosDesenho.length === 1) {
                // console.log('… Primeiro ponto adicionado! Continue desenhando...');
            }
        }

        function desfazerPonto() {
            // console.log('');
            // console.log(' DESFAZER ACIONADO ');
            // console.log('Pontos antes:', pontosDesenho.length);
            // console.log('Marcadores antes:', marcadoresTemporarios.length);

            if (pontosDesenho.length === 0) {
                // console.log('  Nenhum ponto para desfazer');
                alert('Nenhum ponto para desfazer!');
                return;
            }

            // Remover 1 ponto
            const pontoRemovido = pontosDesenho.pop();
            // console.log('… Ponto removido:', pontoRemovido);
            // console.log('Š Pontos restantes:', pontosDesenho.length);

            // Remover ultimo marcador
            if (marcadoresTemporarios.length > 0) {
                const marcador = marcadoresTemporarios.pop();
                try {
                    mobilidadeMap.removeLayer(marcador);
                    // console.log('¢ Marcador removido do mapa');
                } catch (err) {
                    console.error('<i class="bi bi-x-circle-fill"></i> Erro ao remover marcador:', err);
                }
            }

            // Remover linha antiga
            if (linhaTemporaria) {
                try {
                    mobilidadeMap.removeLayer(linhaTemporaria);
                    linhaTemporaria = null;
                    // console.log('‘ Linha antiga removida');
                } catch (err) {
                    console.error('<i class="bi bi-x-circle-fill"></i> Erro ao remover linha:', err);
                }
            }

            // Redesenhar linha se ainda houver pontos
            if (pontosDesenho.length > 1) {
                // console.log(' Redesenhando linha com', pontosDesenho.length, 'pontos...');
                try {
                    linhaTemporaria = L.polyline(pontosDesenho, {
                        color: '#10b981',
                        weight: 8,
                        opacity: 0.9
                    }).addTo(mobilidadeMap);
                    // console.log('… Linha redesenhada!');
                } catch (err) {
                    console.error('<i class="bi bi-x-circle-fill"></i> Erro ao redesenhar linha:', err);
                }
            } else if (pontosDesenho.length === 1) {
                // console.log('¹ Apenas 1 ponto restante - sem linha');
            } else {
                // console.log('¹ Todos os pontos removidos');
            }

            // console.log(' FIM DO DESFAZER ');
            // console.log('');
        }

        function finalizarDesenho() {
            // console.log('');
            // console.log(' FINALIZANDO DESENHO');
            // console.log('');
            // console.log('Š Pontos-chave:', pontosChave.length);
            // console.log('Š Pontos da rota:', pontosDesenho.length);

            if (pontosDesenho.length < 2) {
                alert(' VocAª precisa adicionar pelo menos 2 pontos!');
                return;
            }

            desenhoModeAtivo = false;
            modoInterativo = false;
            document.getElementById('mobilidade-map').style.cursor = '';
            document.getElementById('desenho-indicator').classList.remove('active');
            document.getElementById('desenho-controls').classList.remove('active');

            mobilidadeMap.off('mousedown');
            mobilidadeMap.off('mousemove');
            mobilidadeMap.off('mouseup');
            mobilidadeMap.off('click');

            let DistânciaTotal = 0;
            for (let i = 0; i < pontosDesenho.length - 1; i++) {
                DistânciaTotal += mobilidadeMap.distance(pontosDesenho[i], pontosDesenho[i + 1]);
            }
            const DistânciaKm = (DistânciaTotal / 1000).toFixed(2);

            // console.log(' Distância:', DistânciaKm, 'km');

            const nome = prompt(' Nome da rota:');
            if (!nome) {
                cancelarDesenho();
                return;
            }

            const hierarquia = prompt('Š Hierarquia:\n\n1. Estrutural\n2. Arterial primária\n3. Arterial secundária\n4. Coletora\n\nDigite o nome:') || 'Coletora';

            salvarRotaDesenhada(nome, hierarquia, DistânciaKm);
        }

        function cancelarDesenho() {
            // console.log('<i class="bi bi-x-circle-fill"></i> Cancelando desenho...');

            // Limpar desenhos
            limparDesenhoTemporario();
            desenhoModeAtivo = false;
            pontosDesenho = [];


            // Remover indicadores
            document.getElementById('desenho-indicator').classList.remove('active');
            document.getElementById('desenho-controls').classList.remove('active');
            document.getElementById('mobilidade-map').style.cursor = '';

            // Remover eventos
            mobilidadeMap.off('mousedown');
            mobilidadeMap.off('mousemove');
            mobilidadeMap.off('mouseup');
            mobilidadeMap.off('click');

            // console.log('… Desenho cancelado - Sistema pronto para nova operacao');
        }

        function limparDesenhoTemporario() {
            if (linhaTemporaria) {
                mobilidadeMap.removeLayer(linhaTemporaria);
                linhaTemporaria = null;
            }

            if (rotaAutomatica) {
                mobilidadeMap.removeLayer(rotaAutomatica);
                rotaAutomatica = null;
            }

            marcadoresTemporarios.forEach(marker => mobilidadeMap.removeLayer(marker));
            marcadoresTemporarios = [];

            if (marcadorOrigem) {
                mobilidadeMap.removeLayer(marcadorOrigem);
                marcadorOrigem = null;
            }

            if (marcadorDestino) {
                mobilidadeMap.removeLayer(marcadorDestino);
                marcadorDestino = null;
            }
        }

        // ===== FUNA‡A•ES AUXILIARES PARA DESENHO =====

        function mostrarLoading(mostrar) {
            const indicator = document.getElementById('desenho-indicator');
            if (!indicator) return;

            const span = indicator.querySelector('span');
            if (!span) return;

            if (mostrar) {
                span.innerHTML = '<i class="bi bi-hourglass-split" style="animation: spin 1s linear infinite;"></i> Calculando rota nas vias...';
            } else {
                span.textContent = ' Clique no mapa para adicionar pontos Arraste os pontos para ajustar';
            }
        }

        async function recalcularRota() {
            // console.log('');
            // console.log('„ RECALCULANDO ROTA');
            // console.log('');
            // console.log(' Pontos-chave:', pontosChave.length);

            if (pontosChave.length < 2) {
                // console.log('  Menos de 2 pontos - removendo linha');
                if (linhaTemporaria) {
                    mobilidadeMap.removeLayer(linhaTemporaria);
                    linhaTemporaria = null;
                }
                return;
            }

            // Remover linha antiga
            if (linhaTemporaria) {
                mobilidadeMap.removeLayer(linhaTemporaria);
                linhaTemporaria = null;
            }

            mostrarLoading(true);

            try {
                // Criar string de coordenadas para OSRM
                const coords = pontosChave.map(p => `${p.lng},${p.lat}`).join(';');
                const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`;

                // console.log(' Chamando OSRM...');
                // console.log('¡ URL:', url);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);

                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);

                // console.log(' Resposta recebida:', response.status);

                if (response.ok) {
                    const data = await response.json();

                    if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                        const route = data.routes[0];
                        const coordinates = route.geometry.coordinates;

                        // Converter para LatLng do Leaflet
                        const pontosRota = coordinates.map(coord => L.latLng(coord[1], coord[0]));

                        // Criar linha na rota
                        linhaTemporaria = L.polyline(pontosRota, {
                            color: '#10b981',
                            weight: 6,
                            opacity: 0.8
                        }).addTo(mobilidadeMap);

                        // Salvar pontos para uso posterior
                        pontosDesenho = pontosRota;

                        const DistânciaKm = (route.distance / 1000).toFixed(2);
                        // console.log(' Rota calculada:', pontosRota.length, 'pontos');
                        // console.log(' Distância:', DistânciaKm, 'km');

                        mostrarLoading(false);
                        return;
                    }
                }

                throw new Error('OSRM Não retornou rota valida');

            } catch (error) {
                console.warn(' Snap-to-road falhou:', error.message);
                // console.log('Usando linha reta tracejada como fallback');

                // FALLBACK: Linha reta tracejada
                linhaTemporaria = L.polyline(pontosChave, {
                    color: '#f59e0b',
                    weight: 6,
                    opacity: 0.6,
                    dashArray: '10, 10'
                }).addTo(mobilidadeMap);

                pontosDesenho = [...pontosChave];

                mostrarLoading(false);
            }

            // console.log('');
            // console.log('… RECALCULO CONCLUADO');
            // console.log('');
        }

        function salvarNovaRota() {
            // console.log('¾ Salvando nova rota...');

            const nome = document.getElementById('nova-rota-nome').value.trim();
            const hierarquia = document.getElementById('nova-rota-hierarquia').value;
            const trecho = document.getElementById('nova-rota-trecho').value.trim();
            const obs = document.getElementById('nova-rota-obs').value.trim();

            if (!nome || !hierarquia) {
                alert('  Preencha o nome e a classificacao da rota!');
                return;
            }

            if (pontosDesenho.length < 2) {
                alert('  A rota precisa ter pelo menos 2 pontos!');
                return;
            }

            const cor = hierarquiaCores[hierarquia] || '#10b981';

            // Criar rota visual no mapa
            const novaRota = L.polyline(pontosDesenho, {
                color: cor,
                weight: hierarquia === 'Estrutural' ? 4 : 3,
                opacity: 0.8,
                interactive: true
            }).addTo(mobilidadeMap);

            novaRota.feature = {
                properties: {
                    name: nome,
                    Hierarquia: hierarquia,
                    Trecho: trecho || 'Toda Extensão',
                    descricao: obs || '',
                    custom: true, // MARCAR COMO ROTA CUSTOMIZADA
                    data_criacao: new Date().toISOString()
                }
            };

            novaRota._hierarquia = hierarquia;

            // Eventos da rota
            novaRota.on('click', function (e) {
                L.DomEvent.stopPropagation(e);
                showRotaModal(novaRota);
            });

            novaRota.on('mouseover', function () {
                this.setStyle({ color: '#fbbf24', weight: 5, opacity: 1 });
            });

            novaRota.on('mouseout', function () {
                if (selectedRotaLayer !== this) {
                    this.setStyle({
                        color: cor,
                        weight: hierarquia === 'Estrutural' ? 4 : 3,
                        opacity: 0.8
                    });
                }
            });

            // Adicionar ao array de rotas
            if (!window.rotasClicaveis) window.rotasClicaveis = [];
            window.rotasClicaveis.push(novaRota);

            if (kmlLayer) kmlLayer.addLayer(novaRota);

            // ===== SALVAR NO LOCALSTORAGE =====
            salvarRotaNoStorage(novaRota, nome, hierarquia, trecho, obs, pontosDesenho);

            limparDesenhoTemporario();
            cancelarNovaRota();
            atualizarEstatisticas();

            // console.log('… Rota salva com sucesso!');
            alert(`… Rota "${nome}" salva com sucesso!`);
        }

        function salvarRotaNoStorage(rota, nome, hierarquia, trecho, obs, pontos) {
            try {
                // Pegar rotas existentes
                let rotasSalvas = JSON.parse(localStorage.getItem('rotas_customizadas') || '[]');

                // Converter pontos para formato simples
                const pontosSimples = pontos.map(p => ({
                    lat: p.lat,
                    lng: p.lng
                }));

                // Adicionar nova rota
                rotasSalvas.push({
                    id: Date.now(),
                    nome: nome,
                    hierarquia: hierarquia,
                    trecho: trecho,
                    observacoes: obs,
                    pontos: pontosSimples,
                    cor: hierarquiaCores[hierarquia] || '#10b981',
                    data_criacao: new Date().toISOString()
                });

                // Salvar no localStorage
                localStorage.setItem('rotas_customizadas', JSON.stringify(rotasSalvas));

                // console.log('… Rota salva no localStorage');
                // console.log('Š Total de rotas salvas:', rotasSalvas.length);

            } catch (error) {
                console.error('<i class="bi bi-x-circle-fill"></i> Erro ao salvar rota:', error);
                alert('  Erro ao salvar rota no navegador.');
            }
        }

        function carregarRotasSalvas() {
            try {
                const rotasSalvas = JSON.parse(localStorage.getItem('rotas_customizadas') || '[]');

                // console.log('‚ Carregando rotas salvas...');
                // console.log('Š Encontradas', rotasSalvas.length, 'rotas');

                if (rotasSalvas.length === 0) {
                    // console.log('¹ Nenhuma rota salva encontrada');
                    return;
                }

                rotasSalvas.forEach((rotaData, index) => {
                    try {
                        console.log(` [${index + 1}] Carregando: ${rotaData.nome}`);

                        // Converter pontos de volta para LatLng
                        const pontos = rotaData.pontos.map(p => L.latLng(p.lat, p.lng));

                        // Criar rota no mapa
                        const rota = L.polyline(pontos, {
                            color: rotaData.cor,
                            weight: rotaData.hierarquia === 'Estrutural' ? 4 : 3,
                            opacity: 0.8,
                            interactive: true
                        }).addTo(mobilidadeMap);

                        rota.feature = {
                            properties: {
                                name: rotaData.nome,
                                Hierarquia: rotaData.hierarquia,
                                Trecho: rotaData.trecho,
                                descricao: rotaData.observacoes,
                                custom: true,
                                data_criacao: rotaData.data_criacao
                            }
                        };

                        rota._hierarquia = rotaData.hierarquia;

                        // Eventos
                        rota.on('click', function (e) {
                            L.DomEvent.stopPropagation(e);
                            showRotaModal(rota);
                        });

                        rota.on('mouseover', function () {
                            this.setStyle({ color: '#fbbf24', weight: 5, opacity: 1 });
                        });

                        rota.on('mouseout', function () {
                            if (selectedRotaLayer !== this) {
                                this.setStyle({
                                    color: rotaData.cor,
                                    weight: rotaData.hierarquia === 'Estrutural' ? 4 : 3,
                                    opacity: 0.8
                                });
                            }
                        });

                        // Adicionar ao array
                        if (!window.rotasClicaveis) window.rotasClicaveis = [];
                        window.rotasClicaveis.push(rota);

                        if (kmlLayer) kmlLayer.addLayer(rota);

                        console.log(`   … Rota "${rotaData.nome}" carregada`);

                    } catch (err) {
                        console.error(`   <i class="bi bi-x-circle-fill"></i> Erro ao carregar rota ${index + 1}:`, err);
                    }
                });

                // console.log('… Todas as rotas salvas foram carregadas');
                atualizarEstatisticas();

            } catch (error) {
                console.error('<i class="bi bi-x-circle-fill"></i> Erro ao carregar rotas salvas:', error);
            }
        }

        function apagarRotaById(id) {
            // console.log('');
            // console.log('‘ APAGANDO ROTA:', id);
            // console.log('');

            event.stopPropagation(); // … IMPORTANTE: Evitar que o clique propague

            if (!confirm('  Deseja realmente apagar esta rota?\n\nEsta acao Não pode ser desfeita!')) {
                // console.log('<i class="bi bi-x-circle-fill"></i> Usuario cancelou');
                return;
            }

            try {
                // Carregar rotas do localStorage
                let rotasSalvas = JSON.parse(localStorage.getItem('rotas_customizadas') || '[]');
                // console.log('¦ Total de rotas antes:', rotasSalvas.length);

                // Filtrar removendo a rota com o ID especificado
                const rotasFiltradas = rotasSalvas.filter(rota => rota.id !== id);
                // console.log('¦ Total de rotas depois:', rotasFiltradas.length);

                if (rotasFiltradas.length === rotasSalvas.length) {
                    console.warn('  Rota Não encontrada no localStorage');
                    alert('  Rota Não encontrada!');
                    return;
                }

                // Salvar de volta
                localStorage.setItem('rotas_customizadas', JSON.stringify(rotasFiltradas));
                // console.log('… localStorage atualizado');

                // Verificar se salvou
                const verificacao = JSON.parse(localStorage.getItem('rotas_customizadas') || '[]');
                // console.log('… Verificacao: agora tem', verificacao.length, 'rotas');

                // Remover do mapa
                if (window.rotasClicaveis) {
                    const rotaNoMapa = window.rotasClicaveis.find(r => r._rotaId === id);
                    if (rotaNoMapa) {
                        mobilidadeMap.removeLayer(rotaNoMapa);
                        window.rotasClicaveis = window.rotasClicaveis.filter(r => r._rotaId !== id);
                        // console.log('… Rota removida do mapa');
                    }
                }

                // Atualizar interface
                atualizarListaRotasCustomizadas();
                atualizarEstatisticas();

                // console.log('');
                // console.log('… ROTA APAGADA COM SUCESSO!');
                // console.log('');

                alert('… Rota apagada com sucesso!');

            } catch (error) {
                console.error('<i class="bi bi-x-circle-fill"></i> Erro ao apagar rota:', error);
                alert('<i class="bi bi-x-circle-fill"></i> Erro ao apagar rota: ' + error.message);
            }
        }

        function apagarRotasSelecionadas() {
            // console.log('');
            // console.log('‘ APAGANDO ROTAS SELECIONADAS');
            // console.log('');

            const checkboxes = document.querySelectorAll('.rota-custom-checkbox:checked');
            // console.log('‹ Checkboxes marcados:', checkboxes.length);

            if (checkboxes.length === 0) {
                alert('  Selecione pelo menos uma rota para apagar!');
                // console.log('<i class="bi bi-x-circle-fill"></i> Nenhum checkbox marcado');
                return;
            }

            if (!confirm(`  Deseja realmente apagar ${checkboxes.length} rota(s)?\n\nEsta acao Não pode ser desfeita!`)) {
                // console.log('<i class="bi bi-x-circle-fill"></i> Usuario cancelou');
                return;
            }

            try {
                const idsParaApagar = Array.from(checkboxes).map(cb => parseInt(cb.dataset.rotaId));
                // console.log('‘ IDs para apagar:', idsParaApagar);

                let rotasSalvas = JSON.parse(localStorage.getItem('rotas_customizadas') || '[]');
                // console.log('¦ Total antes:', rotasSalvas.length);

                // Filtrar
                rotasSalvas = rotasSalvas.filter(rota => !idsParaApagar.includes(rota.id));
                // console.log('¦ Total depois:', rotasSalvas.length);

                // Salvar
                localStorage.setItem('rotas_customizadas', JSON.stringify(rotasSalvas));
                // console.log('… localStorage atualizado');

                // Remover do mapa
                if (window.rotasClicaveis) {
                    idsParaApagar.forEach(id => {
                        const rotaNoMapa = window.rotasClicaveis.find(r => r._rotaId === id);
                        if (rotaNoMapa) {
                            mobilidadeMap.removeLayer(rotaNoMapa);
                        }
                    });
                    window.rotasClicaveis = window.rotasClicaveis.filter(r => !idsParaApagar.includes(r._rotaId));
                }

                // console.log(icone: '<i class="bi bi-check-circle-fill"></i>', checkboxes.length, 'rotas apagadas');

                atualizarListaRotasCustomizadas();
                atualizarEstatisticas();

                // console.log('');
                // console.log('… EXCLUSAƒO CONCLUADA!');
                // console.log('');

                alert(`… ${checkboxes.length} rota(s) apagada(s) com sucesso!`);

            } catch (error) {
                console.error('<i class="bi bi-x-circle-fill"></i> Erro:', error);
                alert('<i class="bi bi-x-circle-fill"></i> Erro ao apagar rotas: ' + error.message);
            }
        }

        function centralizarRotaById(id) {
            // console.log('¯ Centralizando rota:', id);

            event.stopPropagation(); // … IMPORTANTE

            // Tentar encontrar no mapa primeiro
            if (window.rotasClicaveis) {
                const rotaNoMapa = window.rotasClicaveis.find(r => r._rotaId === id);
                if (rotaNoMapa) {
                    mobilidadeMap.fitBounds(rotaNoMapa.getBounds(), { padding: [50, 50] });
                    // console.log('… Centralizado via mapa');
                    return;
                }
            }

            // Se Não encontrou, buscar no localStorage
            const rotasSalvas = JSON.parse(localStorage.getItem('rotas_customizadas') || '[]');
            const rotaData = rotasSalvas.find(r => r.id === id);

            if (!rotaData || !rotaData.pontos || rotaData.pontos.length === 0) {
                alert('<i class="bi bi-x-circle-fill"></i> Rota Não encontrada!');
                // console.log('<i class="bi bi-x-circle-fill"></i> Rota Não encontrada');
                return;
            }

            const lats = rotaData.pontos.map(p => p.lat);
            const lngs = rotaData.pontos.map(p => p.lng);

            const bounds = L.latLngBounds(
                [Math.min(...lats), Math.min(...lngs)],
                [Math.max(...lats), Math.max(...lngs)]
            );

            mobilidadeMap.fitBounds(bounds, { padding: [50, 50] });
            // console.log('… Centralizado via localStorage');
        }

        function limparRotasSalvas() {
            if (confirm('  Deseja realmente apagar TODAS as rotas customizadas?\n\nEsta acao Não pode ser desfeita!')) {
                localStorage.removeItem('rotas_customizadas');
                alert('… Rotas customizadas removidas!\n\nRecarregue a pagina para aplicar.');
                // console.log('‘ Rotas salvas apagadas do localStorage');
            }
        }

        function exportarRotas() {
            try {
                const rotasSalvas = JSON.parse(localStorage.getItem('rotas_customizadas') || '[]');

                if (rotasSalvas.length === 0) {
                    alert('  Nenhuma rota para exportar!');
                    return;
                }

                const dataStr = JSON.stringify(rotasSalvas, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });

                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `rotas_customizadas_${Date.now()}.json`;
                link.click();

                // console.log('… Rotas exportadas');
                alert(`… ${rotasSalvas.length} rotas exportadas com sucesso!`);

            } catch (error) {
                console.error('<i class="bi bi-x-circle-fill"></i> Erro ao exportar:', error);
                alert('<i class="bi bi-x-circle-fill"></i> Erro ao exportar rotas');
            }
        }

        function salvarRotaNoStorage(rota, nome, hierarquia, trecho, obs, pontos) {
            try {
                // Pegar rotas existentes
                let rotasSalvas = JSON.parse(localStorage.getItem('rotas_customizadas') || '[]');

                // Converter pontos para formato simples
                const pontosSimples = pontos.map(p => ({
                    lat: p.lat,
                    lng: p.lng
                }));

                // Adicionar nova rota
                rotasSalvas.push({
                    id: Date.now(),
                    nome: nome,
                    hierarquia: hierarquia,
                    trecho: trecho,
                    observacoes: obs,
                    pontos: pontosSimples,
                    cor: hierarquiaCores[hierarquia] || '#10b981',
                    data_criacao: new Date().toISOString()
                });

                // Salvar no localStorage
                localStorage.setItem('rotas_customizadas', JSON.stringify(rotasSalvas));

                // console.log('… Rota salva no localStorage');
                // console.log('Š Total de rotas salvas:', rotasSalvas.length);

            } catch (error) {
                console.error('<i class="bi bi-x-circle-fill"></i> Erro ao salvar rota:', error);
                alert('  Erro ao salvar rota no navegador.');
            }
        }

        function carregarRotasSalvas() {
            try {
                const rotasSalvas = JSON.parse(localStorage.getItem('rotas_customizadas') || '[]');

                // console.log('‚ Carregando rotas salvas...');
                // console.log('Š Encontradas', rotasSalvas.length, 'rotas');

                if (rotasSalvas.length === 0) {
                    // console.log('¹ Nenhuma rota salva encontrada');
                    return;
                }

                rotasSalvas.forEach((rotaData, index) => {
                    try {
                        console.log(` [${index + 1}] Carregando: ${rotaData.nome}`);

                        // Converter pontos de volta para LatLng
                        const pontos = rotaData.pontos.map(p => L.latLng(p.lat, p.lng));

                        // Criar rota no mapa
                        const rota = L.polyline(pontos, {
                            color: rotaData.cor,
                            weight: rotaData.hierarquia === 'Estrutural' ? 4 : 3,
                            opacity: 0.8,
                            interactive: true
                        }).addTo(mobilidadeMap);

                        rota.feature = {
                            properties: {
                                name: rotaData.nome,
                                Hierarquia: rotaData.hierarquia,
                                Trecho: rotaData.trecho,
                                descricao: rotaData.observacoes,
                                custom: true,
                                data_criacao: rotaData.data_criacao
                            }
                        };

                        rota._hierarquia = rotaData.hierarquia;

                        // Eventos
                        rota.on('click', function (e) {
                            L.DomEvent.stopPropagation(e);
                            showRotaModal(rota);
                        });

                        rota.on('mouseover', function () {
                            this.setStyle({ color: '#fbbf24', weight: 5, opacity: 1 });
                        });

                        rota.on('mouseout', function () {
                            if (selectedRotaLayer !== this) {
                                this.setStyle({
                                    color: rotaData.cor,
                                    weight: rotaData.hierarquia === 'Estrutural' ? 4 : 3,
                                    opacity: 0.8
                                });
                            }
                        });

                        // Adicionar ao array
                        if (!window.rotasClicaveis) window.rotasClicaveis = [];
                        window.rotasClicaveis.push(rota);

                        if (kmlLayer) kmlLayer.addLayer(rota);

                        console.log(`   … Rota "${rotaData.nome}" carregada`);

                    } catch (err) {
                        console.error(`   <i class="bi bi-x-circle-fill"></i> Erro ao carregar rota ${index + 1}:`, err);
                    }
                });

                // console.log('… Todas as rotas salvas foram carregadas');
                atualizarEstatisticas();

            } catch (error) {
                console.error('<i class="bi bi-x-circle-fill"></i> Erro ao carregar rotas salvas:', error);
            }
        }

        function limparRotasSalvas() {
            if (confirm('  Deseja realmente apagar TODAS as rotas customizadas?\n\nEsta acao Não pode ser desfeita!')) {
                localStorage.removeItem('rotas_customizadas');
                alert('… Rotas customizadas removidas!\n\nRecarregue a pagina para aplicar.');
                // console.log('‘ Rotas salvas apagadas do localStorage');
            }
        }

        function exportarRotas() {
            try {
                const rotasSalvas = JSON.parse(localStorage.getItem('rotas_customizadas') || '[]');

                if (rotasSalvas.length === 0) {
                    alert('  Nenhuma rota para exportar!');
                    return;
                }

                const dataStr = JSON.stringify(rotasSalvas, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });

                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `rotas_customizadas_${Date.now()}.json`;
                link.click();

                // console.log('… Rotas exportadas');
                alert(`… ${rotasSalvas.length} rotas exportadas com sucesso!`);

            } catch (error) {
                console.error('<i class="bi bi-x-circle-fill"></i> Erro ao exportar:', error);
                alert('<i class="bi bi-x-circle-fill"></i> Erro ao exportar rotas');
            }
        }

        function cancelarNovaRota() {
            // console.log('');
            // console.log('„ CANCELANDO NOVA ROTA');
            // console.log('   Stack trace:');
            console.trace();
            // console.log('');

            limparDesenhoTemporario();
            cancelarDesenho();

            const modal = document.getElementById('nova-rota-modal');
            modal.classList.remove('active');
            modal.style.display = '';

            // Limpar campos
            document.getElementById('rota-origem').value = '';
            document.getElementById('rota-destino').value = '';
            document.getElementById('nova-rota-nome').value = '';
            document.getElementById('nova-rota-hierarquia').value = '';
            document.getElementById('nova-rota-trecho').value = '';
            document.getElementById('nova-rota-obs').value = '';

            document.getElementById('rota-info').style.display = 'none';
            document.getElementById('dados-rota').style.display = 'none';
            document.getElementById('btn-salvar-rota').style.display = 'none';

            coordOrigem = null;
            coordDestino = null;
            pontosDesenho = [];

            modoAtual = 'automatico';
            document.getElementById('tab-automatico').classList.add('active');
            document.getElementById('tab-manual').classList.remove('active');
            document.getElementById('modo-automatico').classList.add('active');
            document.getElementById('modo-automatico').style.display = 'block';
            document.getElementById('modo-manual').classList.remove('active');
            document.getElementById('modo-manual').style.display = 'none';

            // console.log('… Tudo resetado');
        }

        function cancelarDesenho() {
            // console.log('<i class="bi bi-x-circle-fill"></i> Desenho cancelado');

            desenhoModeAtivo = false;
            modoInterativo = false;
            document.getElementById('mobilidade-map').style.cursor = '';
            document.getElementById('desenho-indicator').classList.remove('active');
            document.getElementById('desenho-controls').classList.remove('active');

            mobilidadeMap.off('mousedown');
            mobilidadeMap.off('mousemove');
            mobilidadeMap.off('mouseup');
            mobilidadeMap.off('click');

            limparDesenhoTemporario();
            pontosDesenho = [];
            pontosChave = [];
        }

        function limparDesenhoTemporario() {
            if (linhaTemporaria) {
                mobilidadeMap.removeLayer(linhaTemporaria);
                linhaTemporaria = null;
            }

            if (rotaAutomatica) {
                mobilidadeMap.removeLayer(rotaAutomatica);
                rotaAutomatica = null;
            }

            marcadoresTemporarios.forEach(marker => mobilidadeMap.removeLayer(marker));
            marcadoresTemporarios = [];

            if (marcadorOrigem) {
                mobilidadeMap.removeLayer(marcadorOrigem);
                marcadorOrigem = null;
            }

            if (marcadorDestino) {
                mobilidadeMap.removeLayer(marcadorDestino);
                marcadorDestino = null;
            }
        }

        function salvarNovaRota() {
            const nome = document.getElementById('nova-rota-nome').value.trim();
            const hierarquia = document.getElementById('nova-rota-hierarquia').value;
            const trecho = document.getElementById('nova-rota-trecho').value.trim();
            const obs = document.getElementById('nova-rota-obs').value.trim();

            if (!nome || !hierarquia) {
                alert('  Preencha o nome e a classificacao da rota!');
                return;
            }

            if (pontosDesenho.length < 2) {
                alert('  A rota precisa ter pelo menos 2 pontos!');
                return;
            }

            const cor = hierarquiaCores[hierarquia] || '#10b981';

            const novaRota = L.polyline(pontosDesenho, {
                color: cor,
                weight: hierarquia === 'Estrutural' ? 4 : 3,
                opacity: 0.8,
                interactive: true
            }).addTo(mobilidadeMap);

            novaRota.feature = {
                properties: {
                    name: nome,
                    Hierarquia: hierarquia,
                    Trecho: trecho || 'Toda Extensão',
                    descricao: obs || ''
                }
            };

            novaRota._hierarquia = hierarquia;

            novaRota.on('click', function (e) {
                L.DomEvent.stopPropagation(e);
                showRotaModal(novaRota);
            });

            novaRota.on('mouseover', function () {
                this.setStyle({ color: '#fbbf24', weight: 5, opacity: 1 });
            });

            novaRota.on('mouseout', function () {
                if (selectedRotaLayer !== this) {
                    this.setStyle({
                        color: cor,
                        weight: hierarquia === 'Estrutural' ? 4 : 3,
                        opacity: 0.8
                    });
                }
            });

            if (!window.rotasClicaveis) window.rotasClicaveis = [];
            window.rotasClicaveis.push(novaRota);

            if (kmlLayer) kmlLayer.addLayer(novaRota);

            limparDesenhoTemporario();
            cancelarNovaRota();
            atualizarEstatisticas();

            // console.log('… Nova rota adicionada:', nome);
            alert(`… Rota "${nome}" adicionada com sucesso!`);
        }

        function cancelarNovaRota() {
            limparDesenhoTemporario();
            cancelarDesenho();

            document.getElementById('nova-rota-modal').classList.remove('active');
            document.getElementById('rota-origem').value = '';
            document.getElementById('rota-destino').value = '';
            document.getElementById('nova-rota-nome').value = '';
            document.getElementById('nova-rota-hierarquia').value = '';
            document.getElementById('nova-rota-trecho').value = '';
            document.getElementById('nova-rota-obs').value = '';
            document.getElementById('rota-info').style.display = 'none';
            document.getElementById('dados-rota').style.display = 'none';
            document.getElementById('btn-salvar-rota').style.display = 'none';

            coordOrigem = null;
            coordDestino = null;
            pontosDesenho = [];
        }

        function closeNovaRotaModal() {
            cancelarNovaRota();
        }

        // ===== FIM DO SISTEMA DE ROTEAMENTO =====

        // ===== ANALISE DE TRA‚NSITO EM ROTAS =====

        function analisartransitoNaRota(layer) {
            // console.log('');
            // console.log(' ANALISANDO TRA‚NSITO NA ROTA');
            // console.log('');

            // console.log('wazeMarkers existe?', !!wazeMarkers);
            // console.log('wazeMarkers.length:', wazeMarkers ? wazeMarkers.length : 0);
            // console.log('wazeVisible:', wazeVisible);

            if (!wazeMarkers || wazeMarkers.length === 0) {
                // console.log('<i class="bi bi-x-circle-fill"></i> Nenhum dado do Waze carregado');
                return null;
            }

            const latlngs = layer.getLatLngs();
            // console.log('Pontos da rota:', latlngs.length);

            if (!latlngs || latlngs.length === 0) {
                // console.log('<i class="bi bi-x-circle-fill"></i> Rota sem pontos');
                return null;
            }

            // Estatísticas
            const Análise = {
                acidentes: 0,
                congestionamentos: 0,
                perigos: 0,
                outros: 0,
                velocidades: [],
                velocidadeMédia: null,
                NívelCongestionamento: 0,
                alertaspróximos: [],
                DistânciaTotal: 0
            };

            // Calcular Distância total da rota
            for (let i = 0; i < latlngs.length - 1; i++) {
                Análise.DistânciaTotal += mobilidadeMap.distance(latlngs[i], latlngs[i + 1]);
            }
            Análise.DistânciaTotal = (Análise.DistânciaTotal / 1000).toFixed(2);

            // console.log(' Distância total da rota:', Análise.DistânciaTotal, 'km');

            // Raio de busca (200 metros)
            const raioMetros = 200;
            // console.log('¯ Raio de busca:', raioMetros, 'metros');

            let marcadoresVerificados = 0;
            let marcadorespróximos = 0;

            // Verificar cada marcador do Waze
            wazeMarkers.forEach((marker, index) => {
                if (!marker || !marker.wazeData) {
                    console.log(`  Marcador ${index} sem dados`);
                    return;
                }

                marcadoresVerificados++;

                const markerLatLng = marker.getLatLng();
                let menorDistância = Infinity;

                // Calcular Distância minima do marcador ate a rota
                latlngs.forEach(ponto => {
                    const Distância = mobilidadeMap.distance(markerLatLng, ponto);
                    if (Distância < menorDistância) {
                        menorDistância = Distância;
                    }
                });

                // Se estiver próximo
                if (menorDistância <= raioMetros) {
                    marcadorespróximos++;

                    const data = marker.wazeData;
                    const tipo = data.tipo || data.type || '';

                    console.log(`… [${marcadorespróximos}] Alerta próximo:`, tipo, `(${Math.round(menorDistância)}m)`);

                    // Contar por tipo
                    if (tipo.includes('Acidente') || tipo === 'ACCIDENT') {
                        Análise.acidentes++;
                    } else if (tipo.includes('Congestionamento') || tipo === 'JAM') {
                        Análise.congestionamentos++;

                        if (data.velocidade !== undefined) {
                            Análise.velocidades.push(data.velocidade);
                            // console.log('  Š Velocidade:', data.velocidade, 'km/h');
                        }

                        if (data.Nível !== undefined) {
                            Análise.NívelCongestionamento += data.Nível;
                            // console.log('  ¦ Nível:', data.Nível);
                        }
                    } else if (tipo.includes('Perigo') || tipo === 'HAZARD' || tipo === 'WEATHERHAZARD' || tipo === 'ROAD_CLOSED') {
                        Análise.perigos++;
                    } else {
                        Análise.outros++;
                    }

                    // Guardar alerta
                    Análise.alertaspróximos.push({
                        tipo: data.título,
                        icone: data.icone,
                        cor: data.cor,
                        rua: data.rua || data.street || 'Via não identificada',
                        Distância: Math.round(menorDistância)
                    });
                }
            });

            // console.log('Š Marcadores verificados:', marcadoresVerificados);
            // console.log(' Marcadores próximos:', marcadorespróximos);

            // Calcular velocidade Média
            if (Análise.velocidades.length > 0) {
                const soma = Análise.velocidades.reduce((a, b) => a + b, 0);
                Análise.velocidadeMédia = Math.round((soma / Análise.velocidades.length) * 10) / 10;
                // console.log('— Velocidade Média:', Análise.velocidadeMédia, 'km/h');
            }

            // Calcular Nível medio
            if (Análise.congestionamentos > 0) {
                Análise.NívelCongestionamento = Math.round(Análise.NívelCongestionamento / Análise.congestionamentos);
            }

            Análise.totalAlertas = Análise.acidentes + Análise.congestionamentos + Análise.perigos + Análise.outros;

            // console.log('');
            // console.log('Š RESUMO DA ANALISE:');
            // console.log('   Total de alertas:', Análise.totalAlertas);
            // console.log('   ¨ Acidentes:', Análise.acidentes);
            // console.log('   — Congestionamentos:', Análise.congestionamentos);
            // console.log('     Perigos:', Análise.perigos);
            // console.log('    Outros:', Análise.outros);
            // console.log('   ™ Velocidade Média:', Análise.velocidadeMédia);
            // console.log('');

            return Análise;
        }

        function getStatustransito(Análise) {
            if (!Análise || Análise.totalAlertas === 0) {
                return {
                    Nível: 0,
                    texto: 'Sem InformacAµes',
                    cor: '#64748b',
                    icone: '“',
                    badge: 'info'
                };
            }

            // Baseado em velocidade Média
            if (Análise.velocidadeMédia !== null) {
                if (Análise.velocidadeMédia < 10) {
                    return {
                        Nível: 4,
                        texto: 'transito Parado',
                        cor: '#dc2626',
                        icone: '<i class="bi bi-exclamation-octagon-fill"></i>',
                        badge: 'danger'
                    };
                } else if (Análise.velocidadeMédia < 20) {
                    return {
                        Nível: 3,
                        texto: 'transito Intenso',
                        cor: '#ef4444',
                        icone: '—',
                        badge: 'danger'
                    };
                } else if (Análise.velocidadeMédia < 40) {
                    return {
                        Nível: 2,
                        texto: 'transito Moderado',
                        cor: '#f59e0b',
                        icone: '™',
                        badge: 'warning'
                    };
                } else {
                    return {
                        Nível: 1,
                        texto: 'transito Fluindo',
                        cor: '#10b981',
                        icone: '<i class="bi bi-check-circle-fill"></i>',
                        badge: 'success'
                    };
                }
            }

            // Baseado em congestionamentos
            if (Análise.congestionamentos >= 3) {
                return {
                    Nível: 3,
                    texto: 'transito Intenso',
                    cor: '#ef4444',
                    icone: '—',
                    badge: 'danger'
                };
            } else if (Análise.congestionamentos >= 1) {
                return {
                    Nível: 2,
                    texto: 'transito Moderado',
                    cor: '#f59e0b',
                    icone: '™',
                    badge: 'warning'
                };
            }

            // Baseado em acidentes
            if (Análise.acidentes >= 1) {
                return {
                    Nível: 3,
                    texto: 'Atencao - Acidente',
                    cor: '#ef4444',
                    icone: '¨',
                    badge: 'danger'
                };
            }

            return {
                Nível: 1,
                texto: 'transito Normal',
                cor: '#10b981',
                icone: '<i class="bi bi-check-circle-fill"></i>',
                badge: 'success'
            };
        }

        // ===== CARREGAR APIs =====
        async function loadtransitoStatus() {
            try {
                const response = await fetch('/api/transito-status/');
                const data = await response.json();

                if (data.success) {
                    const container = document.getElementById('transito-container');
                    const status = data.data;

                    const statusHTML = `
                        <div class="transito-status Nível-${status.Nível}">
                            <div class="transito-icon" style="background: ${status.cor}20; color: ${status.cor};">
                                <i class="bi bi-car-front-fill"></i>
                            </div>
                            <div class="transito-descricao" style="color: ${status.cor};">
                                ${status.descricao}
                            </div>
                            <div class="transito-detalhes">
                                <div class="transito-detail">
                                    <div class="transito-detail-value">${status.lentidao_km} km</div>
                                    <div class="transito-detail-label">Lentidao</div>
                                </div>
                                <div class="transito-detail">
                                    <div class="transito-detail-value">${status.velocidade_Média} km/h</div>
                                    <div class="transito-detail-label">Velocidade Média</div>
                                </div>
                                <div class="transito-detail">
                                    <div class="transito-detail-value">${status.hora}h</div>
                                    <div class="transito-detail-label">Hora Atual</div>
                                </div>
                            </div>
                        </div>
                    `;

                    container.innerHTML = statusHTML;
                    document.getElementById('transito-Nível').textContent = status.descricao.replace('transito ', '');
                }
            } catch (error) {
                console.error('Erro ao carregar status:', error);
            }
        }

        async function loadBRT() {
            try {
                const response = await fetch('/api/brt/');
                const data = await response.json();

                if (data.success) {
                    const container = document.getElementById('brt-container');
                    container.innerHTML = '';

                    data.data.forEach(linha => {
                        const card = `
                            <div class="linha-card" style="--linha-cor: ${linha.cor}">
                                <div class="linha-header">
                                    <div class="linha-nome">${linha.nome}</div>
                                    <span class="linha-status ${linha.status_code}">${linha.status}</span>
                                </div>
                                <div class="linha-info">
                                    <div class="linha-info-item">
                                        EstacAµes
                                        <strong>${linha.estacoes}</strong>
                                    </div>
                                    <div class="linha-info-item">
                                        Extensão
                                        <strong>${linha.Extensão}</strong>
                                    </div>
                                    <div class="linha-info-item">
                                        Tempo Medio
                                        <strong>${linha.tempo_medio}</strong>
                                    </div>
                                    <div class="linha-info-item">
                                        Intervalo
                                        <strong>${linha.intervalo}</strong>
                                    </div>
                                </div>
                            </div>
                        `;
                        container.innerHTML += card;
                    });

                    document.getElementById('brt-total').textContent = data.count;
                }
            } catch (error) {
                console.error('Erro ao carregar BRT:', error);
            }
        }

        async function loadMetro() {
            try {
                const response = await fetch('/api/metro/');
                const data = await response.json();

                if (data.success) {
                    const container = document.getElementById('metro-container');
                    container.innerHTML = '';

                    data.data.forEach(linha => {
                        const card = `
                            <div class="linha-card" style="--linha-cor: ${linha.cor}">
                                <div class="linha-header">
                                    <div class="linha-nome">${linha.nome}</div>
                                    <span class="linha-status ${linha.status_code}">${linha.status}</span>
                                </div>
                                <div class="linha-info">
                                    <div class="linha-info-item">
                                        EstacAµes
                                        <strong>${linha.estacoes}</strong>
                                    </div>
                                    <div class="linha-info-item">
                                        Extensão
                                        <strong>${linha.Extensão}</strong>
                                    </div>
                                    <div class="linha-info-item">
                                        Intervalo
                                        <strong>${linha.intervalo}</strong>
                                    </div>
                                    <div class="linha-info-item">
                                        Trecho
                                        <strong>${linha.origem} - ${linha.destino}</strong>
                                    </div>
                                </div>
                            </div>
                        `;
                        container.innerHTML += card;
                    });

                    document.getElementById('metro-total').textContent = data.count;
                }
            } catch (error) {
                console.error('Erro ao carregar MetrA´:', error);
            }
        }

        async function loadBikeRio() {
            try {
                const response = await fetch('/api/bike-rio/');
                const data = await response.json();

                if (data.success) {
                    const container = document.getElementById('bike-container');
                    container.innerHTML = '';

                    data.data.forEach(estacao => {
                        const statusClass = estacao.bikes_disponiveis === 0 ? 'sem-bikes' : '';
                        const statusText = estacao.bikes_disponiveis === 0 ? 'Sem Bikes' : estacao.status;

                        const card = `
                            <div class="bike-card">
                                <div class="bike-header">
                                    <div class="bike-nome">
                                        <i class="bi bi-bicycle"></i> ${estacao.nome}
                                    </div>
                                    <span class="bike-status ${statusClass}">${statusText}</span>
                                </div>
                                <div class="bike-stats">
                                    <div class="bike-stat">
                                        <div class="bike-stat-value">${estacao.bikes_disponiveis}</div>
                                        <div class="bike-stat-label">Bikes</div>
                                    </div>
                                    <div class="bike-stat">
                                        <div class="bike-stat-value">${estacao.vagas_disponiveis}</div>
                                        <div class="bike-stat-label">Vagas</div>
                                    </div>
                                </div>
                            </div>
                        `;
                        container.innerHTML += card;
                    });

                    document.getElementById('bike-total').textContent = data.total_bikes;
                }
            } catch (error) {
                console.error('Erro ao carregar Bike Rio:', error);
            }
        }

        // Dropdown toggle
        document.querySelectorAll('.cor-menu-item').forEach(item => {
            item.addEventListener('click', function (e) {
                if (this.querySelector('.cor-submenu')) {
                    e.preventDefault();
                    this.classList.toggle('open');

                    document.querySelectorAll('.cor-menu-item').forEach(other => {
                        if (other !== this) other.classList.remove('open');
                    });
                }
            });
        });

        function mostrarModoAutomatico() {
            // console.log('„ Modo automatico');

            modoAtual = 'automatico';

            document.getElementById('tab-automatico').classList.add('active');
            document.getElementById('tab-manual').classList.remove('active');

            const modoAuto = document.getElementById('modo-automatico');
            const modoManual = document.getElementById('modo-manual');

            modoAuto.classList.add('active');
            modoAuto.style.display = 'block';

            modoManual.classList.remove('active');
            modoManual.style.display = 'none';
        }

        function mostrarModoManual() {
            // console.log('„ Modo manual');

            modoAtual = 'manual';

            document.getElementById('tab-manual').classList.add('active');
            document.getElementById('tab-automatico').classList.remove('active');

            const modoAuto = document.getElementById('modo-automatico');
            const modoManual = document.getElementById('modo-manual');

            modoManual.classList.add('active');
            modoManual.style.display = 'block';

            modoAuto.classList.remove('active');
            modoAuto.style.display = 'none';
        }


        // ===== FUNA‡A•ES DO MODAL DE ALERTA WAZE =====

        function showWazeModal(marker) {
            selectedWazeMarker = marker;

            const data = marker.wazeData;

            document.getElementById('waze-modal-title').innerHTML =
                `${data.icone} ${data.título}`;

            let content = '';

            // ===== HERO SECTION =====
            const rua = data.rua || data.street || 'Via não identificada';
            const cidade = data.cidade || data.city || 'Rio de Janeiro';
            const subtipo = data.subtipo || data.subtype || data.Nível_texto || '';

            content += `
                <div class="waze-hero">
                    <div class="waze-hero-icon">${data.icone}</div>
                    <div class="waze-hero-title">${data.título}</div>
                    ${subtipo ? `<div class="waze-hero-subtitle">${subtipo}</div>` : ''}
                </div>
            `;

            // ===== LOCALIZAA‡AƒO =====
            content += `
                <div class="waze-modal-section">
                    <div class="waze-section-title">
                        <i class="bi bi-geo-alt-fill"></i>
                        Localização
                    </div>
                    
                    <div class="waze-info-row">
                        <div class="waze-info-icon"></div>
                        <div class="waze-info-content">
                            <div class="waze-info-label">Endereço</div>
                            <div class="waze-info-value">${rua}</div>
                        </div>
                    </div>
                    
                    <div class="waze-info-row">
                        <div class="waze-info-icon"><i class="bi bi-buildings-fill"></i></div>
                        <div class="waze-info-content">
                            <div class="waze-info-label">Cidade</div>
                            <div class="waze-info-value">${cidade}</div>
                        </div>
                    </div>
                </div>
            `;

            // ===== DESCRIA‡AƒO (se existir) =====
            const descricao = data.reportDescription || data.descricao;
            if (descricao && descricao.trim() !== '') {
                content += `
                    <div class="waze-modal-section">
                        <div class="waze-section-title">
                            <i class="bi bi-chat-left-text-fill"></i>
                            descricao
                        </div>
                        <div class="waze-info-row">
                            <div class="waze-info-icon">¬</div>
                            <div class="waze-info-content">
                                <div class="waze-info-value">${descricao}</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // ===== ESTATASTICAS (para congestionamentos) =====
            const hasStats = data.velocidade !== undefined ||
                data.comprimento !== undefined ||
                data.atraso !== undefined ||
                data.Nível !== undefined;

            if (hasStats) {
                content += `
                    <div class="waze-modal-section">
                        <div class="waze-section-title">
                            <i class="bi bi-speedometer2"></i>
                            Estatísticas do transito
                        </div>
                        <div class="waze-stats-grid">
                `;

                // Velocidade
                if (data.velocidade !== undefined) {
                    const velocidade = Math.round(data.velocidade * 10) / 10;
                    let badgeClass = 'success';
                    let statusText = 'Fluindo';

                    if (velocidade < 10) {
                        badgeClass = 'danger';
                        statusText = 'Parado';
                    } else if (velocidade < 20) {
                        badgeClass = 'warning';
                        statusText = 'Muito Lento';
                    } else if (velocidade < 40) {
                        badgeClass = 'info';
                        statusText = 'Lento';
                    }

                    content += `
                        <div class="waze-stat-box">
                            <div class="waze-badge ${badgeClass}" style="margin-bottom: 8px; font-size: 10px;">
                                ${statusText}
                            </div>
                            <div class="waze-stat-value" style="color: ${data.cor};">${velocidade}</div>
                            <div class="waze-stat-label">km/h</div>
                        </div>
                    `;
                }

                // Comprimento
                if (data.comprimento !== undefined) {
                    const comprimento = Math.round(data.comprimento);
                    content += `
                        <div class="waze-stat-box">
                            <div class="waze-stat-value" style="color: ${data.cor};">${comprimento}</div>
                            <div class="waze-stat-label">Metros</div>
                        </div>
                    `;
                }

                // Atraso
                if (data.atraso !== undefined) {
                    const atrasoMin = Math.round(data.atraso / 60);
                    content += `
                        <div class="waze-stat-box">
                            <div class="waze-stat-value" style="color: ${data.cor};">${atrasoMin}</div>
                            <div class="waze-stat-label">Min Atraso</div>
                        </div>
                    `;
                }

                // Nível
                if (data.Nível !== undefined) {
                    const niveis = ['Livre', 'Leve', 'Moderado', 'Pesado', 'Parado', 'Muito Lento'];
                    content += `
                        <div class="waze-stat-box">
                            <div class="waze-stat-value" style="color: ${data.cor};">${data.Nível}</div>
                            <div class="waze-stat-label">${niveis[data.Nível] || 'N/A'}</div>
                        </div>
                    `;
                }

                content += `
                        </div>
                    </div>
                `;
            }

            // ===== CONFIABILIDADE =====
            const confianca = data.confianca || data.confidence;
            const confiabilidade = data.confiabilidade || data.reliability;

            if (confianca !== undefined || confiabilidade !== undefined) {
                content += `
                    <div class="waze-modal-section">
                        <div class="waze-section-title">
                            <i class="bi bi-shield-check"></i>
                            Confiabilidade
                        </div>
                        <div class="waze-stats-grid" style="grid-template-columns: 1fr 1fr;">
                `;

                if (confianca !== undefined) {
                    content += `
                        <div class="waze-stat-box">
                            <div class="waze-stat-value" style="color: #10b981;">${confianca}</div>
                            <div class="waze-stat-label"> Confianca</div>
                        </div>
                    `;
                }

                if (confiabilidade !== undefined) {
                    content += `
                        <div class="waze-stat-box">
                            <div class="waze-stat-value" style="color: #10b981;">${confiabilidade}</div>
                            <div class="waze-stat-label">¯ Qualidade</div>
                        </div>
                    `;
                }

                content += `
                        </div>
                    </div>
                `;
            }

            // ===== FONTE =====
            content += `
                <div class="waze-modal-section">
                    <div class="waze-source">
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Waze_logo.svg/200px-Waze_logo.svg.png" alt="Waze">
                        <div class="waze-source-text">
                            <strong>Dados em tempo real</strong><br>
                            InformacAµes coletadas pela comunidade Waze
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('waze-modal-body').innerHTML = content;
            document.getElementById('waze-modal').classList.add('active');
        }

        function closeWazeModal() {
            document.getElementById('waze-modal').classList.remove('active');

            if (selectedWazeMarker) {
                selectedWazeMarker._icon.style.transform = 'scale(1)';
                selectedWazeMarker._icon.style.zIndex = '1000';
                selectedWazeMarker = null;
            }
        }

        function centerWazeOnMap() {
            if (selectedWazeMarker) {
                const latlng = selectedWazeMarker.getLatLng();
                mobilidadeMap.setView(latlng, 16, {
                    animate: true,
                    duration: 1
                });
            }
        }

        // Fechar modal ao clicar fora
        document.addEventListener('click', function (e) {
            const modal = document.getElementById('waze-modal');
            if (e.target === modal) {
                closeWazeModal();
            }
        });

        // Fechar modal com ESC
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                closeWazeModal();
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            initMapa();
            loadtransitoStatus();
            loadBRT();
            loadMetro();
            loadBikeRio();

            // … CARREGAR ROTAS SALVAS APA“S O MAPA INICIAR
            setTimeout(() => {
                carregarRotasSalvas();
            }, 2000); // Aguardar 2 segundos para garantir que o mapa esta pronto

            // ===== CONFIGURAR BOTAƒO DE DESENHO COM CAPTURE =====
            const configurarBotaoDesenho = () => {
                const btnDesenho = document.getElementById('btn-iniciar-desenho-manual');

                if (btnDesenho && !btnDesenho.hasAttribute('data-configured')) {
                    btnDesenho.setAttribute('data-configured', 'true');

                    // console.log('§ Configurando botao de desenho...');

                    // Usar addEventListener COM CAPTURE para interceptar ANTES
                    btnDesenho.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImMédiatePropagation();

                        // console.log('');
                        // console.log('<i class="bi bi-clock-fill"></i> BOTAƒO CLICADO!');
                        // console.log('');

                        // Fechar modal
                        const modal = document.getElementById('nova-rota-modal');
                        modal.classList.remove('active');
                        modal.style.display = 'none';

                        // console.log('… Modal fechado');

                        // Chamar desenho
                        setTimeout(() => {
                            // console.log('¨ Iniciando desenho...');
                            iniciarDesenhoManual();
                        }, 300);

                        return false;
                    }, true); // … CAPTURE = TRUE (MUITO IMPORTANTE!)

                    // console.log('… Botao configurado com CAPTURE!');
                }
            };

            // Configurar agora
            setTimeout(configurarBotaoDesenho, 500);

            // Configurar sempre que o modal abrir
            const modal = document.getElementById('nova-rota-modal');
            const observer = new MutationObserver(() => {
                if (modal.classList.contains('active')) {
                    setTimeout(configurarBotaoDesenho, 100);
                }
            });

            observer.observe(modal, {
                attributes: true,
                attributeFilter: ['class']
            });

            // Atualizar status das vias a cada 30 segundos
            setInterval(() => {
                if (wazeVisible && wazeMarkers.length > 0 && window.rotasClicaveis && window.rotasClicaveis.length > 0) {
                    analisarViasComWaze();
                }
            }, 30000);

            // Primeira atualização após 5 segundos (dar tempo de carregar tudo)
            setTimeout(() => {
                if (window.rotasClicaveis && window.rotasClicaveis.length > 0) {
                    analisarViasComWaze();
                }
            }, 5000);

            // console.log('… Observer configurado');

            setInterval(() => {
                loadtransitoStatus();
                loadBikeRio();
            }, 2 * 60 * 1000);

            // console.log('… Dashboard de Mobilidade inicializado');
        });


        // ===== FUNA‡A•ES DO MODAL DE ALERTA WAZE =====

        function showWazeModal(marker) {
            selectedWazeMarker = marker;

            marker._icon.style.transform = 'scale(1.3)';
            marker._icon.style.zIndex = '10001';

            const data = marker.wazeData;

            document.getElementById('waze-modal-title').innerHTML =
                `<i class="bi bi-exclamation-triangle-fill"></i> ${data.titulo || 'Alerta'}`;

            let content = '';

            // Hero Section
            const rua = data.rua || data.street || 'Via nao identificada';
            const cidade = data.cidade || data.city || 'Rio de Janeiro';
            const subtipo = data.subtipo || data.subtype || data.nivel_texto || '';

            content += `
        <div class="waze-hero" style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.2) 0%, rgba(37, 99, 235, 0.1) 100%); padding: 24px; text-align: center; border-bottom: 2px solid rgba(59, 130, 246, 0.3);">
            <div style="font-size: 48px; margin-bottom: 12px;">
                <i class="bi bi-exclamation-triangle-fill" style="color: ${data.cor};"></i>
            </div>
            <div style="font-size: 24px; font-weight: 700; color: #f8fafc; margin-bottom: 4px;">
                ${data.titulo || 'Alerta'}
            </div>
            ${subtipo ? `<div style="font-size: 14px; color: #94a3b8;">${subtipo}</div>` : ''}
        </div>
    `;

            // Localizacao
            content += `
        <div class="waze-modal-section" style="padding: 20px 24px; border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
            <div style="color: #94a3b8; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px;">
                <i class="bi bi-geo-alt-fill"></i> Localizacao
            </div>
            
            <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 8px; margin-bottom: 8px;">
                <div style="width: 40px; height: 40px; background: rgba(59, 130, 246, 0.2); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 20px;">
                    <i class="bi bi-signpost-2-fill"></i>
                </div>
                <div style="flex: 1;">
                    <div style="font-size: 11px; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 2px;">Endereco</div>
                    <div style="font-size: 15px; color: #f8fafc; font-weight: 500;">${rua}</div>
                </div>
            </div>
            
            <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 8px;">
                <div style="width: 40px; height: 40px; background: rgba(59, 130, 246, 0.2); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 20px;">
                    <i class="bi bi-buildings-fill"></i>
                </div>
                <div style="flex: 1;">
                    <div style="font-size: 11px; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 2px;">Cidade</div>
                    <div style="font-size: 15px; color: #f8fafc; font-weight: 500;">${cidade}</div>
                </div>
            </div>
        </div>
    `;

            // Descricao (se existir)
            const descricao = data.reportDescription || data.descricao;
            if (descricao && descricao.trim() !== '') {
                content += `
            <div class="waze-modal-section" style="padding: 20px 24px; border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="color: #94a3b8; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px;">
                    <i class="bi bi-chat-left-text-fill"></i> Descricao
                </div>
                <div style="padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 8px;">
                    <div style="font-size: 15px; color: #f8fafc; font-weight: 500;">${descricao}</div>
                </div>
            </div>
        `;
            }

            // Estatisticas (para congestionamentos)
            const hasStats = data.velocidade !== undefined ||
                data.comprimento !== undefined ||
                data.atraso !== undefined ||
                data.nivel !== undefined;

            if (hasStats) {
                content += `
            <div class="waze-modal-section" style="padding: 20px 24px; border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="color: #94a3b8; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px;">
                    <i class="bi bi-speedometer2"></i> Estatisticas do Transito
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 12px;">
        `;

                // Velocidade
                if (data.velocidade !== undefined) {
                    const velocidade = Math.round(data.velocidade * 10) / 10;
                    let statusText = 'Fluindo';
                    let statusColor = '#10b981';

                    if (velocidade < 10) {
                        statusText = 'Parado';
                        statusColor = '#ef4444';
                    } else if (velocidade < 20) {
                        statusText = 'Muito Lento';
                        statusColor = '#f59e0b';
                    } else if (velocidade < 40) {
                        statusText = 'Lento';
                        statusColor = '#3b82f6';
                    }

                    content += `
                <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 16px 12px; text-align: center;">
                    <div style="display: inline-flex; align-items: center; gap: 6px; padding: 4px 12px; border-radius: 20px; font-size: 10px; font-weight: 600; text-transform: uppercase; background: ${statusColor}20; color: ${statusColor}; border: 1px solid ${statusColor}40; margin-bottom: 8px;">
                        ${statusText}
                    </div>
                    <div style="font-size: 28px; font-weight: 700; color: ${data.cor}; margin-bottom: 4px; line-height: 1;">${velocidade}</div>
                    <div style="font-size: 11px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">km/h</div>
                </div>
            `;
                }

                // Comprimento
                if (data.comprimento !== undefined) {
                    const comprimento = Math.round(data.comprimento);
                    content += `
                <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 16px 12px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: ${data.cor}; margin-bottom: 4px; line-height: 1;">${comprimento}</div>
                    <div style="font-size: 11px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Metros</div>
                </div>
            `;
                }

                // Atraso
                if (data.atraso !== undefined) {
                    const atrasoMin = Math.round(data.atraso / 60);
                    content += `
                <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 16px 12px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: ${data.cor}; margin-bottom: 4px; line-height: 1;">${atrasoMin}</div>
                    <div style="font-size: 11px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Min Atraso</div>
                </div>
            `;
                }

                // Nivel
                if (data.nivel !== undefined) {
                    const niveis = ['Livre', 'Leve', 'Moderado', 'Pesado', 'Parado', 'Muito Lento'];
                    content += `
                <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 16px 12px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: ${data.cor}; margin-bottom: 4px; line-height: 1;">${data.nivel}</div>
                    <div style="font-size: 11px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">${niveis[data.nivel] || 'N/A'}</div>
                </div>
            `;
                }

                content += `
                </div>
            </div>
        `;
            }

            // Confiabilidade
            const confianca = data.confianca || data.confidence;
            const confiabilidade = data.confiabilidade || data.reliability;

            if (confianca !== undefined || confiabilidade !== undefined) {
                content += `
            <div class="waze-modal-section" style="padding: 20px 24px; border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="color: #94a3b8; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px;">
                    <i class="bi bi-shield-check"></i> Confiabilidade
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
        `;

                if (confianca !== undefined) {
                    content += `
                <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 16px 12px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: #10b981; margin-bottom: 4px; line-height: 1;">${confianca}</div>
                    <div style="font-size: 11px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Confianca</div>
                </div>
            `;
                }

                if (confiabilidade !== undefined) {
                    content += `
                <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 16px 12px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: #10b981; margin-bottom: 4px; line-height: 1;">${confiabilidade}</div>
                    <div style="font-size: 11px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Qualidade</div>
                </div>
            `;
                }

                content += `
                </div>
            </div>
        `;
            }

            // Fonte
            content += `
        <div class="waze-modal-section" style="padding: 20px 24px;">
            <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(37, 99, 235, 0.05) 100%); padding: 16px; border-radius: 8px; display: flex; align-items: center; gap: 12px; border: 1px solid rgba(59, 130, 246, 0.2);">
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Waze_logo.svg/200px-Waze_logo.svg.png" alt="Waze" style="height: 24px;">
                <div style="flex: 1; font-size: 13px; color: #cbd5e1;">
                    <strong>Dados em tempo real</strong><br>
                    Informacoes coletadas pela comunidade Waze
                </div>
            </div>
        </div>
    `;

            document.getElementById('waze-modal-body').innerHTML = content;
            document.getElementById('waze-modal').classList.add('active');
        }

        function closeWazeModal() {
            document.getElementById('waze-modal').classList.remove('active');

            if (selectedWazeMarker) {
                selectedWazeMarker._icon.style.transform = 'scale(1)';
                selectedWazeMarker._icon.style.zIndex = '1000';
                selectedWazeMarker = null;
            }
        }

        function centerWazeOnMap() {
            if (selectedWazeMarker) {
                const latlng = selectedWazeMarker.getLatLng();
                mobilidadeMap.setView(latlng, 16, {
                    animate: true,
                    duration: 1
                });
            }
        }

        // Fechar modal ao clicar fora
        document.addEventListener('click', function (e) {
            const modal = document.getElementById('waze-modal');
            if (e.target === modal) {
                closeWazeModal();
            }
        });

        // Fechar modal com ESC
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                closeWazeModal();
            }
        });

    </script>

    <!-- Modal de Nova Rota -->
    <div class="nova-rota-modal" id="nova-rota-modal">
        <div class="nova-rota-content" style="max-width: 600px;">
            <div class="nova-rota-header">
                <h3>
                    <i class="bi bi-plus-circle-fill"></i>
                    Nova Rota
                </h3>
                <button class="rota-modal-close" onclick="closeNovaRotaModal()">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>

            <div class="nova-rota-body">

                <!-- Abas de Modo -->
                <div
                    style="display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 2px solid rgba(255,255,255,0.1); padding-bottom: 10px;">
                    <button class="modo-tab active" onclick="mudarModo('automatico')" id="tab-automatico">
                        <i class="bi bi-magic"></i> Roteamento Automatico
                    </button>
                    <button class="modo-tab" onclick="mudarModo('manual')" id="tab-manual">
                        <i class="bi bi-pencil"></i> Desenho Manual
                    </button>
                </div>

                <!-- Modo Automatico -->
                <div id="modo-automatico" class="modo-content active" style="display: block;">
                    <div class="form-group">
                        <label class="form-label">
                            <i class="bi bi-geo-alt-fill" style="color: #10b981;"></i>
                            Ponto Inicial *
                        </label>
                        <input type="text" id="rota-origem" class="form-input"
                            placeholder="Ex: Copacabana, Rio de Janeiro"
                            onkeydown="if(event.key==='Enter') buscarEndereço('origem')">
                        <button class="search-btn" onclick="buscarEndereço('origem')">
                            <i class="bi bi-search"></i> Buscar
                        </button>
                    </div>

                    <div class="form-group">
                        <label class="form-label">
                            <i class="bi bi-flag-fill" style="color: #ef4444;"></i>
                            Ponto Final *
                        </label>
                        <input type="text" id="rota-destino" class="form-input"
                            placeholder="Ex: Ipanema, Rio de Janeiro"
                            onkeydown="if(event.key==='Enter') buscarEndereço('destino')">
                        <button class="search-btn" onclick="buscarEndereço('destino')">
                            <i class="bi bi-search"></i> Buscar
                        </button>
                    </div>

                    <button class="btn-calcular-rota" onclick="calcularRotaAutomatica()">
                        <i class="bi bi-arrow-left-right"></i>
                        Calcular Rota
                    </button>

                    <div id="rota-info"
                        style="display: none; margin-top: 16px; padding: 12px; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px;">
                        <div style="color: #10b981; font-weight: 600; margin-bottom: 8px;">
                            <i class="bi bi-check-circle-fill"></i> Rota Calculada
                        </div>
                        <div style="display: flex; gap: 16px; font-size: 13px; color: #cbd5e1;">
                            <span><strong>Distância:</strong> <span id="rota-Distância">-</span></span>
                            <span><strong>Tempo:</strong> <span id="rota-tempo">-</span></span>
                        </div>
                    </div>
                </div>

                <!-- Modo Manual -->
                <div id="modo-manual" class="modo-content" style="display: none;">
                    <div
                        style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(217, 119, 6, 0.1) 100%); border: 2px solid rgba(245, 158, 11, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="color: #f59e0b; font-weight: 700; margin-bottom: 12px; font-size: 16px;">
                            <i class="bi bi-info-circle-fill"></i> Como funciona
                        </div>
                        <ul style="font-size: 14px; color: #cbd5e1; margin: 0; padding-left: 20px; line-height: 1.8;">
                            <li><strong>Clique</strong> no mapa para adicionar pontos-chave numerados</li>
                            <li><strong>Arraste</strong> os pontos vermelhos para reposicionar</li>
                            <li><strong>Duplo-clique</strong> em um ponto para removAª-lo</li>
                            <li>A rota <strong style="color: #10b981;">verde</strong> e recalculada automaticamente
                                seguindo as vias</li>


                            <li>Use <strong>"Desfazer"</strong> para remover pontos</li>
                            <li>Clique em <strong>"Finalizar Rota"</strong> quando terminar</li>
                        </ul>
                    </div>

                    <div style="text-align: center; padding: 30px 20px; position: relative; z-index: 100;">
                        <button class="btn-iniciar-desenho" id="btn-iniciar-desenho-manual">
                            <i class="bi bi-pencil-fill"></i>
                            <span>Iniciar Desenho no Mapa</span>
                        </button>
                        <div style="color: #64748b; font-size: 12px; margin-top: 12px;">
                            O modal sera fechado e vocAª podera desenhar no mapa
                        </div>
                    </div>
                </div>

                <!-- Dados da Rota (comum para ambos) -->
                <div id="dados-rota" style="display: none;">
                    <hr style="border: 1px solid rgba(255,255,255,0.1); margin: 20px 0;">

                    <div class="form-group">
                        <label class="form-label">Nome da Via *</label>
                        <input type="text" id="nova-rota-nome" class="form-input" placeholder="Ex: Avenida AtlA¢ntica"
                            required>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Classificacao Viaria *</label>
                        <select id="nova-rota-hierarquia" class="form-select" required>
                            <option value="">Selecione...</option>
                            <option value="Estrutural">Estrutural</option>
                            <option value="Arterial primária">Arterial primária</option>
                            <option value="Arterial secundária">Arterial secundária</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Trecho (Opcional)</label>
                        <input type="text" id="nova-rota-trecho" class="form-input"
                            placeholder="Ex: Copacabana ate Ipanema">
                    </div>

                    <div class="form-group">
                        <label class="form-label">ObservacAµes</label>
                        <textarea id="nova-rota-obs" class="form-input" rows="3"
                            placeholder="InformacAµes adicionais..."></textarea>
                    </div>
                </div>
            </div>

            <div class="nova-rota-footer">
                <button class="nova-rota-btn secondary" onclick="cancelarNovaRota()">
                    <i class="bi bi-x-circle"></i>
                    Cancelar
                </button>
                <button class="nova-rota-btn primary" id="btn-salvar-rota" onclick="salvarNovaRota()"
                    style="display: none;">
                    <i class="bi bi-check-circle-fill"></i>
                    Salvar Rota
                </button>
            </div>
        </div>
    </div>


    <!-- ========================================
     🌙 SISTEMA DE TEMA CLARO/ESCURO
     ======================================== -->
    <script>
        (function () {
            // console.log('🎨 Inicializando Sistema de Temas COR...');

            let currentTheme = localStorage.getItem('cor-theme') || 'light';

            // Aplicar tema iMédiatamente
            if (currentTheme === 'dark') {
                document.body.classList.add('dark-theme');
            }

            function applyTheme(theme) {
                currentTheme = theme;

                if (theme === 'dark') {
                    document.body.classList.add('dark-theme');
                    updateThemeButton('sun', 'Tema Claro');
                    // console.log('🌙 Tema escuro ativado');
                } else {
                    document.body.classList.remove('dark-theme');
                    updateThemeButton('moon', 'Tema Escuro');
                    // console.log('☀️ Tema claro ativado');
                }

                localStorage.setItem('cor-theme', theme);
            }

            function toggleTheme() {
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                applyTheme(newTheme);
            }

            function updateThemeButton(icon, tooltip) {
                const button = document.getElementById('theme-toggle');
                if (!button) return;

                const iconElement = button.querySelector('i');
                const spanElement = button.querySelector('span');

                if (iconElement) {
                    iconElement.className = `bi bi-${icon}-fill`;
                }

                if (spanElement) {
                    spanElement.textContent = tooltip;
                }

                button.setAttribute('title', tooltip);
            }

            function init() {
                const themeButton = document.getElementById('theme-toggle');

                if (themeButton) {
                    themeButton.addEventListener('click', toggleTheme);
                    applyTheme(currentTheme);
                    // console.log('✅ Botío de tema conectado!');
                } else {
                    console.warn('⚠️ Botío #theme-toggle nío encontrado');
                }
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        })();
    </script>
</body>

</html>